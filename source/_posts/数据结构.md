---
title: 数据结构
date: 2022-02-14 17:53:07
tags:
---
栈、队列、双端队列、
<!-- more -->

# 栈
先进后出LIFO
## 应用
函数执行、历史记录回退
## 实现
### 基于数组

```
class Stack{
    constructor(){
        this.items = [];
    }
    push(item){
        this.items.push(item);
    }
    pop(){
        if(this.isEmpty()) return ;
        return this.items.pop();
    }
    peek(){
        return this.items[this.items.length - 1];
    }
    size(){
        return this.items.length;
    }
    isEmpty(){
        return this.items.length === 0;
    }
    clear(){
        this.items = [];
    }
    toString(){
        return this.items.toString();
    }
}
```
两个问题： 1、实例的items不是私有变量，可以随意修改。
2、基于数组创建的stack类，方法的实现都是对数组的循环。

对于问题2，可以基于对象来实现stack。
### 基于对象

```
class Stack{
    constructor(){
        this.items = {};
        this.count = 0;
    }
    push(item){
        this.items[this.count] = item;
        this.count++;
    }
    pop(){
        if(this.isEmpty()) return;
        this.count--;
        const result = this.items[this.count];
        delete this.items[this.count];
        return result
    }
    peek(){
        if(this.isEmpty()) return;
        return this.items[this.count - 1];
    }
    size(){
        return this.count;
    }
    isEmpty(){
        return this.count === 0;
    }
    clear(){
        this.items = {};
        this.count = 0
    }
    toString(){
        if(this.isEmpty()) return '';
        return Object.values(this.items).reduce((result,item) => {
            return `${result},${item}`
        })
    }
}
```

由于原型类没有私有属性，基于对象与基于数组创建的stack都有同样的问题，对于问题1，可以尝试用WeakMap来实现

### 基于WeakMap

```
const items = new WeakMap();
class Stack{
    constructor(){
        items.set(this, []);
    }
    push(item){
        const s = items.get(this);
        s.push(item);
    }
    pop(){
        const s = items.get(this);
        return s.pop();
    }
    peek(){
        const s = items.get(this);
        return s[s.length - 1];
    }
    size(){
        const s = items.get(this);
        return s.length;
    }
    isEmpty(){
        const s = items.get(this);
        return s.length === 0;
    }
    clear(){
        items.set(this, []);
    }
    toString(){
        const s = items.get(this);
        return s.toString();
    }
}
```

## 可以解决的问题
### 十进制转二进制

```
function decimalToBinary(num){
    let stack = new Stack();
    while(num > 0){
        stack.push(num % 2);
        num = Math.floor(num / 2);
    }
    // stack 0,1,0,1
    let binaryString = '';
    while(!stack.isEmpty()){
        binaryString = `${binaryString}${stack.pop()}`;
    }
    return binaryString
}
```

### 进制转换算法
36进制 待补充
1-9a-z 0123456789abcdefghijklmnopqrstuvwxyz
```
function baseConverter(num, base){
    let stack = new Stack(), str = '0123456789abcdefghijklmnopqrstuvwxyz';
    if(base < 2 || base > 36) return '';
    while(num > 0){
        stack.push(str[num % base]);
        num = Math.floor(num / base);
    }
    // stack 0,1,0,1
    let binaryString = '';
    while(!stack.isEmpty()){
        binaryString = `${binaryString}${stack.pop()}`;
    }
    return binaryString
}
```
# 队列与双端队列
先进先出FIFO

## 实现

```
class Queue{
    constructor(){
        this.items = {};
        this.count = 0;
        this.lowestCount = 0;
    }
    enqueue(item){
        this.items[this.count] = item;
        this.count++;
    }
    dequeue(){
        if(this.isEmpty()) return;
        const result = this.items[this.lowestCount];
        delete this.items[this.lowestCount];
        this.lowestCount++;
        return result;
    }
    peek(){
        return this.items[this.lowestCount];
    }
    size(){
        return this.count - this.lowestCount;
    }
    isEmpty(){
        return this.size() === 0;
    }
    clear(){
        this.items = {};
        this.count = 0;
        this.lowestCount = 0;
    }
    toString(){
        if(this.isEmpty()) return '';
        return Object.values(this.items).reduce((result, value) => {
            return `${result},${value}`;
        });
    }
}
```

## 双端队列 deque，或称double-ended queue

```
class Deque{
    constructor(){
        this.items = {};
        this.count = 0;
        this.lowestCount = 0;
    }
    addFront(item){
        if(this.isEmpty()){
            this.addBack(item);
        }else if(this.lowestCount > 0){
            this.lowestCount--;
            this.items[this.lowestCount] = item;
        }else{
            for(let i = this.count; i > 0; i--){
                this.items[i] = this.items[i-1];
            }
            this.items[0] = item;
            this.count++;
        }
    }
    addBack(item){
        this.items[this.count] = item;
        this.count++;
    }
    removeFront(){
        if(this.isEmpty()) return;
        const result = this.items[this.lowestCount];
        delete this.items[this.lowestCount];
        this.lowestCount++;
        return result;
    }
    removeBack(){
        if(this.isEmpty()) return;
        const result = this.items[--this.count];
        delete this.items[this.count];
        return result;
    }
    peekFront(){
        return this.items[this.lowestCount];
    }
    peekBack(){
        return this.items[this.count - 1];
    }
    size(){
        return this.count - this.lowestCount;
    }
    isEmpty(){
        return this.size() === 0;
    }
    clear(){
        this.items = {};
        this.count = 0;
        this.lowestCount = 0;
    }
    toString(){
        if(this.isEmpty()) return '';
        return Object.values(this.items).reduce((result, value) => {
            return `${result},${value}`;
        });
    }
}
```

## 应用
### 击鼓传花

```
/**
* 此程序每次传花都是第一个人拿着花。传给第二个人……
* @param {elementList} array 多少人参与游戏
* @param {num} number 传几个人淘汰一个人
*/
function hotPotato(elementList, num){
    let queue = new Queue();
    elementList.forEach(item => queue.enqueue(item));
    while(queue.size > 1){
        for(let i = 0; i < num; i++){
            queue.enqueue(queue.dequeue());
        }
        queue.dequeue();
    }
    return queue.peek();
}
```

### 检查是否回文字
```
/**
* 回文字：左右颠倒，还是原来的文字
* @param {str} stirng 
*/
function palindromeChecker(str){
    let deque = new Deque();
    let len = str.length;
    for(let i = 0; i < len; i++){
        deque.addBack(str.charAt(i));
    }
    while(deque.size() > 1){
        if(deque.removeFront() !== deque.removeBack()){
            return false;
        }
    }
    return true;
}
```
# 链表
数组插入删除中间元素，需移动其它元素，因此诞生链表这种数据结构

链表上的每个节点

```
class Node{
    constructor(element){
        this.element = element;
        this.next = null;
    }
}
```

## 单向链表

```
class LinkedList{
    constructor(){
        this.head = undefined;
        this.count = 0;
        this.equelFn = function(ele1, ele2){
            return ele1 === ele2;
        }
    }
    push(element){
        let node = new Node(element), lastNode = this.head;
        if(this.count === 0){
            this.head = node;
        }else{
            while(lastNode.next){
                lastNode = lastNode.next;
            }
            lastNode.next = node;
        }
        this.count++;
    }
    insert(element, index){
        if( index < 0 || index > this.count) return undefined;
        let previousNode = this.getElementAt(index - 1);
        let nextNode = this.getElementAt(index);
        let node = new Node(element);
        if(index === 0){
            this.head = node;
            node.next = nextNode;
            return;
        }
        // if(index === this.count){
        //     previousNode
        // }
        previousNode.next = node;
        node.next = nextNode;
        this.count++;
    }
    getElementAt(index){
        if( index < 0 || index >= this.count) return undefined;
        let node = this.head;
        for(let i = 1; i <= index; i++){
            node = node.next;
        }
        return node;
    }
    remove(element){
        let position = this.indexOf(element);
        return this.removeAt(position);
    }
    indexOf(element){
        let position = -1, index = -1, node = this.head;
        while(node){
            index++
            if( this.equelFn(element, node.element) ){
                position = index;
                break;
            }
            node = node.next;
        }
        return position;
    }
    removeAt(index){
        if( index < 0 || index >= this.count) return undefined;
        let previousNode = null, 
            node = null,
            nextNode = null;
        if(index === 0 ){
            node = this.head;
            this.head = node.next;
            return node;
        }
        previousNode = this.getElementAt(index -1);
        node = previousNode.next;
        nextNode = node.next;
        if(!nextNode){
            previousNode.next = undefined;
        }else{
            previousNode.next = nextNode;
        }
        this.count--;
        return node;
    }
    isEmpty(){
        return this.count === 0;
    }
    size(){
        return this.count;
    }
    toString(){
        let str = this.head.element, nextNode = this.head.next;
        while( nextNode ){
            str = `${str},${nextNode.element}`;
            nextNode = nextNode.next;
        }
        return str;
    }
}
```
## 双向链表

```
Class DoublyNode extends Node{
    constructor(element){
        super(element);
        this.prev = undefined;
    }
}
class DoublyLinkedlist extends LinkedList{
    constructor(){
        super();
        this.tail = undefined;
    }
    insert(element, index){
        if(index < 0 || index > this.count) return false;
        let currentNode = New DoublyNode(element)
        if(index === 0){
            if(this.count === 0){
                this.head = currentNode;
                this.tail = this.head;
            }else{
                let nextNode = this.getElementAt(index),
                this.head = currentNode;
                currentNode.next = nextNode;
                nextNode.prev = currentNode;
            }
        }else if(this.count === index){
            let prevNode = this.tail;
            prevNode.next = currentNode;
            currentNode.prev = prevNode;
            this.tail = currentNode;
        }else{
            let nextNode = this.getElementAt(index),
            prevNode = nextNode.prevNode;
            nextNode.prev = currentNode;
            currentNode.prev = prevNode;
            prevNode.next = currentNode;
            currentNode.next = nextNode;
        }
        this.count++;
        return true;
    }
    removeAt(index){
        let removeNode = this.getElementAt(index);
        if(!removeNode) return false;
        let prevNode = removeNode.prev,
            nextNode = removeNode.next;
        if(prevNode && nextNode){
            prevNode.next = nextNode;
            next.prev = prevNode;
        }else if(prevNode){
            this.tail = prevNode;
        }else if(nextNode){
            this.head = nextNode
        }else{
            this.head = undefined;
            this.tail = undefined;
        }
        this.count--;
        return removeNode;
    }
}
```