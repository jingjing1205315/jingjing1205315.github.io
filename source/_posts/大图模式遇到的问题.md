---
title: 大图详情页问题
date: 2020-09-23 20:00:00
tags: 
---

## 检测全面屏

```
function judgeBigScreen() {  
    // 这里根据返回值 true 或false ,返回true的话 则为全面屏
     var result = false;
     var rate = window.screen.height / window.screen.width;
     var limit =  window.screen.height == window.screen.availHeight ? 1.8 : 1.65; // 临界判断值
 
     // window.screen.height为屏幕高度
     //  window.screen.availHeight 为浏览器 可用高度
     if (rate > limit) {
         result = true;
     }
     return result;
 }
```


##  overflow:hidden和-webkit-overflow-scrolling:touch引起的一系列问题

1. 有-webkit-overflow-scrolling:touch属性，会导致正常的横屏滑动（某些ios），划过去不渲染的问题。需上下滑动，才能渲染出。

2. 去掉overflow:hidden和-webkit-overflow-scrolling:touch，导致页面之前的scroll事件监听都失效了。需监听document.documentElement。

3. 滚动到指点位置的设置，Iphone中设置document.documentElement.scrollTop；Android中设置document.body.scrollTop；
    
4. 输入完成点击支付，软键盘收起，在某些手机支付按钮的焦点并不在你可视的位置。为解决这个问题设置的收起软键盘后scrollTop(0,0)。还会发现，弹窗中的支付按钮，点击时，软键盘收起，并没有跳转到支付页。需在软键盘关闭后再点击一次。去掉overflow:hidden和-webkit-overflow-scrolling:touch，无需再设置scrollTop(0,0)。在软键盘打开的情况下，点击支付按钮，就可以调走。

总结：如非必要，不要用-webkit-overflow-scrolling:touch！
不要用-webkit-overflow-scrolling:touch！
不要用-webkit-overflow-scrolling:touch！
都是坑！

## 冒泡导致问题
前端埋点用来数据统计。
用冒泡事件监听body，在遇到需跳转的按钮时，click事件很少能捕捉到。而监听当前元素的点击，发送的click事件则大部分可以被捕捉。

--在跳转的按钮上，另有click需发送请求，最好不要用冒泡在body上监听。往往服务端接受不到此请求。

--又遇到一种情况，但点击“查看更多“时，会变为“加载中……“，“查看更多”按钮上的埋点，如果加在父标签上，事件的发送都是通过body上的click检测父标签有没有一个属性，有则发送埋点请求。
这时就遇到问题了。点击的目标元素event.target会一直存在，即使父标签已移除，依然可以拿到event.target。但event.target.parentNode这时候就会使null。检测它上面的属性就会检测不到。
event.target从DOM中删除了，但还存在内存中。

## swiper要定义好高度

高度自适应且slide图片有大有小时，会在某些ios手机上滑动方向相反的一边闪屏。

## 1px问题

设计稿上1px的边框，通常我们会用0.5px来实现，一般在ios可以表现正常。但在某些Android手机可能会出现线条出不来的问题。
解决：设为1px；用transform:scale(0.5),来启动GPU加速，就会正常渲染

[关于GPU](https://baijiahao.baidu.com/s?id=1564835558133838&wfr=spider&for=pc)

## referre问题
chrome浏览器重85后的版本,meta---referrer的content默认是改为'strict-origin-when-cross-origin',即跨域请求时，后端拿到的referrer只包括origin，不含路径。在之前的版本上默认no-referrer-when-downgrade，即降级从https到http时，才会只传origin。

```
<meta name="referrer" content="no-referrer-when-downgrade" />
```

content后面的“属性值”，常见有以下几种：

1. no-referrer：任何情况下都不发送Referrer信息；
2. no-referrer-when-downgrade：仅当协议降级（如从HTTPS页面跳转到HTTP页面）时不发送Referrer信息。是大部分浏览器默认策略。

3. origin：发送只包含host部分的referrer信息，也就是只包含了协议和域名的url，不包含域名后面部分，比如，来源网页url是https://www.liudaima.com/1.html，但referrer值只包含http://www.liudaima.com；

4. origin-when-cross-origin：仅在发生跨域访问时，发送只包含host的Referer信息，但在同域下还是完整的，而只有协议、域名和端口都一致时，浏览器才认为是同域。

5. unsafe-url：全部都发送Referrer信息，是最宽松，也是最不安全的策略

参考文章：
1. [meta标签name="referrer"属性的写法和用法](https://www.liudaima.com/a/132.html)
2. [MDN:Referrer-Policy ](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy)
3. [chrome 修改日志](https://developers.google.cn/web/updates/2020/07/referrer-policy-new-chrome-default)

    
    
 
 

