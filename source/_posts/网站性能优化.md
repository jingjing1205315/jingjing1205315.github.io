### 文件放在合适的位置。
***Css样式文件链接尽量放在头部** 
Css加载不会阻碍DOM tree解析，但是会阻塞到DOM tree渲染，也会阻塞后面js执行。任何body元素之前，可以确保在文档部分中解析了所有的css样式（内联和外联），从而减少了浏览器必须重排文档的次数，如果放置页面底部，就要等待最后一个css文件下载完成，此时会出现“白屏”影响用户体验。

***Js引用放在html底部** 
防止js的加载、解析、执行对阻塞页面后续元素的正常渲染。

### 精简html代码，

**减少html的嵌套**
**减少当节点数**
**减少无语意代码。如消除浮动。**
**删除http或者https，如果url的协议头和当前页面的协议头一致的，或者此url在多个协议里头都是可用的，则可以考虑删除协议头**
**删除多余的空格，换行符、缩进和不必要的注释**
**省略冗余标签和属性**
**使用相对路径的url**

### 增强用户体验
**设置favicon.ico**
网站如果不设置favicon.ico，控制台会报错，另外页面加载过程中也没有图标loading过程,同时也不利于记忆网站品牌，建议统一添加

**增加首屏必要的css和js**

页面如果需要等待所有的依赖解释和css加载完成才显示，则在渲染过程中，页面会一直显示空白，影响用户体验，建议增加首屏必要的css和js，比如页面框架背景图片或者loading图标,内联在html页面中，这样做首屏能快速显示出来，相对减少用户对页面加载等待过程.(比如新浪微博M站页面框架)



### 提升css渲染性能

**谨慎使用expensive属性**
如:nth-child伪类；position:fix的定位

**尽量减少样式层级数**

如div ul li span i{ color: blue;}

**尽量避免使用占用过多的CPU和内存的属性**

如text-indent: -99999 px

**尽量避免使用或电量大的属性**

如CSS3 3D transforms、 CSS3 transitions、 opacity

### 合理使用CSS选择器

**尽量避免使用CS表达式**
background-color: expression((new data()).getHours()/2?'#fff':'#000');

**尽量避免使用通配选择器**
body > a{ font-weight:blod;}

**尽量避免类正则的属性选择器**
*=，|=， ^=, &=

### 精简css代码
**使用缩写语句**
**删除不必要的零**
**删除不必要的单位，如px**
**删除过多分好**
**删除空格和注释**
**尽量减少样式表的大小**
### 合理使用Web Fonts
**将字体部署在cdn上**
**将字体以base64形式保存在css中，并通过localStorage进行缓存**
**谷歌字体库，因为某些不可抗拒原因，应该使用国内托管服务**

### Css动画优化
**尽量避免同时动画**
**延迟动画初始化**
**结合svg**

### JS优化总体原则
**当需要时才优**
**考虑可维护性**

### Js变量和函数优化
**尽量使用ID选择器**
**尽量避免使用eval**
**Js函数尽可能保持简洁**
**使用事件节流函数**
**使用事件委托**

### 提升js文件加载性能
**加载元素的顺序，css文件放在\<head\>里，js文件放在\<body\>里**
### Js动画优化
**尽量避免添加大量js动画**
**尽量使用css3动画**
**尽量使用Canvas动画**
**合理使用RequestAnimationFrame动画代替setTimeout(callback)、setInterval(callback)无法保证callback回调函数的执行时机** 

### 合理使用缓存
**合理缓存DOM对象**
**缓存列表长度**
**使用可缓存的AJAX**
## 9 JavaScript：如何对JavaScript进行缓存优化
### Cookie
通常有浏览器存储，然后将cookie与每个后续请求一起发送到同一服务器。收到http请求时，服务器可以发送带有cookie的header头，可以给Cookie设置有效时间。

应用于：
* 会话管理：登录名、购物车商品、游戏得分或服务器应要记录的其他任何内容
* 个性化：用户首选项、主题或其他设置
* 跟踪：记录和分析用户行为，比如埋点



### Session storage
建立一个本地存储的键/值对
应用于：页面应用页面之间传值

### IndexedDB
索引数据库
应用于:
* 客户端存储大量结构化数据
* 没有网络连接的情况下使用(比如Google DOC、石墨文档）
* 将冗余、很少修改、但经常访问的数据，以避免随时从服务器获取数据

### Local storage
本地存储
应用于：
* 缓存静态文件内容js/css(比如百度M站首页)
* 缓存不常变更的API接口数据
* 储存地理位置信息
* 浏览在页面的具体位置

### JS模块化加载方案和选型
**commonJS**
* 旨在web浏览器之外为JavaScript建立模块生态系统。
* Node.js 模块化方案受commonJS
**Amd(Asynchronous Module Definition)(异步模块定义)规范
* RequireJS模块化加载器:基于AMD API实现
**CMD(Common Module Definition)(通用模块定义)规范
* SeaJS模块加载器:遵循CMD API的编写
**ES6 import**

### Css
* 避免过多样式嵌套
* 避免使用css表达式
* 使用绝对定位,可以让动画元素脱离文档流
* 避免使用table布局
* 尽量不使用float布局
* 图片最好设置好width和height
* 尽量简化浏览器不必要的任务，减少页面重新布局
* 使用viewpoint设置屏幕缩放级别
* 避免频繁设置样式，最好把新style属性设置完成后,进行一次性更改
* 避免使用引流引起回流/重绘的属性，最好把相应变量缓存起来

JS
**最小化回流和重排**
* 为了减少回流发生次数，避免频繁或操作DOM,可以合并多次对DOM修改，然后一次性批量处理
**控制绘制过程和绘制区域**
* 绘制过程开销比较大的属性设置应该尽量避免减少使用
* 减少绘制区域范围

## 12 DOM编程优化：怎样控制DOM大小并简化DOM操作

### 控制DOM大小
* 众所周知，页面交互卡顿和流畅度很大一部分原因就是页面有大量的DOM元素，想象一下，从一个上万个节点的DOM Tree上，使用querySelectorAll或者getElementByTagName方法查找某一个节点,是非常耗时的.另外元素绑定事件、事件冒泡或事件捕获的执行也会相对耗时

* 通常控制DOM大小的技巧包括：
  * 合理业务逻辑
  * 延迟加载即将呈现的内容

### 简化DOM操作
* 对DOM节点的操作处理后统一插入到DOM Tree中。
* 可以使用fragment，尽量不在页面DOM Tree里直接操作.
* 现在流行的框架Angular、react、 vue，都在使用虚拟DOM技术，通过diff算法简化和减少DOM操作

## 13静态文件：有哪些常用的压缩工具？

### 静态文件压缩工具介绍
* html压缩工具，
  * html-minifier
* CSS压缩工具
  * clean-css
* JS压缩工具
  * uglify-js
  * 使用方法：uglifyjs in.js -o out.js
  
### 静态文件打包方案
* 公共组件拆分
* 压缩:JS/CSS/图片
* 合并:JS/CSS文件合并, CSS Sprite
* Combo: JS/CSS文件 Combo http://cdn.com/??a.js,b.js内容

## 静态文件:版本号更新,你应该遵循哪些策略

### 静态文件版本号更新策略
* 缓存更新
  * CDN或ng后台刷新文件路径，更新文件header头
* 文件name.v1-v100.js
  * 大功能迭代每次新增一个大版本，比如由v1到v2
  * 小功能迭代新增加0.0.1或者0.1.0，比如从v1.0.0至v1.0.1
  * 年末ng统一配置所有版本302至最新版

* 时间戳.文件name.js
  * 以每次上线时间点做差异
* 文件hash.文件name.js
  * 以文件内容hash值做key，每次上线,文件路径不一致

![]()
### 前端构建工具介绍和选型建议
* Grunt
  * 最早，一个项目需要定制多个小任务和引用多个插件（质量参差不齐）
* Gulp
  * 通过流（Stream）来简化多个任务间的配置和输出，配置代码相对较少
* Webpack
  * 预编译，中间文件在内存中处理，支持多种模块化，配置相对很简单
* FIS
* JDF

### webpack打包优化
* 定位体积大的模块
* 删除没有使用的依赖
* 生产模式进行公共依赖包抽离
* 开发模式进行DLL&DllReference方案优化

