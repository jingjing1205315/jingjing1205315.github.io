---
title: 跨域
date: 2020-09-07 08:00:00
tags: 
---
跨域的几种方式
<!--more-->
同源：
协议相同
域名相同
端口相同

非同源限制
LocalStore 和 IndexDB 无法读取。这两个显然是不能读取的，但是 cookie 有点不一样，放在后面单独说明
DOM 无法获取,比如如法在页面 A 中通过 iframe 获取异源页面 B 的 DOM
AJAX 请求无法读取（可以发送请求，但是无法读取到请求结果。比如在页面 A 中请求异源接口 B，请求会正常发出处理，但是在页面 A 中无法获取请求结果，除非响应头 Access-Control-Allow-Headers 中允许了页面 A 的源，这样就能读取到结果）
  但是这里有个例外，所有带“src”属性的标签都可以跨域加载资源，不受同源策略的限制，这样你应该可以想到一个比较古老的跨域解决方案（JSONP）,同时这个特性也会被用作 CSRF 攻击。
### 1 JS设置document.domain实现跨域---iframe DOM操作

这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域.
Javascript出于对安全性的考虑，而禁止两个或者多个不同域的页面进行互相操作。
相同域的页面在相互操作的时候不会有任何问题。

有另一种情况，两个子域名：
aaa.xxx.com
bbb.xxx.com
aaa里的一个网页(a.html)引入了bbb 里的一个网页(b.html)
通过Javascript，将两个页面的domain改成一样的，
需要在a.html里与b.html里都加入：

代码如下:
```
document.domain = "***.net"
```
这样这两个页面就可以互相操作了。也就是实现了同一基础域名之间的"跨域"。
### http 请求跨域

 在前端开发中经常会遇到跨域的问题，比如前后端分离中前后端部署在不同的端口上，或者在前端页面中需要向另外一个服务请求数据，这些都会被跨域所阻挡。
目前主要有以下几种办法解决跨域问题：

1、关闭浏览器同源检查(方法：https://blog.csdn.net/cgs1999/article/details/90751757)
  这个太暴力，也太不安全了，不用考虑。

2、jsonp 实现跨域请求
  前面说过了浏览器对于带 src 属性的标签都可以跨域的。因此 jsonp 的实现流失利用了这个特性，在页面中动态插入一个`<script/>`标签,然后他的 src 属性就是接口调用地址，这样就能访问过去了，然后再讲返回内容特殊处理成立即执行的函数，这样就看起像进行了一次跨域请求。之所以不推荐这种方式，主要有以下两个原因：

1) 实现复杂,且需要前后台同时修改才能实现
2)只能进行 get 请求

3、服务器设置运行跨域
  这种方法只需要后台做处理便能实现跨域，前面说的 http 跨域请求是能够发出去的，只是不能接收，那我们只要在响应头Access-Control-Allow-Headers中加入允许请求的地址即可，以,分隔，同时*代表所有地址都允许。比如：
  
  
```
Access-Control-Allow-Origin: http://localhost:8081,http://localhost:8082
```


本方法是较为常用的一种跨域办法,只需简单修改服务端代码即可。

但是会发现，这些跨域的请求，cookie并未被携带，这时，我们就要加上 withCredentials: true 当前请求为跨域类型时是否在请求中协带cookie

**后端增加 response 头信息Access-Control-Allow-Origin，且必须指定域名，而不能指定为***

[ajax中的withCredentials使用效果](https://blog.csdn.net/chjj0904/article/details/90268813)

[CORS 跨域 access-control-allow-headers 的问题](https://blog.csdn.net/yasha009/article/details/78784620)

4、请求代理
  这也是非常常用的一种跨域方法。跨域限制只是浏览器限制，服务端并没有这个概念，因此我们在前端还是请求同域地址，然后在服务端做一个代理，将请求转发到真正的 ip 和端口上。通常使用 nginx 实现端口转发，比如下面一段 nginx 配置：

```
server {
    # /test1/abc 转发到 http://a.com:8011/abc
    location /test1/ {
        proxy_pass http://a.com:8011/;
    }

    # /test2/abc 转发到 http://b.com:8011/main/abc
    location /test2/ {
        proxy_pass http://b.com:8011/main/;
    }

    # /test3/abc 转发到 http://c.com:8011/test3/abc
    location /test3/ {
        proxy_pass http://c.com:8081;
    }
}
```

### cookie 同源策略(仅限制域名)

cookie 的同源策略是通过“Domain“和“path“两个部分来共同确认一个 cookie 在哪些页面上可用。

1、设置cookie的domaim和path
Domain确定这个 cookie 所属的域名，不能带端口或协议。因此 cookie 便可在不同端口/不同协议下共享,只要域名相同。有一个例外是父子域名间也能共享 cookie，只需将 Domain 设置为.父域名或者父域名（不带.）。***domain设为主域名即baidu.com或者.baidu.com,那么cookie在任何百度的子域名下都可共享*** www.baidu.com仅是baidu.com的子域名，同样受限制。Í

  path就简单多了，通过 Domain 确定哪些域名可以共享 cookie，然后在通过path来确定 cookie 在哪些路径下可用。使用/表示所有路径都可共享。

具体如下：

```
Domain : example,path : /a可获取 cookie:http://example:8081/a,https://example:8081/a
Domain : example,path : /可获取 cookie:http://example:8081/a,https://example:8081/a , http://example:12/abcd
Domain : .example,path : /a可获取 cookie:http://example:8081/a , https://localhost:8081/a , http://test.example:889/a

注意:在跨域请求中，即时目标地址有 cookie 且发起请求的页面也能读取到该 cookie，浏览器也不会将 cookie 自动设置到该跨域请求中。比如在http://localhost:8082/a页面中请求http://localhost:8081/abc,这两个地址下拥有共享cookie，http请求也不会携带cookie。
```
2、设置反向代理，使两个页面位于同一domain和path下。
3、jsonp方法
文件a/b处于相同域下，不同路径，设置的cookie在b路径下。
a.html访问b路径下的jsonp文件。此jsonp文件可以访问b下的cookie。同时可以设置cookie的路径为a。这样a就可以拿到b下的cookie。

猜测（未经实验）：a通过jsonp请求不用b域上的文件。那个文件能拿到b域上的cookie。回传给a，就可以试想cookie的跨域访问
4、nodejs superagent（可参考下方参考文章）
5、同一域下，不同工程之间cookie携带
（1）. 使用jsonp格式发送
（2）. ajax请求中加上字段 xhrFields: {withCredentials: true}，这样可以携带上cookie。这样后台配置就出现了限制，需要配置一个解决跨域访问的过滤器，而且header字段Access-Control-Allow-Origin的值不能为"*", 必须是一个确定的域。
### image跨域
在页面上src加载图片资源无跨域问题。但canvas绘图时，加载的资源图和当前域名不使同一域名时，就会加载不出来。

```
img.src="shareImages/cz.jpg";
        img2.src=app25.newLevelImage;//图片的路径
// 解决图片的跨域问题
image.setAttribute("crossOrigin",'anonymous')    // 添加改代码， 防止跨域
  image.src =  item.src + '?v=3' ;   //添加后缀， 防止缓存；
 ```

cnd源站添加header头
```
add_header Access-Control-Allow-Origin *;
add_header Access-Control-Allow-Headers X-Requested-With;
add_header Access-Control-Allow-Methods Get, Post, Options;
```

第三方图片：
把第三方图片通过php处理，然后直接输出图片，就可以使用，需要注意的是在请求后台的时候需要用encodeURIComponent转码，不然碰到图片链接里带%号的就呵呵了

```
let url = encodeURIComponent('图片地址.jpg')

this.toDataURL(`后台接口地址.php?url=${url}`, function(dataUrl) {

      self.dataUrl = dataUrl

 })

```

参考地址 https://www.jianshu.com/p/f1d0b107e912
参考地址 https://www.jianshu.com/p/18823f15b31d

### 参考文章
https://www.cnblogs.com/lonelyshy/p/10179762.html
https://www.cnblogs.com/wuyoucao/p/11075435.html

https://www.cnblogs.com/hujunzheng/p/5744755.html

