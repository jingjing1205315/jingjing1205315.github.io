---
title: '网页性能优化'
date: 2021-03-01 09:42:28
tags:
---
一次性能优化实战经验总结
<!--more-->
### 关键节点数据采集
如html加载完成时间点、js加载完成时间点、接口请求时间点、首屏渲染时间点

测试了请求6个并行接口和请求一个合并接口的时间，大致相同。400ms左右。后端检测到他们的时间是几十ms。优化意义不大。

因此，这次优化工作的重点放在前端。
### 将首屏串行接口请求全部改为并行请求。
若依赖前一接口的返回，则和后端沟通是否合并接口。
### 对需要登录的页面，去掉页面最开始是否登录的接口请求。
在请求首页页面数据接口时，会知道用户是否登录，如页面需强制登录，则根据某一字段判断是否跳转登录。这样，就减少了一个串行接口，大约减时400ms。



接下来是页面级的优化：
### 首屏组件及任何父组件都应为同步加载
对vue开发的网站，会先加载html，再加载html里引入的app.js，js中的代码去渲染页面，首屏代码不用同步方式加载的话，app.js下载完成，还需要串行去加载渲染首屏的的js。时间就被浪费掉了。

然后发现，app.js太大了，于是决定对js进行拆包。

### 最大化利用浏览器并行请求数对首屏拆包，减小包的大小。用webpack-bundle-analyzer分析哪些可拆

以chrome为例：同域名下最大并行请求数为6个。注意看有没有同域下的css、img占用资源数是否影响js的并行。

拆完包，发现首屏渲染速度反而变慢了……
### 首屏同步加载部分组件
分析变慢的原因是整体包的大小，比未拆包前稍微大一点，而带宽资源有限。于是想首屏只加载部分组件，将整体包大小减小了1/3,上线后首屏渲染速度明显大幅提升


 **放在head中的js文件比body中的js文件加载优先级高**

### 预加载

prefetch 预加载其它页面所需的资源

```
import(
  `./utilities/divide`
  /* webpackPrefetch: true */
  /* webpackChunkName: "utilities" */
)
```
以上的导入会让<link rel="prefetch" as="script" href="utilities.js">被添加至页面的头部。因此浏览器会在空闲时间预先拉取该文件。


异步chunk会和父级chunk并行加载(webpack4.46并未实验成功)

```
/* webpackPreload: true */
```



参考：[Webpack 4教程 - 第八部分 使用prefetch和preload进行动态加载](https://www.cnblogs.com/powertoolsteam/p/10873677.html)

### 去掉ajax的mothed为option的请求
由于浏览器的同源策略，非简单请求会发送option进行预检。猜测预检请求会影响加载速度，待验证

