---
title: 算法学习
date: 2021-10-10 22:03:46
tags:
---
快速排序，两数之和，fibonacci, 生成dom树

<!--more-->

# 快速排序

```
function sortQuick(arr){
    // 当数组小于等于一个元素时，直接返回
    if(arr && arr.length <= 1) return arr;
    // 获取中间位置
    let middleIndex = Math.floor(arr.length / 2);
    // 获取中间位置的值,并从原数组中删除该值
    let middleValue = arr.splice(middleIndex, 1)[0];
    let prevArr = [], nextArr = [], middleArr = [middleValue];
    for( let i = 0, l = arr.length; i < l; i++){
        // 循环剩余原数组，将值与中间值比较，小的放到preArr，大的放到nextArr，相等的放到middleArr
        if(arr[i] > middleValue) nextArr.push(arr[i]);
        else if(arr[i] < middleValue) prevArr.push(arr[i]);
        else middleArr.push(arr[i]);
    }
    // 递归遍历prevArr，与nextArr，并将prevArr，middleValue，nextArr合并
    return sortQuick(prevArr).concat(middleArr, sortQuick(nextArr));
}
console.log(sortQuick([1,2,2,8,3, 3])) // [ 1, 2, 2, 3, 3, 8 ]
```

# 两数之和

时间复杂度o(n), 空间复杂度o(n);

```
/**
  * 
  * @param numbers int整型一维数组 
  * @param target int整型 
  * @return int整型一维数组
  */
function twoSum( numbers ,  target ) {
    // write code here
    if(!numbers || numbers.length < 2 ) return [];
    let obj = {[numbers[0]]: 1};
    for(let i = 1,l = numbers.length; i<l; i++){    
        let tem = target - numbers[i];
        if(obj[tem] >= 1){
            return [obj[tem], i+1]
        }
        obj[numbers[i]] = i+1;
    }
}
module.exports = {
    twoSum : twoSum
};
```
用原始for循环

```
let arr = [1,2,3,4,5,0];
function sum(arr, target){
    let result= [];
    for(let i = 0; i < arr.length-1;i++){
        let temp = target - arr[i];
        for(let j = i+1; j< arr.length ;j++){
            if(arr[j] === temp){
                result.push([arr[i], temp]);
                arr.splice(j,1);
                break;
            }
        }
    }
    console.log(result) //[ [ 1, 4 ], [ 2, 3 ], [ 5, 0 ] ]
}
sum(arr, 5)
```
假如这里不是用for而是用forEach，首先第一层循环，不能停在倒数第二个；第二层也不能从i+1开始；其次也不可在第二层for循环找到元素时，中断循环。

```
let arr = [1,2,3,4,5,0];
arr.forEach((item, i) => {
    console.log('item', item) // 1,2,3,5,0
    if(i == 2) arr.splice(i,1);
})
```
删除了第3个，循环缺跳过了第四个。无法做到后退。

总结for和forEach的区别
- 循环不能选择开始和结束位置
- 循环不能中断
- 循环不能后退

# 斐波那契fibonacci

## 返回第n个斐波那契数。 f(1) = 1, f(2) = 1 等

```
// 时间复杂度o(n), 空间复杂度o(n);
// 通过全部用例 运行时间 2383ms 占用内存 77896KB
function fibonacci(n) {
    if(typeof n !== 'number') return '请输入一个正整数';
    let aFib = [1,1];
    for (let i = 2; i< n; i++){
        aFib.push(aFib[i-1]+aFib[i-2])
    }
    return aFib[n-1];
}
```

```
//????                 时间复杂度o(n), 空间复杂度o(nlogn);
// 通过全部用例 运行时间 1904ms 占用内存 77936KB
function fibonacci(n) {
    if(typeof n !== 'number') return '请输入一个正整数';
    if(n <= 2) return 1;
    return fibonacci(n-1)+fibonacci(n-2);
}
```

```
// 尾递归优化
// 通过全部用例 运行时间 2377ms 占用内存 77868KB
function fibonacci(n,pre1=1,pre2=1) {
    if(typeof n !== 'number') return '请输入一个正整数';
    if(n <= 2) return pre1;
    return fibonacci(--n, pre1+pre2, pre1);
}
```
## 斐波那契兔子
有一对兔子，长到第五个月的时候开始每个月都会生一对兔子，第n个月的时候会有多少对兔子
1
1
1
1
2
3
4
5
7
10
14
...

从第五个月起，f(n) = f(n-1)+f(n-4), 第n个月的兔子，首先包括前一个月的兔子数量；然后，这些兔子里，包含前四个月的兔子都已经成年了的，可以有多少对，在这个月就能生出来多少对。所以是f(n-1)+f(n-4);

```
function getRabbitsNumber(n, prev1 = 1, prev2 = 1,prev3 = 1,prev4 = 1){
    if(n < 5) return prev1;
    return getRabbitsNumber(n-1, prev1 + prev4, prev1, prev2, prev3 )
}
或者
function getRabbitsNumber(n){
    if(n < 5) return 1;
    return getRabbitsNumber(n-1)+ getRabbitsNumber(n-4)
}
```

# 生成dom树

```
function dom2json() {
    const jsContainer = document.querySelector("#jsContainer")

    function domJson(dom) {
        var obj = {}
        if (dom.nodeType == 1) {
            obj.tag = dom.tagName.toLocaleLowerCase()
            var attrs = getTagAttrs(dom)
            if (attrs) obj.attributes = attrs;
            
            obj.children = [];
            Array.from(dom.childNodes).filter(child => { // 这里用[...dom.childNodes]编译不过？？？？
                return !(child.nodeType == 3 && !child.textContent.trim())
            }).forEach((item,i)=>{
                obj.children.push(domJson(item))
            });
                
            
            
            return obj
        }
        if (dom.nodeType == 3) {
            let content = dom.textContent.trim();
            if(!content) return;
            obj.tag = 'text';
            obj.content = content
            return obj
        }
    }

    function getTagName(dom) {
        return dom.nodeName.toLocaleLowerCase().replace('#', '')
    }

    function getTagAttrs(dom) {
        var attr = Array.from(dom.attributes)
        var obj = {}
        attr.forEach(atr => obj[atr.name] = atr.value)
        return attr.length ? obj : null;
    }

    return domJson(jsContainer)
}
```
原生具备 Iterator 接口的数据结构如下：

Array
Map
Set
String
TypedArray
函数的 arguments 对象
NodeList 对象

```
// todo 这里还需要再测试
Array.from(dom.childNodes).filter(child => { // 这里用[...dom.childNodes]编译不过？？？？
```

# 烙饼问题
一个锅可以烙两张饼，30分钟可以出锅，一共三张饼，最短需要多少时间？
这么思考？
假如资源就是锅，资源同时给两个人用，做这件事需要耗时30分钟，假如只给一个人用，那么他的耗时就是15分钟。
资源是限量的（只有一口锅），可同时烤两张饼，那么就是每15分钟，换一张饼去烙。
30 / 2 * 3 = 45

假如同时可以烤3张饼，一共有四张饼，那么最短时间是 30 / 3 * 4 = 40, 每10分钟换一张饼烙
