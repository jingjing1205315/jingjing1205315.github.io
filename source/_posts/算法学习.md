---
title: 算法学习
date: 2021-10-10 22:03:46
tags:
---
快速排序，两数之和，fibonacci, 生成dom树, 烙饼问题, 车跑多远的问题, 整数翻转, 回文数, 罗马数字转整数，最长公共前缀

<!--more-->

# 快速排序

```
function sortQuick(arr){
    // 当数组小于等于一个元素时，直接返回
    if(arr && arr.length <= 1) return arr;
    // 获取中间位置
    let middleIndex = Math.floor(arr.length / 2);
    // 获取中间位置的值,并从原数组中删除该值
    let middleValue = arr.splice(middleIndex, 1)[0];
    let prevArr = [], nextArr = [], middleArr = [middleValue];
    for( let i = 0, l = arr.length; i < l; i++){
        // 循环剩余原数组，将值与中间值比较，小的放到preArr，大的放到nextArr，相等的放到middleArr
        if(arr[i] > middleValue) nextArr.push(arr[i]);
        else if(arr[i] < middleValue) prevArr.push(arr[i]);
        else middleArr.push(arr[i]);
    }
    // 递归遍历prevArr，与nextArr，并将prevArr，middleValue，nextArr合并
    return sortQuick(prevArr).concat(middleArr, sortQuick(nextArr));
}
console.log(sortQuick([1,2,2,8,3, 3])) // [ 1, 2, 2, 3, 3, 8 ]
```

# 两数之和

时间复杂度o(n), 空间复杂度o(n);

```
/**
  * 
  * @param numbers int整型一维数组 
  * @param target int整型 
  * @return int整型一维数组
  */
function twoSum( numbers ,  target ) {
    // write code here
    if(!numbers || numbers.length < 2 ) return [];
    let obj = {[numbers[0]]: 1};
    for(let i = 1,l = numbers.length; i<l; i++){    
        let tem = target - numbers[i];
        if(obj[tem] >= 1){
            return [obj[tem], i+1]
        }
        obj[numbers[i]] = i+1;
    }
}
module.exports = {
    twoSum : twoSum
};
```
用原始for循环

```
let arr = [1,2,3,4,5,0];
function sum(arr, target){
    let result= [];
    for(let i = 0; i < arr.length-1;i++){
        let temp = target - arr[i];
        for(let j = i+1; j< arr.length ;j++){
            if(arr[j] === temp){
                result.push([arr[i], temp]);
                arr.splice(j,1);
                break;
            }
        }
    }
    console.log(result) //[ [ 1, 4 ], [ 2, 3 ], [ 5, 0 ] ]
}
sum(arr, 5)
```
假如这里不是用for而是用forEach，首先第一层循环，不能停在倒数第二个；第二层也不能从i+1开始；其次也不可在第二层for循环找到元素时，中断循环。

```
let arr = [1,2,3,4,5,0];
arr.forEach((item, i) => {
    console.log('item', item) // 1,2,3,5,0
    if(i == 2) arr.splice(i,1);
})
```
删除了第3个，循环缺跳过了第四个。无法做到后退。

总结for和forEach的区别
- 循环不能选择开始和结束位置
- 循环不能中断
- 循环不能后退
- 异步语句forEach可以拿到每一个i值

# 斐波那契fibonacci

## 返回第n个斐波那契数。 f(1) = 1, f(2) = 1 等

```
// 时间复杂度o(n), 空间复杂度o(n);
// 通过全部用例 运行时间 2383ms 占用内存 77896KB
function fibonacci(n) {
    if(typeof n !== 'number') return '请输入一个正整数';
    let aFib = [1,1];
    for (let i = 2; i< n; i++){
        aFib.push(aFib[i-1]+aFib[i-2])
    }
    return aFib[n-1];
}
```

```
//????                 时间复杂度o(n), 空间复杂度o(nlogn);
// 通过全部用例 运行时间 1904ms 占用内存 77936KB
function fibonacci(n) {
    if(typeof n !== 'number') return '请输入一个正整数';
    if(n <= 2) return 1;
    return fibonacci(n-1)+fibonacci(n-2);
}
```

```
// 尾递归优化
// 通过全部用例 运行时间 2377ms 占用内存 77868KB
function fibonacci(n,pre1=1,pre2=1) {
    if(typeof n !== 'number') return '请输入一个正整数';
    if(n <= 2) return pre1;
    return fibonacci(--n, pre1+pre2, pre1);
}
```
## 斐波那契兔子
有一对兔子，长到第五个月的时候开始每个月都会生一对兔子，第n个月的时候会有多少对兔子
1
1
1
1
2
3
4
5
7
10
14
...

从第五个月起，f(n) = f(n-1)+f(n-4), 第n个月的兔子，首先包括前一个月的兔子数量；然后，这些兔子里，包含前四个月的兔子都已经成年了的，可以有多少对，在这个月就能生出来多少对。所以是f(n-1)+f(n-4);

```
function getRabbitsNumber(n, prev1 = 1, prev2 = 1,prev3 = 1,prev4 = 1){
    if(n < 5) return prev1;
    return getRabbitsNumber(n-1, prev1 + prev4, prev1, prev2, prev3 )
}
或者
function getRabbitsNumber(n){
    if(n < 5) return 1;
    return getRabbitsNumber(n-1)+ getRabbitsNumber(n-4)
}
```

# 生成dom树

```
function dom2json() {
    const jsContainer = document.querySelector("#jsContainer")

    function domJson(dom) {
        var obj = {}
        if (dom.nodeType == 1) {
            obj.tag = dom.tagName.toLocaleLowerCase()
            var attrs = getTagAttrs(dom)
            if (attrs) obj.attributes = attrs;
            
            obj.children = [];
            Array.from(dom.childNodes).filter(child => { // 这里用[...dom.childNodes]编译不过？？？？
                return !(child.nodeType == 3 && !child.textContent.trim())
            }).forEach((item,i)=>{
                obj.children.push(domJson(item))
            });
                
            
            
            return obj
        }
        if (dom.nodeType == 3) {
            let content = dom.textContent.trim();
            if(!content) return;
            obj.tag = 'text';
            obj.content = content
            return obj
        }
    }

    function getTagName(dom) {
        return dom.nodeName.toLocaleLowerCase().replace('#', '')
    }

    function getTagAttrs(dom) {
        var attr = Array.from(dom.attributes)
        var obj = {}
        attr.forEach(atr => obj[atr.name] = atr.value)
        return attr.length ? obj : null;
    }

    return domJson(jsContainer)
}
```
原生具备 Iterator 接口的数据结构如下：

Array
Map
Set
String
TypedArray
函数的 arguments 对象
NodeList 对象

```
// todo 这里还需要再测试
Array.from(dom.childNodes).filter(child => { // 这里用[...dom.childNodes]编译不过？？？？
```

# 烙饼问题
一个锅可以烙两张饼，30分钟可以出锅，一共三张饼，最短需要多少时间？
这么思考？
假如资源就是锅，资源同时给两个人用，做这件事需要耗时30分钟，假如只给一个人用，那么他的耗时就是15分钟。
资源是限量的（只有一口锅），可同时烤两张饼，那么就是每15分钟，换一张饼去烙。
30 / 2 * 3 = 45

假如同时可以烤3张饼，一共有四张饼，那么最短时间是 30 / 3 * 4 = 40, 每10分钟换一张饼烙

# 车跑多远的问题
有16辆相同的车，每辆车的油都可以跑100km,问互相配合最远可以跑多远？
前提：
16辆车的起点相同
每辆车已经加满油
互相配合指可以把自己的油分给别的车，最后剩下一辆跑的最远的车，是跑多远

思维导图：
- 16辆车同时出发，走100/16, 第16辆车把它剩下的油分给其它15辆；(为啥分给剩下15辆？第一辆加1/16的油就满了，它需要其它车走的远一些给它做油库)
- 剩下15辆，走100/15,第15辆车把它剩下的油分给其它14辆;
以此类推
.
.
.
- 最后两辆车，走100/2,第2辆车把它的油都给第一辆;
- 第一辆还可以走100km
第一辆车就是走的最远的车，走的距离100/16+100/15+100/14……+100/2+100/1


```
let l=0;
for(i = 1;i<=16;i++){
    l+=100/i
}
console.log(l) // 338.0728993228993
```

# 整数翻转
给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。
示例 1：

输入：x = 123
输出：321
示例 2：

输入：x = -123
输出：-321
示例 3：

输入：x = 120
输出：21
示例 4：

输入：x = 0
输出：0

思路：将数字无符号部分转为string，在转为array，调用reverse方法，在拼接为string，再转化为Number
如果结果在范围内返回结果，否则返回0
```
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function(x) {
    let result = 0;
    
    if(x >= 0) {
        result = Number(x.toString().split('').reverse().join(''))
    }else{
        result = Number('-' + (x*-1).toString().split('').reverse().join(''));
    }
    
    if(result > (Math.pow(2,31) - 1) || result <  -Math.pow(2,31)) return 0;
    return result;
};
```
按照leetcode视频教程，答案如下：

```
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function(x) {
    let result = 0;
    while(x){
        let num = x % 10;
        x = Math.trunc(x / 10); // 取整，丢弃小数部分，ie有兼容问题
        result = result * 10 + num;
    }
    if(result > (Math.pow(2,31) - 1) || result <  -Math.pow(2,31)) return 0;
    return result;
};
```
延伸阅读：[取余和取模的区别](https://www.runoob.com/w3cnote/remainder-and-the-modulo.html)
[Math](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math)

# 回文数
给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

 

示例 1：

输入：x = 121
输出：true
示例 2：

输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3：

输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
示例 4：

输入：x = -101
输出：false
 

提示：

-231 <= x <= 231 - 1
 

进阶：你能不将整数转为字符串来解决这个问题吗？

```
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    if(x.toString() === x.toString().split('').reverse().join('')) return true;
    return false;
};
```
不转换为String，解题：

```
var isPalindrome = function(x) {
    if(x < 0) return false;
    if(x < 10) return true;
    let count = Math.trunc(Math.log10(x)); // 共有多少位
    let iteratorCount = 0;
    while( Math.ceil(count / 2) !== iteratorCount){// 从两边向中间一次遍历
        let highValue =  Math.pow(10, count-iteratorCount);
        let start = Math.trunc(x / highValue) % 10;
        let end = Math.trunc(x / Math.pow(10, iteratorCount) % 10);
        
        if(start !== end){// 拿两端的值做比较，不同则不是回文数
            return false;
        }
        
        iteratorCount++   
    }
    return true;
};
```
364 ms	52.1 MB

看完视频讲解后解题

```
var isPalindrome = function(x) {
    if(x < 0 || (x % 10 === 0 && x !== 0)) return false;
    if(x < 10) return true;
    let reverseNum = 0;
    while(x > reverseNum){
        let v = x % 10;
        x = Math.trunc(x / 10);
        reverseNum = reverseNum * 10 + v;
    }
    if(reverseNum > x){
        reverseNum = Math.trunc(reverseNum / 10);
    }
    if(x === reverseNum){
        return true;
    }

    return false;
};
```
把后一半的数做翻转，与前一半比较。负值、小于10的值，及10的整数倍不需要走入while循环。
156 ms	46.2 MB
# 罗马数字转整数
罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

 

示例 1:

输入: "III"
输出: 3
示例 2:

输入: "IV"
输出: 4
示例 3:

输入: "IX"
输出: 9
示例 4:

输入: "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
示例 5:

输入: "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
 

提示：

1 <= s.length <= 15
s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')
题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内
题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。

## hash表法
```
/**
 * @param {string} s
 * @return {number}
 */
var romanToInt = function(s) {
    let map = {
        I: 1,
        V: 5,
        X: 10,
        L: 50,
        C: 100,
        D: 500,
        M: 1000,
        IV: 4,
        IX: 9,
        XL: 40,
        XC: 90,
        CD: 400,
        CM: 900,
    }
    let result = 0;
    for(let i = 0,l = s.length;i <l;){
        let item = s[i], nextItem = s[i+1];
        let towItem = item + nextItem;
        if(map[towItem]){
            result += map[towItem];
            i += 2;
        }else{
            result += map[item];
            i += 1;
        }
    }
    return result;
};
```
执行用时：124 ms, 在所有 JavaScript 提交中击败了93.69%的用户
内存消耗：45.2 MB, 在所有 JavaScript 提交中击败了12.24%的用户
怎么减少空间复杂度？？？

## 忽略的规律：相邻的两个字母，前一个对应的数字小于后一个对应的数字时，取负值

```
var romanToInt = function(s) {
    let map = {
        I: 1,
        V: 5,
        X: 10,
        L: 50,
        C: 100,
        D: 500,
        M: 1000,
    }
    let result = 0, i = 0,l = s.length;
    for(;i < l -1;i++){
        let item = s[i], nextItem = s[i+1];
        result += map[item] >= map[nextItem] ? map[item]: -map[item];
    }
    result += map[s[i]]; // 注意:运行到这里i = length-1
    return result;
};
```

执行用时：144 ms, 在所有 JavaScript 提交中击败了50.21%的用户
内存消耗：43.2 MB, 在所有 JavaScript 提交中击败了80.20%的用户

## 将hash改为switch，空间占用更有优势
```
var romanToInt = function(s) {
    var getValue = function(v){
        switch(v){
            case 'I': return 1;
            case 'V': return 5;
            case 'X': return 10;
            case 'L': return 50;
            case 'C': return 100;
            case 'D': return 500;
            case 'M': return 1000;
        }
    }
    
    let result = 0, i = 0,l = s.length;
    for(;i < l -1;i++){
        let item = s[i], nextItem = s[i+1];
        result += getValue(item) >= getValue(nextItem) ? getValue(item): -(getValue(item));
    }
    result += getValue(s[i]);
    return result;
};
```
执行用时：144 ms, 在所有 JavaScript 提交中击败了50.21%的用户
内存消耗：42.9 MB, 在所有 JavaScript 提交中击败了94.58%的用户

# 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

 

示例 1：

输入：strs = ["flower","flow","flight"]
输出："fl"
示例 2：

输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
 

提示：

1 <= strs.length <= 200
0 <= strs[i].length <= 200
strs[i] 仅由小写英文字母组成

## 纵向扫描

```
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
    let result = '';
    if(strs.length === 0) return result;
    for(let j = 0, len = strs[0].length; j<len;j++ ){
        let curr = strs[0][j]
        for(let i = 1, l = strs.length; i< l;i++){
            if(strs[i][j] !== curr){
                return result;
            }
        }
        result += curr;
    }   
    return result;
};
```
执行用时：68 ms, 在所有 JavaScript 提交中击败了92.25%的用户
内存消耗：39.7 MB, 在所有 JavaScript 提交中击败了26.72%的用户

## 横向扫描

## 分治法

## 二分查找法