---
title: 算法学习
date: 2021-10-10 22:03:46
tags:
---
快速排序，两数之和，fibonacci, 生成dom树

<!--more-->

# 两数之和

时间复杂度o(n), 空间复杂度o(n);

```
/**
  * 
  * @param numbers int整型一维数组 
  * @param target int整型 
  * @return int整型一维数组
  */
function twoSum( numbers ,  target ) {
    // write code here
    if(!numbers || numbers.length < 2 ) return [];
    let obj = {[numbers[0]]: 1};
    for(let i = 1,l = numbers.length; i<l; i++){    
        let tem = target - numbers[i];
        if(obj[tem] >= 1){
            return [obj[tem], i+1]
        }
        obj[numbers[i]] = i+1;
    }
}
module.exports = {
    twoSum : twoSum
};
```

# 斐波那契fibonacci

## 返回第n个斐波那契数。 f(1) = 1, f(2) = 1 等

```
// 时间复杂度o(n), 空间复杂度o(n);
// 通过全部用例 运行时间 2383ms 占用内存 77896KB
function fibonacci(n) {
    if(typeof n !== 'number') return '请输入一个正整数';
    let aFib = [1,1];
    for (let i = 2; i< n; i++){
        aFib.push(aFib[i-1]+aFib[i-2])
    }
    return aFib[n-1];
}
```

```
//????                 时间复杂度o(n), 空间复杂度o(nlogn);
// 通过全部用例 运行时间 1904ms 占用内存 77936KB
function fibonacci(n) {
    if(typeof n !== 'number') return '请输入一个正整数';
    if(n <= 2) return 1;
    return fibonacci(n-1)+fibonacci(n-2);
}
```

```
// 尾递归优化
// 通过全部用例 运行时间 2377ms 占用内存 77868KB
function fibonacci(n,pre1=1,pre2=1) {
    if(typeof n !== 'number') return '请输入一个正整数';
    if(n <= 2) return pre1;
    return fibonacci(--n, pre1+pre2, pre1);
}
```
# 生成dom树

```
function dom2json() {
    const jsContainer = document.querySelector("#jsContainer")

    function domJson(dom) {
        var obj = {}
        if (dom.nodeType == 1) {
            obj.tag = dom.tagName.toLocaleLowerCase()
            var attrs = getTagAttrs(dom)
            if (attrs) obj.attributes = attrs;
            
            obj.children = [];
            Array.from(dom.childNodes).filter(child => { // 这里用[...dom.childNodes]编译不过？？？？
                return !(child.nodeType == 3 && !child.textContent.trim())
            }).forEach((item,i)=>{
                obj.children.push(domJson(item))
            });
                
            
            
            return obj
        }
        if (dom.nodeType == 3) {
            let content = dom.textContent.trim();
            if(!content) return;
            obj.tag = 'text';
            obj.content = content
            return obj
        }
    }

    function getTagName(dom) {
        return dom.nodeName.toLocaleLowerCase().replace('#', '')
    }

    function getTagAttrs(dom) {
        var attr = Array.from(dom.attributes)
        var obj = {}
        attr.forEach(atr => obj[atr.name] = atr.value)
        return attr.length ? obj : null;
    }

    return domJson(jsContainer)
}
```
原生具备 Iterator 接口的数据结构如下：

Array
Map
Set
String
TypedArray
函数的 arguments 对象
NodeList 对象

```
// todo 这里还需要再测试
Array.from(dom.childNodes).filter(child => { // 这里用[...dom.childNodes]编译不过？？？？
```