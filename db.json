{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1590721346919},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1590721346919},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1590721346927},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1590721346919},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1590721346919},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1590721346919},{"_id":"source/_posts/hello-world的副本.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1590721325647},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1590721325647},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1590721346920},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1590721346920},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1590721346920},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1590721346920},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1590721346920},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1590721346921},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1590721346921},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1590721346921},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1590721346921},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1590721346925},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1590721346925},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1590721346926},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1590721346926},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1590721346926},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1590721346926},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1590721346926},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1590721346927},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1590721346920},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1590721346921},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1590721346921},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1590721346922},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1590721346922},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1590721346922},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1590721346922},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1590721346923},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1590721346923},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1590721346923},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1590721346924},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1590721346924},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1590721346925},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1590721346925},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1590721346925},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1590721346925},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1590721346922},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1590721346922},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1590721346922},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1590721346927},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1590721346931},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1590721346939},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1590721346940},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1590721346940},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1590721346940},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1590721346941},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1590721346939},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1590721346939},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1590721346940},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1590721346942},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1590721346943},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1590721346942},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1590721346923},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1590721346923},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1590721346924},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1590721346924},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1590721346928},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1590721346928},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1590721346928},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1590721346929},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1590721346929},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1590721346930},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1590721346930},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1590721346930},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1590721346930},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1590721346930},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1590721346931},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1590721346923},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1590721346924},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1590721346928},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1590721346932},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1590721346932},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1590721346941},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1590721346941},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1590721346940},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1590721346941},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1590721346935},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1590721346941},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1590721346941},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1590721346935},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1590721346933},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1590721346937},{"_id":"public/2020/05/29/hello-world/index.html","hash":"a88d70efa0e734caf579806f32f9f56848b42cb6","modified":1590723326809},{"_id":"public/2020/05/29/hello-world的副本/index.html","hash":"8fba6bc2186ad1622a60ba5b9fbd182e9942cd10","modified":1590723326809},{"_id":"public/index.html","hash":"4b0590f327b22a54014f609114691908babc37d2","modified":1594005313271},{"_id":"public/archives/index.html","hash":"211709146ea7efba5c3832c5fa6ec52bfe5456ab","modified":1594005313271},{"_id":"public/archives/2020/index.html","hash":"62a8defc1010556aefab588370f0db2d44765c4c","modified":1594005313271},{"_id":"public/archives/2020/05/index.html","hash":"beb8722f7e3f6c9797d84c4928539b7aeae0ae8e","modified":1594005313271},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1590723326809},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1590723326809},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1590723326809},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1590723326809},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1590723326809},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1590723326809},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1590723326809},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1590723326809},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1590723326809},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1590723326809},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1590723326809},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1590723326809},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1590723326809},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1590723326809},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1590723326809},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1590723326809},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1590723326809},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1590723326809},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1590723326809},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1590723326809},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1590723326809},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1590723326809},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1590723326809},{"_id":"source/_posts/js防抖和节流.md","hash":"6cdd6e0bad067b50d23fb2c98cafe3aa2640de42","modified":1593428895428},{"_id":"source/_posts/.DS_Store","hash":"29e6c3f58670fc3b36b00f348e95eb2d5bfe56ff","modified":1593999323377},{"_id":"public/2020/05/29/js防抖和节流/index.html","hash":"b449172869381e8533f3ad264d1da48ceb2db9e2","modified":1594005313271},{"_id":"source/.DS_Store","hash":"aec522e306badee0c08b2691b948f0664647e583","modified":1593758449341},{"_id":"source/_posts/web worker使用教程.md","hash":"89e7d7664d280e27615cb171166af7e9e7faf847","modified":1594002281321},{"_id":"public/2020/05/29/web worker使用教程/index.html","hash":"b019aac4cb7e91e9b1c78335a8002f7a00d3ce32","modified":1593756184962},{"_id":"public/2020/07/03/web worker使用教程/index.html","hash":"087271984bb3f284a0b2195b3ae165a11143d3cf","modified":1594005313271},{"_id":"public/archives/2020/07/index.html","hash":"4e7fa02004d18eeec2a3e25aa4c77a3e2db7841b","modified":1594005313271},{"_id":"source/_posts/Back-Forward cache.md","hash":"de5e64f8f82ca25e071cbe912418b0e12fa090a3","modified":1594001273360},{"_id":"public/2020/07/06/Back-Forward cache/index.html","hash":"9fd0d041b4c89b9b30ab5c39be047d6dfa7c01e5","modified":1594005313271},{"_id":"source/_posts/JavaScript 复杂判断的更优雅写法.md","hash":"871610fb556d8e812aa6d2aaa20de0740be77c2c","modified":1594005249173},{"_id":"public/2020/07/06/JavaScript 复杂判断的更优雅写法/index.html","hash":"4ebb97fb2ad9d687f3c693c3da3efae750c7b9b8","modified":1594005313271}],"Category":[],"Data":[],"Page":[],"Post":[{"_content":"#js防抖和节流\n在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。 \n\n \n\n##函数防抖\n\n函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。\n\n一起来实现个简单的debounce~\n\n防抖debounce代码：\n\n\n\n``` bash\n\n// 防抖\nfunction debounce(fn, wait) {    \n    var timeout = null;    \n    return function() {        \n        if(timeout !== null)   clearTimeout(timeout);        \n        timeout = setTimeout(fn, wait);    \n    }\n}\n// 处理函数\nfunction handle() {    \n    console.log(Math.random()); \n}\n// 滚动事件\nwindow.addEventListener('scroll', debounce(handle, 1000));\n\n```\n\n当持续触发scroll事件时，事件处理函数handle只在停止滚动1000毫秒之后才会调用一次，也就是说在持续触发scroll事件的过程中，事件处理函数handle一直没有执行。\n\n \n\n##函数节流\n\n \n\n函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。\n\n函数节流主要有两种实现方法：时间戳和定时器。接下来分别用两种方法实现throttle~\n\n节流throttle代码（时间戳）：\n\n```\nvar throttle = function(func, delay) {            \n　　var prev = Date.now();            \n　　return function() {                \n　　　　var context = this;                \n　　　　var args = arguments;                \n　　　　var now = Date.now();                \n　　　　if (now - prev >= delay) {                    \n　　　　　　func.apply(context, args);                    \n　　　　　　prev = Date.now();                \n　　　　}            \n　　}        \n}        \nfunction handle() {            \n　　console.log(Math.random());        \n}        \nwindow.addEventListener('scroll', throttle(handle, 1000));\n\n```\n\n当高频事件触发时，第一次会立即执行（给scroll事件绑定函数与真正触发事件的间隔一般大于delay，如果你非要在网页加载1000毫秒以内就去滚动网页的话，我也没办法o(╥﹏╥)o），而后再怎么频繁地触发事件，也都是每delay时间才执行一次。而当最后一次事件触发完毕后，事件也不会再被执行了 （最后一次触发事件与倒数第二次触发事件的间隔小于delay，为什么小于呢？因为大于就不叫高频了呀(*╹▽╹*)）。\n\n节流throttle代码（定时器）：\n\n```\n// 节流throttle代码（定时器）：\nvar throttle = function(func, delay) {            \n    var timer = null;            \n    return function() {                \n        var context = this;               \n        var args = arguments;                \n        if (!timer) {                    \n            timer = setTimeout(function() {                        \n                func.apply(context, args);                        \n                timer = null;                    \n            }, delay);                \n        }            \n    }        \n}        \nfunction handle() {            \n    console.log(Math.random());        \n}        \nwindow.addEventListener('scroll', throttle(handle, 1000));\n```\n当触发事件的时候，我们设置一个定时器，再次触发事件的时候，如果定时器存在，就不执行，直到delay时间后，定时器执行执行函数，并且清空定时器，这样就可以设置下个定时器。当第一次触发事件时，不会立即执行函数，而是在delay秒后才执行。而后再怎么频繁触发事件，也都是每delay时间才执行一次。当最后一次停止触发后，由于定时器的delay延迟，可能还会执行一次函数。\n\n节流中用时间戳或定时器都是可以的。更精确地，可以用时间戳+定时器，当第一次触发事件时马上执行事件处理函数，最后一次触发事件后也还会执行一次事件处理函数。\n\n节流throttle代码（时间戳+定时器）：\n```// 节流throttle代码（时间戳+定时器）：\nvar throttle = function(func, delay) {     \n    var timer = null;     \n    var startTime = Date.now();     \n    return function() {             \n        var curTime = Date.now();             \n        var remaining = delay - (curTime - startTime);             \n        var context = this;             \n        var args = arguments;             \n        clearTimeout(timer);              \n        if (remaining <= 0) {                    \n            func.apply(context, args);                    \n            startTime = Date.now();              \n        } else {                    \n            timer = setTimeout(func, remaining);              \n        }      \n    }\n}\nfunction handle() {      \n    console.log(Math.random());\n} \nwindow.addEventListener('scroll', throttle(handle, 1000));\n```\n在节流函数内部使用开始时间startTime、当前时间curTime与delay来计算剩余时间remaining，当remaining<=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重新计算一个remaining来判断当前状态。\n\n总结\n\n函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。\n\n函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。\n\n区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。\n\n 转载自：[js防抖和节流](https://www.cnblogs.com/momo798/p/9177767.html)\n \n\n","source":"_posts/js防抖和节流.md","raw":"#js防抖和节流\n在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。 \n\n \n\n##函数防抖\n\n函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。\n\n一起来实现个简单的debounce~\n\n防抖debounce代码：\n\n\n\n``` bash\n\n// 防抖\nfunction debounce(fn, wait) {    \n    var timeout = null;    \n    return function() {        \n        if(timeout !== null)   clearTimeout(timeout);        \n        timeout = setTimeout(fn, wait);    \n    }\n}\n// 处理函数\nfunction handle() {    \n    console.log(Math.random()); \n}\n// 滚动事件\nwindow.addEventListener('scroll', debounce(handle, 1000));\n\n```\n\n当持续触发scroll事件时，事件处理函数handle只在停止滚动1000毫秒之后才会调用一次，也就是说在持续触发scroll事件的过程中，事件处理函数handle一直没有执行。\n\n \n\n##函数节流\n\n \n\n函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。\n\n函数节流主要有两种实现方法：时间戳和定时器。接下来分别用两种方法实现throttle~\n\n节流throttle代码（时间戳）：\n\n```\nvar throttle = function(func, delay) {            \n　　var prev = Date.now();            \n　　return function() {                \n　　　　var context = this;                \n　　　　var args = arguments;                \n　　　　var now = Date.now();                \n　　　　if (now - prev >= delay) {                    \n　　　　　　func.apply(context, args);                    \n　　　　　　prev = Date.now();                \n　　　　}            \n　　}        \n}        \nfunction handle() {            \n　　console.log(Math.random());        \n}        \nwindow.addEventListener('scroll', throttle(handle, 1000));\n\n```\n\n当高频事件触发时，第一次会立即执行（给scroll事件绑定函数与真正触发事件的间隔一般大于delay，如果你非要在网页加载1000毫秒以内就去滚动网页的话，我也没办法o(╥﹏╥)o），而后再怎么频繁地触发事件，也都是每delay时间才执行一次。而当最后一次事件触发完毕后，事件也不会再被执行了 （最后一次触发事件与倒数第二次触发事件的间隔小于delay，为什么小于呢？因为大于就不叫高频了呀(*╹▽╹*)）。\n\n节流throttle代码（定时器）：\n\n```\n// 节流throttle代码（定时器）：\nvar throttle = function(func, delay) {            \n    var timer = null;            \n    return function() {                \n        var context = this;               \n        var args = arguments;                \n        if (!timer) {                    \n            timer = setTimeout(function() {                        \n                func.apply(context, args);                        \n                timer = null;                    \n            }, delay);                \n        }            \n    }        \n}        \nfunction handle() {            \n    console.log(Math.random());        \n}        \nwindow.addEventListener('scroll', throttle(handle, 1000));\n```\n当触发事件的时候，我们设置一个定时器，再次触发事件的时候，如果定时器存在，就不执行，直到delay时间后，定时器执行执行函数，并且清空定时器，这样就可以设置下个定时器。当第一次触发事件时，不会立即执行函数，而是在delay秒后才执行。而后再怎么频繁触发事件，也都是每delay时间才执行一次。当最后一次停止触发后，由于定时器的delay延迟，可能还会执行一次函数。\n\n节流中用时间戳或定时器都是可以的。更精确地，可以用时间戳+定时器，当第一次触发事件时马上执行事件处理函数，最后一次触发事件后也还会执行一次事件处理函数。\n\n节流throttle代码（时间戳+定时器）：\n```// 节流throttle代码（时间戳+定时器）：\nvar throttle = function(func, delay) {     \n    var timer = null;     \n    var startTime = Date.now();     \n    return function() {             \n        var curTime = Date.now();             \n        var remaining = delay - (curTime - startTime);             \n        var context = this;             \n        var args = arguments;             \n        clearTimeout(timer);              \n        if (remaining <= 0) {                    \n            func.apply(context, args);                    \n            startTime = Date.now();              \n        } else {                    \n            timer = setTimeout(func, remaining);              \n        }      \n    }\n}\nfunction handle() {      \n    console.log(Math.random());\n} \nwindow.addEventListener('scroll', throttle(handle, 1000));\n```\n在节流函数内部使用开始时间startTime、当前时间curTime与delay来计算剩余时间remaining，当remaining<=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重新计算一个remaining来判断当前状态。\n\n总结\n\n函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。\n\n函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。\n\n区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。\n\n 转载自：[js防抖和节流](https://www.cnblogs.com/momo798/p/9177767.html)\n \n\n","slug":"js防抖和节流","published":1,"date":"2020-05-29T03:02:05.647Z","updated":"2020-06-29T11:08:15.428Z","title":"js防抖和节流","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc0em8vl0000k6c87ti1dr25","content":"<p>#js防抖和节流<br>在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。 </p>\n<p>##函数防抖</p>\n<p>函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</p>\n<p>一起来实现个简单的debounce~</p>\n<p>防抖debounce代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 防抖</span><br><span class=\"line\"><span class=\"keyword\">function</span> debounce(fn, <span class=\"built_in\">wait</span>) &#123;    </span><br><span class=\"line\">    var timeout = null;    </span><br><span class=\"line\">    <span class=\"built_in\">return</span> <span class=\"function\"><span class=\"title\">function</span></span>() &#123;        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(timeout !== null)   clearTimeout(timeout);        </span><br><span class=\"line\">        timeout = setTimeout(fn, <span class=\"built_in\">wait</span>);    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 处理函数</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">handle</span></span>() &#123;    </span><br><span class=\"line\">    console.log(Math.random()); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 滚动事件</span><br><span class=\"line\">window.addEventListener(<span class=\"string\">'scroll'</span>, debounce(handle, 1000));</span><br></pre></td></tr></table></figure>\n\n<p>当持续触发scroll事件时，事件处理函数handle只在停止滚动1000毫秒之后才会调用一次，也就是说在持续触发scroll事件的过程中，事件处理函数handle一直没有执行。</p>\n<p>##函数节流</p>\n<p>函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。</p>\n<p>函数节流主要有两种实现方法：时间戳和定时器。接下来分别用两种方法实现throttle~</p>\n<p>节流throttle代码（时间戳）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var throttle &#x3D; function(func, delay) &#123;            </span><br><span class=\"line\">　　var prev &#x3D; Date.now();            </span><br><span class=\"line\">　　return function() &#123;                </span><br><span class=\"line\">　　　　var context &#x3D; this;                </span><br><span class=\"line\">　　　　var args &#x3D; arguments;                </span><br><span class=\"line\">　　　　var now &#x3D; Date.now();                </span><br><span class=\"line\">　　　　if (now - prev &gt;&#x3D; delay) &#123;                    </span><br><span class=\"line\">　　　　　　func.apply(context, args);                    </span><br><span class=\"line\">　　　　　　prev &#x3D; Date.now();                </span><br><span class=\"line\">　　　　&#125;            </span><br><span class=\"line\">　　&#125;        </span><br><span class=\"line\">&#125;        </span><br><span class=\"line\">function handle() &#123;            </span><br><span class=\"line\">　　console.log(Math.random());        </span><br><span class=\"line\">&#125;        </span><br><span class=\"line\">window.addEventListener(&#39;scroll&#39;, throttle(handle, 1000));</span><br></pre></td></tr></table></figure>\n\n<p>当高频事件触发时，第一次会立即执行（给scroll事件绑定函数与真正触发事件的间隔一般大于delay，如果你非要在网页加载1000毫秒以内就去滚动网页的话，我也没办法o(╥﹏╥)o），而后再怎么频繁地触发事件，也都是每delay时间才执行一次。而当最后一次事件触发完毕后，事件也不会再被执行了 （最后一次触发事件与倒数第二次触发事件的间隔小于delay，为什么小于呢？因为大于就不叫高频了呀(<em>╹▽╹</em>)）。</p>\n<p>节流throttle代码（定时器）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 节流throttle代码（定时器）：</span><br><span class=\"line\">var throttle &#x3D; function(func, delay) &#123;            </span><br><span class=\"line\">    var timer &#x3D; null;            </span><br><span class=\"line\">    return function() &#123;                </span><br><span class=\"line\">        var context &#x3D; this;               </span><br><span class=\"line\">        var args &#x3D; arguments;                </span><br><span class=\"line\">        if (!timer) &#123;                    </span><br><span class=\"line\">            timer &#x3D; setTimeout(function() &#123;                        </span><br><span class=\"line\">                func.apply(context, args);                        </span><br><span class=\"line\">                timer &#x3D; null;                    </span><br><span class=\"line\">            &#125;, delay);                </span><br><span class=\"line\">        &#125;            </span><br><span class=\"line\">    &#125;        </span><br><span class=\"line\">&#125;        </span><br><span class=\"line\">function handle() &#123;            </span><br><span class=\"line\">    console.log(Math.random());        </span><br><span class=\"line\">&#125;        </span><br><span class=\"line\">window.addEventListener(&#39;scroll&#39;, throttle(handle, 1000));</span><br></pre></td></tr></table></figure>\n<p>当触发事件的时候，我们设置一个定时器，再次触发事件的时候，如果定时器存在，就不执行，直到delay时间后，定时器执行执行函数，并且清空定时器，这样就可以设置下个定时器。当第一次触发事件时，不会立即执行函数，而是在delay秒后才执行。而后再怎么频繁触发事件，也都是每delay时间才执行一次。当最后一次停止触发后，由于定时器的delay延迟，可能还会执行一次函数。</p>\n<p>节流中用时间戳或定时器都是可以的。更精确地，可以用时间戳+定时器，当第一次触发事件时马上执行事件处理函数，最后一次触发事件后也还会执行一次事件处理函数。</p>\n<p>节流throttle代码（时间戳+定时器）：</p>\n<figure class=\"highlight plain\"><figcaption><span>节流throttle代码（时间戳+定时器）：</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var throttle &#x3D; function(func, delay) &#123;     </span><br><span class=\"line\">    var timer &#x3D; null;     </span><br><span class=\"line\">    var startTime &#x3D; Date.now();     </span><br><span class=\"line\">    return function() &#123;             </span><br><span class=\"line\">        var curTime &#x3D; Date.now();             </span><br><span class=\"line\">        var remaining &#x3D; delay - (curTime - startTime);             </span><br><span class=\"line\">        var context &#x3D; this;             </span><br><span class=\"line\">        var args &#x3D; arguments;             </span><br><span class=\"line\">        clearTimeout(timer);              </span><br><span class=\"line\">        if (remaining &lt;&#x3D; 0) &#123;                    </span><br><span class=\"line\">            func.apply(context, args);                    </span><br><span class=\"line\">            startTime &#x3D; Date.now();              </span><br><span class=\"line\">        &#125; else &#123;                    </span><br><span class=\"line\">            timer &#x3D; setTimeout(func, remaining);              </span><br><span class=\"line\">        &#125;      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function handle() &#123;      </span><br><span class=\"line\">    console.log(Math.random());</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">window.addEventListener(&#39;scroll&#39;, throttle(handle, 1000));</span><br></pre></td></tr></table></figure>\n<p>在节流函数内部使用开始时间startTime、当前时间curTime与delay来计算剩余时间remaining，当remaining&lt;=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重新计算一个remaining来判断当前状态。</p>\n<p>总结</p>\n<p>函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</p>\n<p>函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。</p>\n<p>区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p>\n<p> 转载自：<a href=\"https://www.cnblogs.com/momo798/p/9177767.html\" target=\"_blank\" rel=\"noopener\">js防抖和节流</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>#js防抖和节流<br>在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。 </p>\n<p>##函数防抖</p>\n<p>函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</p>\n<p>一起来实现个简单的debounce~</p>\n<p>防抖debounce代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 防抖</span><br><span class=\"line\"><span class=\"keyword\">function</span> debounce(fn, <span class=\"built_in\">wait</span>) &#123;    </span><br><span class=\"line\">    var timeout = null;    </span><br><span class=\"line\">    <span class=\"built_in\">return</span> <span class=\"function\"><span class=\"title\">function</span></span>() &#123;        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(timeout !== null)   clearTimeout(timeout);        </span><br><span class=\"line\">        timeout = setTimeout(fn, <span class=\"built_in\">wait</span>);    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 处理函数</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">handle</span></span>() &#123;    </span><br><span class=\"line\">    console.log(Math.random()); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 滚动事件</span><br><span class=\"line\">window.addEventListener(<span class=\"string\">'scroll'</span>, debounce(handle, 1000));</span><br></pre></td></tr></table></figure>\n\n<p>当持续触发scroll事件时，事件处理函数handle只在停止滚动1000毫秒之后才会调用一次，也就是说在持续触发scroll事件的过程中，事件处理函数handle一直没有执行。</p>\n<p>##函数节流</p>\n<p>函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。</p>\n<p>函数节流主要有两种实现方法：时间戳和定时器。接下来分别用两种方法实现throttle~</p>\n<p>节流throttle代码（时间戳）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var throttle &#x3D; function(func, delay) &#123;            </span><br><span class=\"line\">　　var prev &#x3D; Date.now();            </span><br><span class=\"line\">　　return function() &#123;                </span><br><span class=\"line\">　　　　var context &#x3D; this;                </span><br><span class=\"line\">　　　　var args &#x3D; arguments;                </span><br><span class=\"line\">　　　　var now &#x3D; Date.now();                </span><br><span class=\"line\">　　　　if (now - prev &gt;&#x3D; delay) &#123;                    </span><br><span class=\"line\">　　　　　　func.apply(context, args);                    </span><br><span class=\"line\">　　　　　　prev &#x3D; Date.now();                </span><br><span class=\"line\">　　　　&#125;            </span><br><span class=\"line\">　　&#125;        </span><br><span class=\"line\">&#125;        </span><br><span class=\"line\">function handle() &#123;            </span><br><span class=\"line\">　　console.log(Math.random());        </span><br><span class=\"line\">&#125;        </span><br><span class=\"line\">window.addEventListener(&#39;scroll&#39;, throttle(handle, 1000));</span><br></pre></td></tr></table></figure>\n\n<p>当高频事件触发时，第一次会立即执行（给scroll事件绑定函数与真正触发事件的间隔一般大于delay，如果你非要在网页加载1000毫秒以内就去滚动网页的话，我也没办法o(╥﹏╥)o），而后再怎么频繁地触发事件，也都是每delay时间才执行一次。而当最后一次事件触发完毕后，事件也不会再被执行了 （最后一次触发事件与倒数第二次触发事件的间隔小于delay，为什么小于呢？因为大于就不叫高频了呀(<em>╹▽╹</em>)）。</p>\n<p>节流throttle代码（定时器）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 节流throttle代码（定时器）：</span><br><span class=\"line\">var throttle &#x3D; function(func, delay) &#123;            </span><br><span class=\"line\">    var timer &#x3D; null;            </span><br><span class=\"line\">    return function() &#123;                </span><br><span class=\"line\">        var context &#x3D; this;               </span><br><span class=\"line\">        var args &#x3D; arguments;                </span><br><span class=\"line\">        if (!timer) &#123;                    </span><br><span class=\"line\">            timer &#x3D; setTimeout(function() &#123;                        </span><br><span class=\"line\">                func.apply(context, args);                        </span><br><span class=\"line\">                timer &#x3D; null;                    </span><br><span class=\"line\">            &#125;, delay);                </span><br><span class=\"line\">        &#125;            </span><br><span class=\"line\">    &#125;        </span><br><span class=\"line\">&#125;        </span><br><span class=\"line\">function handle() &#123;            </span><br><span class=\"line\">    console.log(Math.random());        </span><br><span class=\"line\">&#125;        </span><br><span class=\"line\">window.addEventListener(&#39;scroll&#39;, throttle(handle, 1000));</span><br></pre></td></tr></table></figure>\n<p>当触发事件的时候，我们设置一个定时器，再次触发事件的时候，如果定时器存在，就不执行，直到delay时间后，定时器执行执行函数，并且清空定时器，这样就可以设置下个定时器。当第一次触发事件时，不会立即执行函数，而是在delay秒后才执行。而后再怎么频繁触发事件，也都是每delay时间才执行一次。当最后一次停止触发后，由于定时器的delay延迟，可能还会执行一次函数。</p>\n<p>节流中用时间戳或定时器都是可以的。更精确地，可以用时间戳+定时器，当第一次触发事件时马上执行事件处理函数，最后一次触发事件后也还会执行一次事件处理函数。</p>\n<p>节流throttle代码（时间戳+定时器）：</p>\n<figure class=\"highlight plain\"><figcaption><span>节流throttle代码（时间戳+定时器）：</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var throttle &#x3D; function(func, delay) &#123;     </span><br><span class=\"line\">    var timer &#x3D; null;     </span><br><span class=\"line\">    var startTime &#x3D; Date.now();     </span><br><span class=\"line\">    return function() &#123;             </span><br><span class=\"line\">        var curTime &#x3D; Date.now();             </span><br><span class=\"line\">        var remaining &#x3D; delay - (curTime - startTime);             </span><br><span class=\"line\">        var context &#x3D; this;             </span><br><span class=\"line\">        var args &#x3D; arguments;             </span><br><span class=\"line\">        clearTimeout(timer);              </span><br><span class=\"line\">        if (remaining &lt;&#x3D; 0) &#123;                    </span><br><span class=\"line\">            func.apply(context, args);                    </span><br><span class=\"line\">            startTime &#x3D; Date.now();              </span><br><span class=\"line\">        &#125; else &#123;                    </span><br><span class=\"line\">            timer &#x3D; setTimeout(func, remaining);              </span><br><span class=\"line\">        &#125;      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function handle() &#123;      </span><br><span class=\"line\">    console.log(Math.random());</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">window.addEventListener(&#39;scroll&#39;, throttle(handle, 1000));</span><br></pre></td></tr></table></figure>\n<p>在节流函数内部使用开始时间startTime、当前时间curTime与delay来计算剩余时间remaining，当remaining&lt;=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重新计算一个remaining来判断当前状态。</p>\n<p>总结</p>\n<p>函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</p>\n<p>函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。</p>\n<p>区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p>\n<p> 转载自：<a href=\"https://www.cnblogs.com/momo798/p/9177767.html\" target=\"_blank\" rel=\"noopener\">js防抖和节流</a></p>\n"},{"_content":"# Web Worker 使用教程\n转载自[阮一峰](http://www.ruanyifeng.com/blog/2018/07/web-worker.html)\n\n \n\n## 一、概述\n\nJavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。\n\nWeb Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。\n\nWorker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。\n\nWeb Worker 有以下几个使用注意点。\n\n（1）同源限制\n\n分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。\n\n（2）DOM 限制\n\nWorker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。\n\n（3）通信联系\n\nWorker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。\n\n（4）脚本限制\n\nWorker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。\n\n（5）文件限制\n\nWorker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。\n\n## 二、基本用法\n### 2.1 主线程\n主线程采用new命令，调用Worker()构造函数，新建一个 Worker 线程。\n\n\n``` bash\nvar worker = new Worker('work.js');\n```\n\nWorker()构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。\n\n然后，主线程调用worker.postMessage()方法，向 Worker 发消息。\n\n\n``` bash\nworker.postMessage('Hello World');\nworker.postMessage({method: 'echo', args: ['Work']});\n```\n\n\nworker.postMessage()方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。\n\n接着，主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息。\n\n```\nworker.onmessage = function (event) {\n  console.log('Received message ' + event.data);\n  doSomething();\n}\n\nfunction doSomething() {\n  // 执行任务\n  worker.postMessage('Work done!');\n}\n```\n上面代码中，事件对象的data属性可以获取 Worker 发来的数据。\n\nWorker 完成任务以后，主线程就可以把它关掉。\n\n```\nworker.terminate();\n```\n### 2.2 Worker 线程\nWorker 线程内部需要有一个监听函数，监听message事件。\n\n```\nself.addEventListener('message', function (e) {\n  self.postMessage('You said: ' + e.data);\n}, false);\n```\n上面代码中，self代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。\n\n```\n// 写法一\nthis.addEventListener('message', function (e) {\n  this.postMessage('You said: ' + e.data);\n}, false);\n\n// 写法二\naddEventListener('message', function (e) {\n  postMessage('You said: ' + e.data);\n}, false);\n```\n除了使用self.addEventListener()指定监听函数，也可以使用self.onmessage指定。监听函数的参数是一个事件对象，它的data属性包含主线程发来的数据。self.postMessage()方法用来向主线程发送消息。\n\n根据主线程发来的数据，Worker 线程可以调用不同的方法，下面是一个例子。\n\n```\nself.addEventListener('message', function (e) {\n  var data = e.data;\n  switch (data.cmd) {\n    case 'start':\n      self.postMessage('WORKER STARTED: ' + data.msg);\n      break;\n    case 'stop':\n      self.postMessage('WORKER STOPPED: ' + data.msg);\n      self.close(); // Terminates the worker.\n      break;\n    default:\n      self.postMessage('Unknown command: ' + data.msg);\n  };\n}, false);\n```\n上面代码中，self.close()用于在 Worker 内部关闭自身。\n### 2.3 Worker 加载脚本\nWorker 内部如果要加载其他脚本，有一个专门的方法importScripts()。\n\n```\nimportScripts('script1.js');\n```\n该方法可以同时加载多个脚本。\n\n```\nimportScripts('script1.js', 'script2.js');\n```\n### 2.4 错误处理\n主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的error事件。\n\n```\nworker.onerror(function (event) {\n  console.log([\n    'ERROR: Line ', e.lineno, ' in ', e.filename, ': ', e.message\n  ].join(''));\n});\n\n// 或者\nworker.addEventListener('error', function (event) {\n  // ...\n});\n```\nWorker 内部也可以监听error事件。\n\n### 2.5 关闭 Worker\n使用完毕，为了节省系统资源，必须关闭 Worker。\n\n```\n// 主线程\nworker.terminate();\n\n// Worker 线程\nself.close();\n```\n## 三、数据通信\n前面说过，主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 Worker，后者再将它还原。\n\n主线程与 Worker 之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。下面是一个例子。\n\n```\n// 主线程\nvar uInt8Array = new Uint8Array(new ArrayBuffer(10));\nfor (var i = 0; i < uInt8Array.length; ++i) {\n  uInt8Array[i] = i * 2; // [0, 2, 4, 6, 8,...]\n}\nworker.postMessage(uInt8Array);\n\n// Worker 线程\nself.onmessage = function (e) {\n  var uInt8Array = e.data;\n  postMessage('Inside worker.js: uInt8Array.toString() = ' + uInt8Array.toString());\n  postMessage('Inside worker.js: uInt8Array.byteLength = ' + uInt8Array.byteLength);\n};\n```\n但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做Transferable Objects。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。\n\n如果要直接转移数据的控制权，就要使用下面的写法。\n\n```\n// Transferable Objects 格式\nworker.postMessage(arrayBuffer, [arrayBuffer]);\n\n// 例子\nvar ab = new ArrayBuffer(1);\nworker.postMessage(ab, [ab]);\n```\n\n## 四、同页面的 Web Worker\n\n通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。\n\n```\n<!DOCTYPE html>\n  <body>\n    <script id=\"worker\" type=\"app/worker\">\n      addEventListener('message', function () {\n        postMessage('some message');\n      }, false);\n    </script>\n  </body>\n</html>\n```\n\n上面是一段嵌入网页的脚本，注意必须指定\\<script\\>标签的type属性是一个浏览器不认识的值，上例是app/worker。\n\n然后，读取这一段嵌入页面的脚本，用 Worker 来处理。  \n\n\n```\nvar blob = new Blob([document.querySelector('#worker').textContent]);\nvar url = window.URL.createObjectURL(blob);\nvar worker = new Worker(url);\n\nworker.onmessage = function (e) {\n  // e.data === 'some message'\n};\n```\n\n上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 URL，再让 Worker 加载这个 URL。这样就做到了，主线程和 Worker 的代码都在同一个网页上面。\n\n## 五、实例：Worker 线程完成轮询\n有时，浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在 Worker 里面。\n\n```\nfunction createWorker(f) {\n  var blob = new Blob(['(' + f.toString() +')()']);\n  var url = window.URL.createObjectURL(blob);\n  var worker = new Worker(url);\n  return worker;\n}\n\nvar pollingWorker = createWorker(function (e) {\n  var cache;\n\n  function compare(new, old) { ... };\n\n  setInterval(function () {\n    fetch('/my-api-endpoint').then(function (res) {\n      var data = res.json();\n\n      if (!compare(data, cache)) {\n        cache = data;\n        self.postMessage(data);\n      }\n    })\n  }, 1000)\n});\n\npollingWorker.onmessage = function () {\n  // render data\n}\n\npollingWorker.postMessage('init');\n```\n\n上面代码中，Worker 每秒钟轮询一次数据，然后跟缓存做比较。如果不一致，就说明服务端有了新的变化，因此就要通知主线程。\n\n## 六、实例： Worker 新建 Worker\nWorker 线程内部还能再新建 Worker 线程（目前只有 Firefox 浏览器支持）。下面的例子是将一个计算密集的任务，分配到10个 Worker。\n\n主线程代码如下。\n\n```\nvar worker = new Worker('worker.js');\nworker.onmessage = function (event) {\n  document.getElementById('result').textContent = event.data;\n};\n```\nWorker 线程代码如下。\n\n```\n// worker.js\n\n// settings\nvar num_workers = 10;\nvar items_per_worker = 1000000;\n\n// start the workers\nvar result = 0;\nvar pending_workers = num_workers;\nfor (var i = 0; i < num_workers; i += 1) {\n  var worker = new Worker('core.js');\n  worker.postMessage(i * items_per_worker);\n  worker.postMessage((i + 1) * items_per_worker);\n  worker.onmessage = storeResult;\n}\n\n// handle the results\nfunction storeResult(event) {\n  result += event.data;\n  pending_workers -= 1;\n  if (pending_workers <= 0)\n    postMessage(result); // finished!\n}\n```\n上面代码中，Worker 线程内部新建了10个 Worker 线程，并且依次向这10个 Worker 发送消息，告知了计算的起点和终点。计算任务脚本的代码如下。\n\n```\n// core.js\nvar start;\nonmessage = getStart;\nfunction getStart(event) {\n  start = event.data;\n  onmessage = getEnd;\n}\n\nvar end;\nfunction getEnd(event) {\n  end = event.data;\n  onmessage = null;\n  work();\n}\n\nfunction work() {\n  var result = 0;\n  for (var i = start; i < end; i += 1) {\n    // perform some complex calculation here\n    result += 1;\n  }\n  postMessage(result);\n  close();\n}\n```\n\n## 七、API\n### 7.1 主线程\n浏览器原生提供Worker()构造函数，用来供主线程生成 Worker 线程。\n\n```\nvar myWorker = new Worker(jsUrl, options);\n```\nWorker()构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。\n\n```\n// 主线程\nvar myWorker = new Worker('worker.js', { name : 'myWorker' });\n\n// Worker 线程\nself.name // myWorker\n```\n\nWorker()构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。Worker 线程对象的属性和方法如下。\n\n* Worker.onerror：指定 error 事件的监听函数。\n* Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在Event.data属性中。\n* Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。\n* Worker.postMessage()：向 Worker 线程发送消息。\n* Worker.terminate()：立即终止 Worker 线程。\n\n### 7.2 Worker 线程\n\nWeb Worker 有自己的全局对象，不是主线程的window，而是一个专门为 Worker 定制的全局对象。因此定义在window上面的对象和方法不是全部都可以使用。\n\nWorker 线程有一些自己的全局属性和方法。\n\n* self.name： Worker 的名字。该属性只读，由构造函数指定。\n* self.onmessage：指定message事件的监听函数。\n* self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。\n* self.close()：关闭 Worker 线程。\n* self.postMessage()：向产生这个 Worker 线程发送消息。\n* self.importScripts()：加载 JS 脚本。\n\n\n","source":"_posts/web worker使用教程.md","raw":"# Web Worker 使用教程\n转载自[阮一峰](http://www.ruanyifeng.com/blog/2018/07/web-worker.html)\n\n \n\n## 一、概述\n\nJavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。\n\nWeb Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。\n\nWorker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。\n\nWeb Worker 有以下几个使用注意点。\n\n（1）同源限制\n\n分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。\n\n（2）DOM 限制\n\nWorker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。\n\n（3）通信联系\n\nWorker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。\n\n（4）脚本限制\n\nWorker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。\n\n（5）文件限制\n\nWorker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。\n\n## 二、基本用法\n### 2.1 主线程\n主线程采用new命令，调用Worker()构造函数，新建一个 Worker 线程。\n\n\n``` bash\nvar worker = new Worker('work.js');\n```\n\nWorker()构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。\n\n然后，主线程调用worker.postMessage()方法，向 Worker 发消息。\n\n\n``` bash\nworker.postMessage('Hello World');\nworker.postMessage({method: 'echo', args: ['Work']});\n```\n\n\nworker.postMessage()方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。\n\n接着，主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息。\n\n```\nworker.onmessage = function (event) {\n  console.log('Received message ' + event.data);\n  doSomething();\n}\n\nfunction doSomething() {\n  // 执行任务\n  worker.postMessage('Work done!');\n}\n```\n上面代码中，事件对象的data属性可以获取 Worker 发来的数据。\n\nWorker 完成任务以后，主线程就可以把它关掉。\n\n```\nworker.terminate();\n```\n### 2.2 Worker 线程\nWorker 线程内部需要有一个监听函数，监听message事件。\n\n```\nself.addEventListener('message', function (e) {\n  self.postMessage('You said: ' + e.data);\n}, false);\n```\n上面代码中，self代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。\n\n```\n// 写法一\nthis.addEventListener('message', function (e) {\n  this.postMessage('You said: ' + e.data);\n}, false);\n\n// 写法二\naddEventListener('message', function (e) {\n  postMessage('You said: ' + e.data);\n}, false);\n```\n除了使用self.addEventListener()指定监听函数，也可以使用self.onmessage指定。监听函数的参数是一个事件对象，它的data属性包含主线程发来的数据。self.postMessage()方法用来向主线程发送消息。\n\n根据主线程发来的数据，Worker 线程可以调用不同的方法，下面是一个例子。\n\n```\nself.addEventListener('message', function (e) {\n  var data = e.data;\n  switch (data.cmd) {\n    case 'start':\n      self.postMessage('WORKER STARTED: ' + data.msg);\n      break;\n    case 'stop':\n      self.postMessage('WORKER STOPPED: ' + data.msg);\n      self.close(); // Terminates the worker.\n      break;\n    default:\n      self.postMessage('Unknown command: ' + data.msg);\n  };\n}, false);\n```\n上面代码中，self.close()用于在 Worker 内部关闭自身。\n### 2.3 Worker 加载脚本\nWorker 内部如果要加载其他脚本，有一个专门的方法importScripts()。\n\n```\nimportScripts('script1.js');\n```\n该方法可以同时加载多个脚本。\n\n```\nimportScripts('script1.js', 'script2.js');\n```\n### 2.4 错误处理\n主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的error事件。\n\n```\nworker.onerror(function (event) {\n  console.log([\n    'ERROR: Line ', e.lineno, ' in ', e.filename, ': ', e.message\n  ].join(''));\n});\n\n// 或者\nworker.addEventListener('error', function (event) {\n  // ...\n});\n```\nWorker 内部也可以监听error事件。\n\n### 2.5 关闭 Worker\n使用完毕，为了节省系统资源，必须关闭 Worker。\n\n```\n// 主线程\nworker.terminate();\n\n// Worker 线程\nself.close();\n```\n## 三、数据通信\n前面说过，主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 Worker，后者再将它还原。\n\n主线程与 Worker 之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。下面是一个例子。\n\n```\n// 主线程\nvar uInt8Array = new Uint8Array(new ArrayBuffer(10));\nfor (var i = 0; i < uInt8Array.length; ++i) {\n  uInt8Array[i] = i * 2; // [0, 2, 4, 6, 8,...]\n}\nworker.postMessage(uInt8Array);\n\n// Worker 线程\nself.onmessage = function (e) {\n  var uInt8Array = e.data;\n  postMessage('Inside worker.js: uInt8Array.toString() = ' + uInt8Array.toString());\n  postMessage('Inside worker.js: uInt8Array.byteLength = ' + uInt8Array.byteLength);\n};\n```\n但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做Transferable Objects。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。\n\n如果要直接转移数据的控制权，就要使用下面的写法。\n\n```\n// Transferable Objects 格式\nworker.postMessage(arrayBuffer, [arrayBuffer]);\n\n// 例子\nvar ab = new ArrayBuffer(1);\nworker.postMessage(ab, [ab]);\n```\n\n## 四、同页面的 Web Worker\n\n通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。\n\n```\n<!DOCTYPE html>\n  <body>\n    <script id=\"worker\" type=\"app/worker\">\n      addEventListener('message', function () {\n        postMessage('some message');\n      }, false);\n    </script>\n  </body>\n</html>\n```\n\n上面是一段嵌入网页的脚本，注意必须指定\\<script\\>标签的type属性是一个浏览器不认识的值，上例是app/worker。\n\n然后，读取这一段嵌入页面的脚本，用 Worker 来处理。  \n\n\n```\nvar blob = new Blob([document.querySelector('#worker').textContent]);\nvar url = window.URL.createObjectURL(blob);\nvar worker = new Worker(url);\n\nworker.onmessage = function (e) {\n  // e.data === 'some message'\n};\n```\n\n上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 URL，再让 Worker 加载这个 URL。这样就做到了，主线程和 Worker 的代码都在同一个网页上面。\n\n## 五、实例：Worker 线程完成轮询\n有时，浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在 Worker 里面。\n\n```\nfunction createWorker(f) {\n  var blob = new Blob(['(' + f.toString() +')()']);\n  var url = window.URL.createObjectURL(blob);\n  var worker = new Worker(url);\n  return worker;\n}\n\nvar pollingWorker = createWorker(function (e) {\n  var cache;\n\n  function compare(new, old) { ... };\n\n  setInterval(function () {\n    fetch('/my-api-endpoint').then(function (res) {\n      var data = res.json();\n\n      if (!compare(data, cache)) {\n        cache = data;\n        self.postMessage(data);\n      }\n    })\n  }, 1000)\n});\n\npollingWorker.onmessage = function () {\n  // render data\n}\n\npollingWorker.postMessage('init');\n```\n\n上面代码中，Worker 每秒钟轮询一次数据，然后跟缓存做比较。如果不一致，就说明服务端有了新的变化，因此就要通知主线程。\n\n## 六、实例： Worker 新建 Worker\nWorker 线程内部还能再新建 Worker 线程（目前只有 Firefox 浏览器支持）。下面的例子是将一个计算密集的任务，分配到10个 Worker。\n\n主线程代码如下。\n\n```\nvar worker = new Worker('worker.js');\nworker.onmessage = function (event) {\n  document.getElementById('result').textContent = event.data;\n};\n```\nWorker 线程代码如下。\n\n```\n// worker.js\n\n// settings\nvar num_workers = 10;\nvar items_per_worker = 1000000;\n\n// start the workers\nvar result = 0;\nvar pending_workers = num_workers;\nfor (var i = 0; i < num_workers; i += 1) {\n  var worker = new Worker('core.js');\n  worker.postMessage(i * items_per_worker);\n  worker.postMessage((i + 1) * items_per_worker);\n  worker.onmessage = storeResult;\n}\n\n// handle the results\nfunction storeResult(event) {\n  result += event.data;\n  pending_workers -= 1;\n  if (pending_workers <= 0)\n    postMessage(result); // finished!\n}\n```\n上面代码中，Worker 线程内部新建了10个 Worker 线程，并且依次向这10个 Worker 发送消息，告知了计算的起点和终点。计算任务脚本的代码如下。\n\n```\n// core.js\nvar start;\nonmessage = getStart;\nfunction getStart(event) {\n  start = event.data;\n  onmessage = getEnd;\n}\n\nvar end;\nfunction getEnd(event) {\n  end = event.data;\n  onmessage = null;\n  work();\n}\n\nfunction work() {\n  var result = 0;\n  for (var i = start; i < end; i += 1) {\n    // perform some complex calculation here\n    result += 1;\n  }\n  postMessage(result);\n  close();\n}\n```\n\n## 七、API\n### 7.1 主线程\n浏览器原生提供Worker()构造函数，用来供主线程生成 Worker 线程。\n\n```\nvar myWorker = new Worker(jsUrl, options);\n```\nWorker()构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。\n\n```\n// 主线程\nvar myWorker = new Worker('worker.js', { name : 'myWorker' });\n\n// Worker 线程\nself.name // myWorker\n```\n\nWorker()构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。Worker 线程对象的属性和方法如下。\n\n* Worker.onerror：指定 error 事件的监听函数。\n* Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在Event.data属性中。\n* Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。\n* Worker.postMessage()：向 Worker 线程发送消息。\n* Worker.terminate()：立即终止 Worker 线程。\n\n### 7.2 Worker 线程\n\nWeb Worker 有自己的全局对象，不是主线程的window，而是一个专门为 Worker 定制的全局对象。因此定义在window上面的对象和方法不是全部都可以使用。\n\nWorker 线程有一些自己的全局属性和方法。\n\n* self.name： Worker 的名字。该属性只读，由构造函数指定。\n* self.onmessage：指定message事件的监听函数。\n* self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。\n* self.close()：关闭 Worker 线程。\n* self.postMessage()：向产生这个 Worker 线程发送消息。\n* self.importScripts()：加载 JS 脚本。\n\n\n","slug":"web worker使用教程","published":1,"date":"2020-07-03T06:06:38.013Z","updated":"2020-07-06T02:24:41.321Z","title":"web worker使用教程","_id":"ckc5um1xj0002hdc8au6r3run","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Web-Worker-使用教程\"><a href=\"#Web-Worker-使用教程\" class=\"headerlink\" title=\"Web Worker 使用教程\"></a>Web Worker 使用教程</h1><p>转载自<a href=\"http://www.ruanyifeng.com/blog/2018/07/web-worker.html\" target=\"_blank\" rel=\"noopener\">阮一峰</a></p>\n<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。</p>\n<p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p>\n<p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>\n<p>Web Worker 有以下几个使用注意点。</p>\n<p>（1）同源限制</p>\n<p>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p>\n<p>（2）DOM 限制</p>\n<p>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。</p>\n<p>（3）通信联系</p>\n<p>Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p>\n<p>（4）脚本限制</p>\n<p>Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</p>\n<p>（5）文件限制</p>\n<p>Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。</p>\n<h2 id=\"二、基本用法\"><a href=\"#二、基本用法\" class=\"headerlink\" title=\"二、基本用法\"></a>二、基本用法</h2><h3 id=\"2-1-主线程\"><a href=\"#2-1-主线程\" class=\"headerlink\" title=\"2.1 主线程\"></a>2.1 主线程</h3><p>主线程采用new命令，调用Worker()构造函数，新建一个 Worker 线程。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var worker = new Worker(<span class=\"string\">'work.js'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>Worker()构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。</p>\n<p>然后，主线程调用worker.postMessage()方法，向 Worker 发消息。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker.postMessage(<span class=\"string\">'Hello World'</span>);</span><br><span class=\"line\">worker.postMessage(&#123;method: <span class=\"string\">'echo'</span>, args: [<span class=\"string\">'Work'</span>]&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<p>worker.postMessage()方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。</p>\n<p>接着，主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker.onmessage &#x3D; function (event) &#123;</span><br><span class=\"line\">  console.log(&#39;Received message &#39; + event.data);</span><br><span class=\"line\">  doSomething();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function doSomething() &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; 执行任务</span><br><span class=\"line\">  worker.postMessage(&#39;Work done!&#39;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，事件对象的data属性可以获取 Worker 发来的数据。</p>\n<p>Worker 完成任务以后，主线程就可以把它关掉。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker.terminate();</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-Worker-线程\"><a href=\"#2-2-Worker-线程\" class=\"headerlink\" title=\"2.2 Worker 线程\"></a>2.2 Worker 线程</h3><p>Worker 线程内部需要有一个监听函数，监听message事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class=\"line\">  self.postMessage(&#39;You said: &#39; + e.data);</span><br><span class=\"line\">&#125;, false);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，self代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 写法一</span><br><span class=\"line\">this.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class=\"line\">  this.postMessage(&#39;You said: &#39; + e.data);</span><br><span class=\"line\">&#125;, false);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 写法二</span><br><span class=\"line\">addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class=\"line\">  postMessage(&#39;You said: &#39; + e.data);</span><br><span class=\"line\">&#125;, false);</span><br></pre></td></tr></table></figure>\n<p>除了使用self.addEventListener()指定监听函数，也可以使用self.onmessage指定。监听函数的参数是一个事件对象，它的data属性包含主线程发来的数据。self.postMessage()方法用来向主线程发送消息。</p>\n<p>根据主线程发来的数据，Worker 线程可以调用不同的方法，下面是一个例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class=\"line\">  var data &#x3D; e.data;</span><br><span class=\"line\">  switch (data.cmd) &#123;</span><br><span class=\"line\">    case &#39;start&#39;:</span><br><span class=\"line\">      self.postMessage(&#39;WORKER STARTED: &#39; + data.msg);</span><br><span class=\"line\">      break;</span><br><span class=\"line\">    case &#39;stop&#39;:</span><br><span class=\"line\">      self.postMessage(&#39;WORKER STOPPED: &#39; + data.msg);</span><br><span class=\"line\">      self.close(); &#x2F;&#x2F; Terminates the worker.</span><br><span class=\"line\">      break;</span><br><span class=\"line\">    default:</span><br><span class=\"line\">      self.postMessage(&#39;Unknown command: &#39; + data.msg);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;, false);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，self.close()用于在 Worker 内部关闭自身。</p>\n<h3 id=\"2-3-Worker-加载脚本\"><a href=\"#2-3-Worker-加载脚本\" class=\"headerlink\" title=\"2.3 Worker 加载脚本\"></a>2.3 Worker 加载脚本</h3><p>Worker 内部如果要加载其他脚本，有一个专门的方法importScripts()。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">importScripts(&#39;script1.js&#39;);</span><br></pre></td></tr></table></figure>\n<p>该方法可以同时加载多个脚本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">importScripts(&#39;script1.js&#39;, &#39;script2.js&#39;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-4-错误处理\"><a href=\"#2-4-错误处理\" class=\"headerlink\" title=\"2.4 错误处理\"></a>2.4 错误处理</h3><p>主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的error事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker.onerror(function (event) &#123;</span><br><span class=\"line\">  console.log([</span><br><span class=\"line\">    &#39;ERROR: Line &#39;, e.lineno, &#39; in &#39;, e.filename, &#39;: &#39;, e.message</span><br><span class=\"line\">  ].join(&#39;&#39;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 或者</span><br><span class=\"line\">worker.addEventListener(&#39;error&#39;, function (event) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ...</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Worker 内部也可以监听error事件。</p>\n<h3 id=\"2-5-关闭-Worker\"><a href=\"#2-5-关闭-Worker\" class=\"headerlink\" title=\"2.5 关闭 Worker\"></a>2.5 关闭 Worker</h3><p>使用完毕，为了节省系统资源，必须关闭 Worker。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 主线程</span><br><span class=\"line\">worker.terminate();</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Worker 线程</span><br><span class=\"line\">self.close();</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、数据通信\"><a href=\"#三、数据通信\" class=\"headerlink\" title=\"三、数据通信\"></a>三、数据通信</h2><p>前面说过，主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 Worker，后者再将它还原。</p>\n<p>主线程与 Worker 之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。下面是一个例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 主线程</span><br><span class=\"line\">var uInt8Array &#x3D; new Uint8Array(new ArrayBuffer(10));</span><br><span class=\"line\">for (var i &#x3D; 0; i &lt; uInt8Array.length; ++i) &#123;</span><br><span class=\"line\">  uInt8Array[i] &#x3D; i * 2; &#x2F;&#x2F; [0, 2, 4, 6, 8,...]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">worker.postMessage(uInt8Array);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Worker 线程</span><br><span class=\"line\">self.onmessage &#x3D; function (e) &#123;</span><br><span class=\"line\">  var uInt8Array &#x3D; e.data;</span><br><span class=\"line\">  postMessage(&#39;Inside worker.js: uInt8Array.toString() &#x3D; &#39; + uInt8Array.toString());</span><br><span class=\"line\">  postMessage(&#39;Inside worker.js: uInt8Array.byteLength &#x3D; &#39; + uInt8Array.byteLength);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做Transferable Objects。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。</p>\n<p>如果要直接转移数据的控制权，就要使用下面的写法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Transferable Objects 格式</span><br><span class=\"line\">worker.postMessage(arrayBuffer, [arrayBuffer]);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 例子</span><br><span class=\"line\">var ab &#x3D; new ArrayBuffer(1);</span><br><span class=\"line\">worker.postMessage(ab, [ab]);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、同页面的-Web-Worker\"><a href=\"#四、同页面的-Web-Worker\" class=\"headerlink\" title=\"四、同页面的 Web Worker\"></a>四、同页面的 Web Worker</h2><p>通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;script id&#x3D;&quot;worker&quot; type&#x3D;&quot;app&#x2F;worker&quot;&gt;</span><br><span class=\"line\">      addEventListener(&#39;message&#39;, function () &#123;</span><br><span class=\"line\">        postMessage(&#39;some message&#39;);</span><br><span class=\"line\">      &#125;, false);</span><br><span class=\"line\">    &lt;&#x2F;script&gt;</span><br><span class=\"line\">  &lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上面是一段嵌入网页的脚本，注意必须指定&lt;script&gt;标签的type属性是一个浏览器不认识的值，上例是app/worker。</p>\n<p>然后，读取这一段嵌入页面的脚本，用 Worker 来处理。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var blob &#x3D; new Blob([document.querySelector(&#39;#worker&#39;).textContent]);</span><br><span class=\"line\">var url &#x3D; window.URL.createObjectURL(blob);</span><br><span class=\"line\">var worker &#x3D; new Worker(url);</span><br><span class=\"line\"></span><br><span class=\"line\">worker.onmessage &#x3D; function (e) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; e.data &#x3D;&#x3D;&#x3D; &#39;some message&#39;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 URL，再让 Worker 加载这个 URL。这样就做到了，主线程和 Worker 的代码都在同一个网页上面。</p>\n<h2 id=\"五、实例：Worker-线程完成轮询\"><a href=\"#五、实例：Worker-线程完成轮询\" class=\"headerlink\" title=\"五、实例：Worker 线程完成轮询\"></a>五、实例：Worker 线程完成轮询</h2><p>有时，浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在 Worker 里面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createWorker(f) &#123;</span><br><span class=\"line\">  var blob &#x3D; new Blob([&#39;(&#39; + f.toString() +&#39;)()&#39;]);</span><br><span class=\"line\">  var url &#x3D; window.URL.createObjectURL(blob);</span><br><span class=\"line\">  var worker &#x3D; new Worker(url);</span><br><span class=\"line\">  return worker;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var pollingWorker &#x3D; createWorker(function (e) &#123;</span><br><span class=\"line\">  var cache;</span><br><span class=\"line\"></span><br><span class=\"line\">  function compare(new, old) &#123; ... &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  setInterval(function () &#123;</span><br><span class=\"line\">    fetch(&#39;&#x2F;my-api-endpoint&#39;).then(function (res) &#123;</span><br><span class=\"line\">      var data &#x3D; res.json();</span><br><span class=\"line\"></span><br><span class=\"line\">      if (!compare(data, cache)) &#123;</span><br><span class=\"line\">        cache &#x3D; data;</span><br><span class=\"line\">        self.postMessage(data);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;, 1000)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">pollingWorker.onmessage &#x3D; function () &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; render data</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">pollingWorker.postMessage(&#39;init&#39;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，Worker 每秒钟轮询一次数据，然后跟缓存做比较。如果不一致，就说明服务端有了新的变化，因此就要通知主线程。</p>\n<h2 id=\"六、实例：-Worker-新建-Worker\"><a href=\"#六、实例：-Worker-新建-Worker\" class=\"headerlink\" title=\"六、实例： Worker 新建 Worker\"></a>六、实例： Worker 新建 Worker</h2><p>Worker 线程内部还能再新建 Worker 线程（目前只有 Firefox 浏览器支持）。下面的例子是将一个计算密集的任务，分配到10个 Worker。</p>\n<p>主线程代码如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var worker &#x3D; new Worker(&#39;worker.js&#39;);</span><br><span class=\"line\">worker.onmessage &#x3D; function (event) &#123;</span><br><span class=\"line\">  document.getElementById(&#39;result&#39;).textContent &#x3D; event.data;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Worker 线程代码如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; worker.js</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; settings</span><br><span class=\"line\">var num_workers &#x3D; 10;</span><br><span class=\"line\">var items_per_worker &#x3D; 1000000;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; start the workers</span><br><span class=\"line\">var result &#x3D; 0;</span><br><span class=\"line\">var pending_workers &#x3D; num_workers;</span><br><span class=\"line\">for (var i &#x3D; 0; i &lt; num_workers; i +&#x3D; 1) &#123;</span><br><span class=\"line\">  var worker &#x3D; new Worker(&#39;core.js&#39;);</span><br><span class=\"line\">  worker.postMessage(i * items_per_worker);</span><br><span class=\"line\">  worker.postMessage((i + 1) * items_per_worker);</span><br><span class=\"line\">  worker.onmessage &#x3D; storeResult;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; handle the results</span><br><span class=\"line\">function storeResult(event) &#123;</span><br><span class=\"line\">  result +&#x3D; event.data;</span><br><span class=\"line\">  pending_workers -&#x3D; 1;</span><br><span class=\"line\">  if (pending_workers &lt;&#x3D; 0)</span><br><span class=\"line\">    postMessage(result); &#x2F;&#x2F; finished!</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，Worker 线程内部新建了10个 Worker 线程，并且依次向这10个 Worker 发送消息，告知了计算的起点和终点。计算任务脚本的代码如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; core.js</span><br><span class=\"line\">var start;</span><br><span class=\"line\">onmessage &#x3D; getStart;</span><br><span class=\"line\">function getStart(event) &#123;</span><br><span class=\"line\">  start &#x3D; event.data;</span><br><span class=\"line\">  onmessage &#x3D; getEnd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var end;</span><br><span class=\"line\">function getEnd(event) &#123;</span><br><span class=\"line\">  end &#x3D; event.data;</span><br><span class=\"line\">  onmessage &#x3D; null;</span><br><span class=\"line\">  work();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function work() &#123;</span><br><span class=\"line\">  var result &#x3D; 0;</span><br><span class=\"line\">  for (var i &#x3D; start; i &lt; end; i +&#x3D; 1) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; perform some complex calculation here</span><br><span class=\"line\">    result +&#x3D; 1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  postMessage(result);</span><br><span class=\"line\">  close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"七、API\"><a href=\"#七、API\" class=\"headerlink\" title=\"七、API\"></a>七、API</h2><h3 id=\"7-1-主线程\"><a href=\"#7-1-主线程\" class=\"headerlink\" title=\"7.1 主线程\"></a>7.1 主线程</h3><p>浏览器原生提供Worker()构造函数，用来供主线程生成 Worker 线程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myWorker &#x3D; new Worker(jsUrl, options);</span><br></pre></td></tr></table></figure>\n<p>Worker()构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 主线程</span><br><span class=\"line\">var myWorker &#x3D; new Worker(&#39;worker.js&#39;, &#123; name : &#39;myWorker&#39; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Worker 线程</span><br><span class=\"line\">self.name &#x2F;&#x2F; myWorker</span><br></pre></td></tr></table></figure>\n\n<p>Worker()构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。Worker 线程对象的属性和方法如下。</p>\n<ul>\n<li>Worker.onerror：指定 error 事件的监听函数。</li>\n<li>Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在Event.data属性中。</li>\n<li>Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li>\n<li>Worker.postMessage()：向 Worker 线程发送消息。</li>\n<li>Worker.terminate()：立即终止 Worker 线程。</li>\n</ul>\n<h3 id=\"7-2-Worker-线程\"><a href=\"#7-2-Worker-线程\" class=\"headerlink\" title=\"7.2 Worker 线程\"></a>7.2 Worker 线程</h3><p>Web Worker 有自己的全局对象，不是主线程的window，而是一个专门为 Worker 定制的全局对象。因此定义在window上面的对象和方法不是全部都可以使用。</p>\n<p>Worker 线程有一些自己的全局属性和方法。</p>\n<ul>\n<li>self.name： Worker 的名字。该属性只读，由构造函数指定。</li>\n<li>self.onmessage：指定message事件的监听函数。</li>\n<li>self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li>\n<li>self.close()：关闭 Worker 线程。</li>\n<li>self.postMessage()：向产生这个 Worker 线程发送消息。</li>\n<li>self.importScripts()：加载 JS 脚本。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Web-Worker-使用教程\"><a href=\"#Web-Worker-使用教程\" class=\"headerlink\" title=\"Web Worker 使用教程\"></a>Web Worker 使用教程</h1><p>转载自<a href=\"http://www.ruanyifeng.com/blog/2018/07/web-worker.html\" target=\"_blank\" rel=\"noopener\">阮一峰</a></p>\n<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。</p>\n<p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p>\n<p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>\n<p>Web Worker 有以下几个使用注意点。</p>\n<p>（1）同源限制</p>\n<p>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p>\n<p>（2）DOM 限制</p>\n<p>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。</p>\n<p>（3）通信联系</p>\n<p>Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p>\n<p>（4）脚本限制</p>\n<p>Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</p>\n<p>（5）文件限制</p>\n<p>Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。</p>\n<h2 id=\"二、基本用法\"><a href=\"#二、基本用法\" class=\"headerlink\" title=\"二、基本用法\"></a>二、基本用法</h2><h3 id=\"2-1-主线程\"><a href=\"#2-1-主线程\" class=\"headerlink\" title=\"2.1 主线程\"></a>2.1 主线程</h3><p>主线程采用new命令，调用Worker()构造函数，新建一个 Worker 线程。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var worker = new Worker(<span class=\"string\">'work.js'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>Worker()构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。</p>\n<p>然后，主线程调用worker.postMessage()方法，向 Worker 发消息。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker.postMessage(<span class=\"string\">'Hello World'</span>);</span><br><span class=\"line\">worker.postMessage(&#123;method: <span class=\"string\">'echo'</span>, args: [<span class=\"string\">'Work'</span>]&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<p>worker.postMessage()方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。</p>\n<p>接着，主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker.onmessage &#x3D; function (event) &#123;</span><br><span class=\"line\">  console.log(&#39;Received message &#39; + event.data);</span><br><span class=\"line\">  doSomething();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function doSomething() &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; 执行任务</span><br><span class=\"line\">  worker.postMessage(&#39;Work done!&#39;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，事件对象的data属性可以获取 Worker 发来的数据。</p>\n<p>Worker 完成任务以后，主线程就可以把它关掉。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker.terminate();</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-Worker-线程\"><a href=\"#2-2-Worker-线程\" class=\"headerlink\" title=\"2.2 Worker 线程\"></a>2.2 Worker 线程</h3><p>Worker 线程内部需要有一个监听函数，监听message事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class=\"line\">  self.postMessage(&#39;You said: &#39; + e.data);</span><br><span class=\"line\">&#125;, false);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，self代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 写法一</span><br><span class=\"line\">this.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class=\"line\">  this.postMessage(&#39;You said: &#39; + e.data);</span><br><span class=\"line\">&#125;, false);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 写法二</span><br><span class=\"line\">addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class=\"line\">  postMessage(&#39;You said: &#39; + e.data);</span><br><span class=\"line\">&#125;, false);</span><br></pre></td></tr></table></figure>\n<p>除了使用self.addEventListener()指定监听函数，也可以使用self.onmessage指定。监听函数的参数是一个事件对象，它的data属性包含主线程发来的数据。self.postMessage()方法用来向主线程发送消息。</p>\n<p>根据主线程发来的数据，Worker 线程可以调用不同的方法，下面是一个例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class=\"line\">  var data &#x3D; e.data;</span><br><span class=\"line\">  switch (data.cmd) &#123;</span><br><span class=\"line\">    case &#39;start&#39;:</span><br><span class=\"line\">      self.postMessage(&#39;WORKER STARTED: &#39; + data.msg);</span><br><span class=\"line\">      break;</span><br><span class=\"line\">    case &#39;stop&#39;:</span><br><span class=\"line\">      self.postMessage(&#39;WORKER STOPPED: &#39; + data.msg);</span><br><span class=\"line\">      self.close(); &#x2F;&#x2F; Terminates the worker.</span><br><span class=\"line\">      break;</span><br><span class=\"line\">    default:</span><br><span class=\"line\">      self.postMessage(&#39;Unknown command: &#39; + data.msg);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;, false);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，self.close()用于在 Worker 内部关闭自身。</p>\n<h3 id=\"2-3-Worker-加载脚本\"><a href=\"#2-3-Worker-加载脚本\" class=\"headerlink\" title=\"2.3 Worker 加载脚本\"></a>2.3 Worker 加载脚本</h3><p>Worker 内部如果要加载其他脚本，有一个专门的方法importScripts()。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">importScripts(&#39;script1.js&#39;);</span><br></pre></td></tr></table></figure>\n<p>该方法可以同时加载多个脚本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">importScripts(&#39;script1.js&#39;, &#39;script2.js&#39;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-4-错误处理\"><a href=\"#2-4-错误处理\" class=\"headerlink\" title=\"2.4 错误处理\"></a>2.4 错误处理</h3><p>主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的error事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker.onerror(function (event) &#123;</span><br><span class=\"line\">  console.log([</span><br><span class=\"line\">    &#39;ERROR: Line &#39;, e.lineno, &#39; in &#39;, e.filename, &#39;: &#39;, e.message</span><br><span class=\"line\">  ].join(&#39;&#39;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 或者</span><br><span class=\"line\">worker.addEventListener(&#39;error&#39;, function (event) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ...</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Worker 内部也可以监听error事件。</p>\n<h3 id=\"2-5-关闭-Worker\"><a href=\"#2-5-关闭-Worker\" class=\"headerlink\" title=\"2.5 关闭 Worker\"></a>2.5 关闭 Worker</h3><p>使用完毕，为了节省系统资源，必须关闭 Worker。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 主线程</span><br><span class=\"line\">worker.terminate();</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Worker 线程</span><br><span class=\"line\">self.close();</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、数据通信\"><a href=\"#三、数据通信\" class=\"headerlink\" title=\"三、数据通信\"></a>三、数据通信</h2><p>前面说过，主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 Worker，后者再将它还原。</p>\n<p>主线程与 Worker 之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。下面是一个例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 主线程</span><br><span class=\"line\">var uInt8Array &#x3D; new Uint8Array(new ArrayBuffer(10));</span><br><span class=\"line\">for (var i &#x3D; 0; i &lt; uInt8Array.length; ++i) &#123;</span><br><span class=\"line\">  uInt8Array[i] &#x3D; i * 2; &#x2F;&#x2F; [0, 2, 4, 6, 8,...]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">worker.postMessage(uInt8Array);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Worker 线程</span><br><span class=\"line\">self.onmessage &#x3D; function (e) &#123;</span><br><span class=\"line\">  var uInt8Array &#x3D; e.data;</span><br><span class=\"line\">  postMessage(&#39;Inside worker.js: uInt8Array.toString() &#x3D; &#39; + uInt8Array.toString());</span><br><span class=\"line\">  postMessage(&#39;Inside worker.js: uInt8Array.byteLength &#x3D; &#39; + uInt8Array.byteLength);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做Transferable Objects。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。</p>\n<p>如果要直接转移数据的控制权，就要使用下面的写法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Transferable Objects 格式</span><br><span class=\"line\">worker.postMessage(arrayBuffer, [arrayBuffer]);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 例子</span><br><span class=\"line\">var ab &#x3D; new ArrayBuffer(1);</span><br><span class=\"line\">worker.postMessage(ab, [ab]);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、同页面的-Web-Worker\"><a href=\"#四、同页面的-Web-Worker\" class=\"headerlink\" title=\"四、同页面的 Web Worker\"></a>四、同页面的 Web Worker</h2><p>通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;script id&#x3D;&quot;worker&quot; type&#x3D;&quot;app&#x2F;worker&quot;&gt;</span><br><span class=\"line\">      addEventListener(&#39;message&#39;, function () &#123;</span><br><span class=\"line\">        postMessage(&#39;some message&#39;);</span><br><span class=\"line\">      &#125;, false);</span><br><span class=\"line\">    &lt;&#x2F;script&gt;</span><br><span class=\"line\">  &lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上面是一段嵌入网页的脚本，注意必须指定&lt;script&gt;标签的type属性是一个浏览器不认识的值，上例是app/worker。</p>\n<p>然后，读取这一段嵌入页面的脚本，用 Worker 来处理。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var blob &#x3D; new Blob([document.querySelector(&#39;#worker&#39;).textContent]);</span><br><span class=\"line\">var url &#x3D; window.URL.createObjectURL(blob);</span><br><span class=\"line\">var worker &#x3D; new Worker(url);</span><br><span class=\"line\"></span><br><span class=\"line\">worker.onmessage &#x3D; function (e) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; e.data &#x3D;&#x3D;&#x3D; &#39;some message&#39;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 URL，再让 Worker 加载这个 URL。这样就做到了，主线程和 Worker 的代码都在同一个网页上面。</p>\n<h2 id=\"五、实例：Worker-线程完成轮询\"><a href=\"#五、实例：Worker-线程完成轮询\" class=\"headerlink\" title=\"五、实例：Worker 线程完成轮询\"></a>五、实例：Worker 线程完成轮询</h2><p>有时，浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在 Worker 里面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createWorker(f) &#123;</span><br><span class=\"line\">  var blob &#x3D; new Blob([&#39;(&#39; + f.toString() +&#39;)()&#39;]);</span><br><span class=\"line\">  var url &#x3D; window.URL.createObjectURL(blob);</span><br><span class=\"line\">  var worker &#x3D; new Worker(url);</span><br><span class=\"line\">  return worker;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var pollingWorker &#x3D; createWorker(function (e) &#123;</span><br><span class=\"line\">  var cache;</span><br><span class=\"line\"></span><br><span class=\"line\">  function compare(new, old) &#123; ... &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  setInterval(function () &#123;</span><br><span class=\"line\">    fetch(&#39;&#x2F;my-api-endpoint&#39;).then(function (res) &#123;</span><br><span class=\"line\">      var data &#x3D; res.json();</span><br><span class=\"line\"></span><br><span class=\"line\">      if (!compare(data, cache)) &#123;</span><br><span class=\"line\">        cache &#x3D; data;</span><br><span class=\"line\">        self.postMessage(data);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;, 1000)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">pollingWorker.onmessage &#x3D; function () &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; render data</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">pollingWorker.postMessage(&#39;init&#39;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，Worker 每秒钟轮询一次数据，然后跟缓存做比较。如果不一致，就说明服务端有了新的变化，因此就要通知主线程。</p>\n<h2 id=\"六、实例：-Worker-新建-Worker\"><a href=\"#六、实例：-Worker-新建-Worker\" class=\"headerlink\" title=\"六、实例： Worker 新建 Worker\"></a>六、实例： Worker 新建 Worker</h2><p>Worker 线程内部还能再新建 Worker 线程（目前只有 Firefox 浏览器支持）。下面的例子是将一个计算密集的任务，分配到10个 Worker。</p>\n<p>主线程代码如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var worker &#x3D; new Worker(&#39;worker.js&#39;);</span><br><span class=\"line\">worker.onmessage &#x3D; function (event) &#123;</span><br><span class=\"line\">  document.getElementById(&#39;result&#39;).textContent &#x3D; event.data;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Worker 线程代码如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; worker.js</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; settings</span><br><span class=\"line\">var num_workers &#x3D; 10;</span><br><span class=\"line\">var items_per_worker &#x3D; 1000000;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; start the workers</span><br><span class=\"line\">var result &#x3D; 0;</span><br><span class=\"line\">var pending_workers &#x3D; num_workers;</span><br><span class=\"line\">for (var i &#x3D; 0; i &lt; num_workers; i +&#x3D; 1) &#123;</span><br><span class=\"line\">  var worker &#x3D; new Worker(&#39;core.js&#39;);</span><br><span class=\"line\">  worker.postMessage(i * items_per_worker);</span><br><span class=\"line\">  worker.postMessage((i + 1) * items_per_worker);</span><br><span class=\"line\">  worker.onmessage &#x3D; storeResult;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; handle the results</span><br><span class=\"line\">function storeResult(event) &#123;</span><br><span class=\"line\">  result +&#x3D; event.data;</span><br><span class=\"line\">  pending_workers -&#x3D; 1;</span><br><span class=\"line\">  if (pending_workers &lt;&#x3D; 0)</span><br><span class=\"line\">    postMessage(result); &#x2F;&#x2F; finished!</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，Worker 线程内部新建了10个 Worker 线程，并且依次向这10个 Worker 发送消息，告知了计算的起点和终点。计算任务脚本的代码如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; core.js</span><br><span class=\"line\">var start;</span><br><span class=\"line\">onmessage &#x3D; getStart;</span><br><span class=\"line\">function getStart(event) &#123;</span><br><span class=\"line\">  start &#x3D; event.data;</span><br><span class=\"line\">  onmessage &#x3D; getEnd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var end;</span><br><span class=\"line\">function getEnd(event) &#123;</span><br><span class=\"line\">  end &#x3D; event.data;</span><br><span class=\"line\">  onmessage &#x3D; null;</span><br><span class=\"line\">  work();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function work() &#123;</span><br><span class=\"line\">  var result &#x3D; 0;</span><br><span class=\"line\">  for (var i &#x3D; start; i &lt; end; i +&#x3D; 1) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; perform some complex calculation here</span><br><span class=\"line\">    result +&#x3D; 1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  postMessage(result);</span><br><span class=\"line\">  close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"七、API\"><a href=\"#七、API\" class=\"headerlink\" title=\"七、API\"></a>七、API</h2><h3 id=\"7-1-主线程\"><a href=\"#7-1-主线程\" class=\"headerlink\" title=\"7.1 主线程\"></a>7.1 主线程</h3><p>浏览器原生提供Worker()构造函数，用来供主线程生成 Worker 线程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myWorker &#x3D; new Worker(jsUrl, options);</span><br></pre></td></tr></table></figure>\n<p>Worker()构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 主线程</span><br><span class=\"line\">var myWorker &#x3D; new Worker(&#39;worker.js&#39;, &#123; name : &#39;myWorker&#39; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Worker 线程</span><br><span class=\"line\">self.name &#x2F;&#x2F; myWorker</span><br></pre></td></tr></table></figure>\n\n<p>Worker()构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。Worker 线程对象的属性和方法如下。</p>\n<ul>\n<li>Worker.onerror：指定 error 事件的监听函数。</li>\n<li>Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在Event.data属性中。</li>\n<li>Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li>\n<li>Worker.postMessage()：向 Worker 线程发送消息。</li>\n<li>Worker.terminate()：立即终止 Worker 线程。</li>\n</ul>\n<h3 id=\"7-2-Worker-线程\"><a href=\"#7-2-Worker-线程\" class=\"headerlink\" title=\"7.2 Worker 线程\"></a>7.2 Worker 线程</h3><p>Web Worker 有自己的全局对象，不是主线程的window，而是一个专门为 Worker 定制的全局对象。因此定义在window上面的对象和方法不是全部都可以使用。</p>\n<p>Worker 线程有一些自己的全局属性和方法。</p>\n<ul>\n<li>self.name： Worker 的名字。该属性只读，由构造函数指定。</li>\n<li>self.onmessage：指定message事件的监听函数。</li>\n<li>self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li>\n<li>self.close()：关闭 Worker 线程。</li>\n<li>self.postMessage()：向产生这个 Worker 线程发送消息。</li>\n<li>self.importScripts()：加载 JS 脚本。</li>\n</ul>\n"},{"_content":"# Back/Forward cache\n往返缓存（Back/Forward cache，下文中简称bfcache）是浏览器为了在用户页面间执行前进后退操作时拥有更加流畅体验的一种策略。该策略具体表现为，当用户前往新页面时，将当前页面的浏览器DOM状态保存到bfcache中；当用户点击后退按钮的时候，将页面直接从bfcache中加载，节省了网络请求的时间。\n\n比如：二级页面有用户操作行为导致的状态变更，我们希望回退时一级页面有相应的体现。这时希望浏览器不要展现缓存页面。\n\n**解决方案：**根据[浏览器往返缓存（Back/Forward cache）问题的分析与解决](https://github.com/LeuisKen/leuisken.github.io/issues/6)，尝试用worker，无效果。\n\n回退会触发：\n\n```\nwindow.addEventListener('pageshow', event => {\n  if (event.persisted) {\n    window.location.reload();\n  }\n});\n```\n这样页面会重新加载，但缓存的页面会闪现一下。如果页面有load动画，动画在闪现的缓存页面也会执行。\n\n**解决方案：**首页进入页面，动画执行完，移除动画dom，这样回退的时候，在缓存的页面就不会有动画。\n\n**完美方案：**缓存页面不闪现。（未解决）\n\n\n\n\n","source":"_posts/Back-Forward cache.md","raw":"# Back/Forward cache\n往返缓存（Back/Forward cache，下文中简称bfcache）是浏览器为了在用户页面间执行前进后退操作时拥有更加流畅体验的一种策略。该策略具体表现为，当用户前往新页面时，将当前页面的浏览器DOM状态保存到bfcache中；当用户点击后退按钮的时候，将页面直接从bfcache中加载，节省了网络请求的时间。\n\n比如：二级页面有用户操作行为导致的状态变更，我们希望回退时一级页面有相应的体现。这时希望浏览器不要展现缓存页面。\n\n**解决方案：**根据[浏览器往返缓存（Back/Forward cache）问题的分析与解决](https://github.com/LeuisKen/leuisken.github.io/issues/6)，尝试用worker，无效果。\n\n回退会触发：\n\n```\nwindow.addEventListener('pageshow', event => {\n  if (event.persisted) {\n    window.location.reload();\n  }\n});\n```\n这样页面会重新加载，但缓存的页面会闪现一下。如果页面有load动画，动画在闪现的缓存页面也会执行。\n\n**解决方案：**首页进入页面，动画执行完，移除动画dom，这样回退的时候，在缓存的页面就不会有动画。\n\n**完美方案：**缓存页面不闪现。（未解决）\n\n\n\n\n","slug":"Back-Forward cache","published":1,"date":"2020-07-06T01:52:15.276Z","updated":"2020-07-06T02:07:53.360Z","title":"Back-Forward cache","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc9vqhks0000v1c82btu80nz","content":"<h1 id=\"Back-Forward-cache\"><a href=\"#Back-Forward-cache\" class=\"headerlink\" title=\"Back/Forward cache\"></a>Back/Forward cache</h1><p>往返缓存（Back/Forward cache，下文中简称bfcache）是浏览器为了在用户页面间执行前进后退操作时拥有更加流畅体验的一种策略。该策略具体表现为，当用户前往新页面时，将当前页面的浏览器DOM状态保存到bfcache中；当用户点击后退按钮的时候，将页面直接从bfcache中加载，节省了网络请求的时间。</p>\n<p>比如：二级页面有用户操作行为导致的状态变更，我们希望回退时一级页面有相应的体现。这时希望浏览器不要展现缓存页面。</p>\n<p><strong>解决方案：</strong>根据<a href=\"https://github.com/LeuisKen/leuisken.github.io/issues/6\" target=\"_blank\" rel=\"noopener\">浏览器往返缓存（Back/Forward cache）问题的分析与解决</a>，尝试用worker，无效果。</p>\n<p>回退会触发：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&#39;pageshow&#39;, event &#x3D;&gt; &#123;</span><br><span class=\"line\">  if (event.persisted) &#123;</span><br><span class=\"line\">    window.location.reload();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这样页面会重新加载，但缓存的页面会闪现一下。如果页面有load动画，动画在闪现的缓存页面也会执行。</p>\n<p><strong>解决方案：</strong>首页进入页面，动画执行完，移除动画dom，这样回退的时候，在缓存的页面就不会有动画。</p>\n<p><strong>完美方案：</strong>缓存页面不闪现。（未解决）</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Back-Forward-cache\"><a href=\"#Back-Forward-cache\" class=\"headerlink\" title=\"Back/Forward cache\"></a>Back/Forward cache</h1><p>往返缓存（Back/Forward cache，下文中简称bfcache）是浏览器为了在用户页面间执行前进后退操作时拥有更加流畅体验的一种策略。该策略具体表现为，当用户前往新页面时，将当前页面的浏览器DOM状态保存到bfcache中；当用户点击后退按钮的时候，将页面直接从bfcache中加载，节省了网络请求的时间。</p>\n<p>比如：二级页面有用户操作行为导致的状态变更，我们希望回退时一级页面有相应的体现。这时希望浏览器不要展现缓存页面。</p>\n<p><strong>解决方案：</strong>根据<a href=\"https://github.com/LeuisKen/leuisken.github.io/issues/6\" target=\"_blank\" rel=\"noopener\">浏览器往返缓存（Back/Forward cache）问题的分析与解决</a>，尝试用worker，无效果。</p>\n<p>回退会触发：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&#39;pageshow&#39;, event &#x3D;&gt; &#123;</span><br><span class=\"line\">  if (event.persisted) &#123;</span><br><span class=\"line\">    window.location.reload();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这样页面会重新加载，但缓存的页面会闪现一下。如果页面有load动画，动画在闪现的缓存页面也会执行。</p>\n<p><strong>解决方案：</strong>首页进入页面，动画执行完，移除动画dom，这样回退的时候，在缓存的页面就不会有动画。</p>\n<p><strong>完美方案：</strong>缓存页面不闪现。（未解决）</p>\n"},{"_content":"# JavaScript 复杂判断的更优雅写法\n转载在[JavaScript 复杂判断的更优雅写法](https://mp.weixin.qq.com/s/JkZZbWOesqWDVGkUh2lRvg)\n\n## 前提\n我们编写js代码时经常遇到复杂逻辑判断的情况，通常大家可以用if/else或者switch来实现多个条件判断，但这样会有个问题，随着逻辑复杂度的增加，代码中的if/else/switch会变得越来越臃肿，越来越看不懂，那么如何更优雅的写判断逻辑，本文带你试一下。\n\n## 举个例子\n先看一段代码\n```\n/**\n     * 按钮点击事件\n     * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消\n     */const onButtonClick = (status)=>{\n      if(status == 1){\n        sendLog('processing')\n        jumpTo('IndexPage')\n      }elseif(status == 2){\n        sendLog('fail')\n        jumpTo('FailPage')\n      }elseif(status == 3){\n        sendLog('fail')\n        jumpTo('FailPage')\n      }elseif(status == 4){\n        sendLog('success')\n        jumpTo('SuccessPage')\n      }elseif(status == 5){\n        sendLog('cancel')\n        jumpTo('CancelPage')\n      }else {\n        sendLog('other')\n        jumpTo('Index')\n      }\n    }\n\n```\n\n通过代码可以看到这个按钮的点击逻辑：根据不同活动状态做两件事情，发送日志埋点和跳转到对应页面，大家可以很轻易的提出这段代码的改写方案，switch出场：\n```\n/**\n     * 按钮点击事件\n     * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消\n     */const onButtonClick = (status)=>{\n      switch (status){\n        case1:\n          sendLog('processing')\n          jumpTo('IndexPage')\n          breakcase2:\n        case3:\n          sendLog('fail')\n          jumpTo('FailPage')\n          breakcase4:\n          sendLog('success')\n          jumpTo('SuccessPage')\n          breakcase5:\n          sendLog('cancel')\n          jumpTo('CancelPage')\n          breakdefault:\n          sendLog('other')\n          jumpTo('Index')\n          break\n      }\n    }\n    ```\n    嗯，这样看起来比if/else清晰多了，细心的同学也发现了小技巧，case 2和case 3逻辑一样的时候，可以省去执行语句和break，则case 2的情况自动执行case 3的逻辑。\n\n这时有同学会说，还有更简单的写法：\n```\nconst actions = {\n      '1': ['processing','IndexPage'],\n      '2': ['fail','FailPage'],\n      '3': ['fail','FailPage'],\n      '4': ['success','SuccessPage'],\n      '5': ['cancel','CancelPage'],\n      'default': ['other','Index'],\n    }\n    /**\n     * 按钮点击事件\n     * @param {number} status 活动状态：1开团进行中 2开团失败 3 商品售罄 4 开团成功 5 系统取消\n     */const onButtonClick = (status)=>{\n      let action = actions[status] || actions['default'],\n          logName = action[0],\n          pageName = action[1]\n      sendLog(logName)\n      jumpTo(pageName)\n    }\n    ```\n    上面代码确实看起来更清爽了，这种方法的聪明之处在于：将判断条件作为对象的属性名，将处理逻辑作为对象的属性值，在按钮点击的时候，通过对象属性查找的方式来进行逻辑判断，这种写法特别适合一元条件判断的情况。\n\n是不是还有其他写法呢？有的：\n```\nconst actions = newMap([\n      [1, ['processing','IndexPage']],\n      [2, ['fail','FailPage']],\n      [3, ['fail','FailPage']],\n      [4, ['success','SuccessPage']],\n      [5, ['cancel','CancelPage']],\n      ['default', ['other','Index']]\n    ])\n    /**\n     * 按钮点击事件\n     * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消\n     */const onButtonClick = (status)=>{\n      let action = actions.get(status) || actions.get('default')\n      sendLog(action[0])\n      jumpTo(action[1])\n    }\n    ```\n    这样写用到了es6里的Map对象，是不是更爽了？Map对象和Object对象有什么区别呢？\n\n1. 一个对象通常都有自己的原型，所以一个对象总有一个\"prototype\"键。\n2. 一个对象的键只能是字符串或者Symbols，但一个Map的键可以是任意值。\n3. 你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。\n我们需要把问题升级一下，以前按钮点击时候只需要判断status，现在还需要判断用户的身份：\n```\n/**\n     * 按钮点击事件\n     * @param {number} status 活动状态：1开团进行中 2开团失败 3 开团成功 4 商品售罄 5 有库存未开团\n     * @param {string} identity 身份标识：guest客态 master主态\n     */const onButtonClick = (status,identity)=>{\n      if(identity == 'guest'){\n        if(status == 1){\n          //do sth\n        }elseif(status == 2){\n          //do sth\n        }elseif(status == 3){\n          //do sth\n        }elseif(status == 4){\n          //do sth\n        }elseif(status == 5){\n          //do sth\n        }else {\n          //do sth\n        }\n      }elseif(identity == 'master') {\n        if(status == 1){\n          //do sth\n        }elseif(status == 2){\n          //do sth\n        }elseif(status == 3){\n          //do sth\n        }elseif(status == 4){\n          //do sth\n        }elseif(status == 5){\n          //do sth\n        }else {\n          //do sth\n        }\n      }\n    }\n    ```\n原谅我不写每个判断里的具体逻辑了，因为代码太冗长了。\n\n原谅我又用了if/else，因为我看到很多人依然在用if/else写这种大段的逻辑判断。\n\n从上面的例子我们可以看到，当你的逻辑升级为二元判断时，你的判断量会加倍，你的代码量也会加倍，这时怎么写更清爽呢？\n\n```\nconst actions = newMap([\n      ['guest_1', ()=>{/*do sth*/}],\n      ['guest_2', ()=>{/*do sth*/}],\n      ['guest_3', ()=>{/*do sth*/}],\n      ['guest_4', ()=>{/*do sth*/}],\n      ['guest_5', ()=>{/*do sth*/}],\n      ['master_1', ()=>{/*do sth*/}],\n      ['master_2', ()=>{/*do sth*/}],\n      ['master_3', ()=>{/*do sth*/}],\n      ['master_4', ()=>{/*do sth*/}],\n      ['master_5', ()=>{/*do sth*/}],\n      ['default', ()=>{/*do sth*/}],\n    ])\n    \n    /**\n     * 按钮点击事件\n     * @param {string} identity 身份标识：guest客态 master主态\n     * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 开团成功 4 商品售罄 5 有库存未开团\n     */const onButtonClick = (identity,status)=>{\n      let action = actions.get(`${identity}_${status}`) || actions.get('default')\n      action.call(this)\n    }\n    ```\n上述代码核心逻辑是：把两个条件拼接成字符串，并通过以条件拼接字符串作为键，以处理函数作为值的Map对象进行查找并执行，这种写法在多元条件判断时候尤其好用。\n\n当然上述代码如果用Object对象来实现也是类似的：\n\n```\nconst actions = {\n      'guest_1':()=>{/*do sth*/},\n      'guest_2':()=>{/*do sth*/},\n      //....\n    }\n    \n    const onButtonClick = (identity,status)=>{\n      let action = actions[`${identity}_${status}`] || actions['default']\n      action.call(this)\n    }\n    ```\n如果有些同学觉得把查询条件拼成字符串有点别扭，那还有一种方案，就是用Map对象，以Object对象作为key：\n    \n    ```\n    const actions = newMap([\n      [{identity:'guest',status:1},()=>{/*do sth*/}],\n      [{identity:'guest',status:2},()=>{/*do sth*/}],\n      //...\n    ])\n    \n    const onButtonClick = (identity,status)=>{\n      let action = [...actions].filter(([key,value])=>(key.identity == identity && key.status == status))\n      action.forEach(([key,value])=>value.call(this))\n    }\n    ```\n是不是又高级了一点点？\n\n这里也看出来Map与Object的区别，Map可以用任何类型的数据作为key。\n\n我们现在再将难度升级一点点，假如guest情况下，status1-4的处理逻辑都一样怎么办，最差的情况是这样：\n\n```\nconst actions = newMap([\n      [{identity:'guest',status:1},()=>{/* functionA */}],\n      [{identity:'guest',status:2},()=>{/* functionA */}],\n      [{identity:'guest',status:3},()=>{/* functionA */}],\n      [{identity:'guest',status:4},()=>{/* functionA */}],\n      [{identity:'guest',status:5},()=>{/* functionB */}],\n      //...\n    ])\n    ```\n好一点的写法是将处理逻辑函数进行缓存：\n```\nconst actions = ()=>{\n      const functionA = ()=>{/*do sth*/}\n      const functionB = ()=>{/*do sth*/}\n      returnnewMap([\n        [{identity:'guest',status:1},functionA],\n        [{identity:'guest',status:2},functionA],\n        [{identity:'guest',status:3},functionA],\n        [{identity:'guest',status:4},functionA],\n        [{identity:'guest',status:5},functionB],\n        //...\n      ])\n    }\n    \n    const onButtonClick = (identity,status)=>{\n      let action = [...actions()].filter(([key,value])=>(key.identity == identity && key.status == status))\n      action.forEach(([key,value])=>value.call(this))\n    }\n    ```\n这样写已经能满足日常需求了，但认真一点讲，上面重写了4次functionA还是有点不爽，假如判断条件变得特别复杂，比如identity有3种状态，status有10种状态，那你需要定义30条处理逻辑，而往往这些逻辑里面很多都是相同的，这似乎也是笔者不想接受的，那可以这样实现:\n```\nconst actions = ()=>{\n      const functionA = ()=>{/*do sth*/}\n      const functionB = ()=>{/*do sth*/}\n      returnnewMap([\n        [/^guest_[1-4]$/,functionA],\n        [/^guest_5$/,functionB],\n        //...\n      ])\n    }\n    \n    const onButtonClick = (identity,status)=>{\n      let action = [...actions()].filter(([key,value])=>(key.test(`${identity}_${status}`)))\n      action.forEach(([key,value])=>value.call(this))\n    }\n```\n这里Map的优势更加凸显，可以用正则类型作为key了，这样就有了无限可能，假如需求变成，凡是guest情况都要发送一个日志埋点，不同status情况也需要单独的逻辑处理，那我们可以这样写:\n```\nconst actions = ()=>{\n      const functionA = ()=>{/*do sth*/}\n      const functionB = ()=>{/*do sth*/}\n      const functionC = ()=>{/*send log*/}\n      returnnewMap([\n        [/^guest_[1-4]$/,functionA],\n        [/^guest_5$/,functionB],\n        [/^guest_.*$/,functionC],\n        //...\n      ])\n    }\n    \n    const onButtonClick = (identity,status)=>{\n      let action = [...actions()].filter(([key,value])=>(key.test(`${identity}_${status}`)))\n      action.forEach(([key,value])=>value.call(this))\n    }\n    ```\n也就是说利用数组循环的特性，符合正则条件的逻辑都会被执行，那就可以同时执行公共逻辑和单独逻辑，因为正则的存在，你可以打开想象力解锁更多的玩法，本文就不赘述了。\n\n## 总结\n本文已经教你了8种逻辑判断写法，包括：\n\nif/else\nswitch\n一元判断时：存到Object里\n一元判断时：存到Map里\n多元判断时：将condition拼接成字符串存到Object里\n多元判断时：将condition拼接成字符串存到Map里\n多元判断时：将condition存为Object存到Map里\n多元判断时：将condition写作正则存到Map里\n至此，本文也将告一段落，愿你未来的人生里，不只是有if/else/switch。\n\n","source":"_posts/JavaScript 复杂判断的更优雅写法.md","raw":"# JavaScript 复杂判断的更优雅写法\n转载在[JavaScript 复杂判断的更优雅写法](https://mp.weixin.qq.com/s/JkZZbWOesqWDVGkUh2lRvg)\n\n## 前提\n我们编写js代码时经常遇到复杂逻辑判断的情况，通常大家可以用if/else或者switch来实现多个条件判断，但这样会有个问题，随着逻辑复杂度的增加，代码中的if/else/switch会变得越来越臃肿，越来越看不懂，那么如何更优雅的写判断逻辑，本文带你试一下。\n\n## 举个例子\n先看一段代码\n```\n/**\n     * 按钮点击事件\n     * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消\n     */const onButtonClick = (status)=>{\n      if(status == 1){\n        sendLog('processing')\n        jumpTo('IndexPage')\n      }elseif(status == 2){\n        sendLog('fail')\n        jumpTo('FailPage')\n      }elseif(status == 3){\n        sendLog('fail')\n        jumpTo('FailPage')\n      }elseif(status == 4){\n        sendLog('success')\n        jumpTo('SuccessPage')\n      }elseif(status == 5){\n        sendLog('cancel')\n        jumpTo('CancelPage')\n      }else {\n        sendLog('other')\n        jumpTo('Index')\n      }\n    }\n\n```\n\n通过代码可以看到这个按钮的点击逻辑：根据不同活动状态做两件事情，发送日志埋点和跳转到对应页面，大家可以很轻易的提出这段代码的改写方案，switch出场：\n```\n/**\n     * 按钮点击事件\n     * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消\n     */const onButtonClick = (status)=>{\n      switch (status){\n        case1:\n          sendLog('processing')\n          jumpTo('IndexPage')\n          breakcase2:\n        case3:\n          sendLog('fail')\n          jumpTo('FailPage')\n          breakcase4:\n          sendLog('success')\n          jumpTo('SuccessPage')\n          breakcase5:\n          sendLog('cancel')\n          jumpTo('CancelPage')\n          breakdefault:\n          sendLog('other')\n          jumpTo('Index')\n          break\n      }\n    }\n    ```\n    嗯，这样看起来比if/else清晰多了，细心的同学也发现了小技巧，case 2和case 3逻辑一样的时候，可以省去执行语句和break，则case 2的情况自动执行case 3的逻辑。\n\n这时有同学会说，还有更简单的写法：\n```\nconst actions = {\n      '1': ['processing','IndexPage'],\n      '2': ['fail','FailPage'],\n      '3': ['fail','FailPage'],\n      '4': ['success','SuccessPage'],\n      '5': ['cancel','CancelPage'],\n      'default': ['other','Index'],\n    }\n    /**\n     * 按钮点击事件\n     * @param {number} status 活动状态：1开团进行中 2开团失败 3 商品售罄 4 开团成功 5 系统取消\n     */const onButtonClick = (status)=>{\n      let action = actions[status] || actions['default'],\n          logName = action[0],\n          pageName = action[1]\n      sendLog(logName)\n      jumpTo(pageName)\n    }\n    ```\n    上面代码确实看起来更清爽了，这种方法的聪明之处在于：将判断条件作为对象的属性名，将处理逻辑作为对象的属性值，在按钮点击的时候，通过对象属性查找的方式来进行逻辑判断，这种写法特别适合一元条件判断的情况。\n\n是不是还有其他写法呢？有的：\n```\nconst actions = newMap([\n      [1, ['processing','IndexPage']],\n      [2, ['fail','FailPage']],\n      [3, ['fail','FailPage']],\n      [4, ['success','SuccessPage']],\n      [5, ['cancel','CancelPage']],\n      ['default', ['other','Index']]\n    ])\n    /**\n     * 按钮点击事件\n     * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消\n     */const onButtonClick = (status)=>{\n      let action = actions.get(status) || actions.get('default')\n      sendLog(action[0])\n      jumpTo(action[1])\n    }\n    ```\n    这样写用到了es6里的Map对象，是不是更爽了？Map对象和Object对象有什么区别呢？\n\n1. 一个对象通常都有自己的原型，所以一个对象总有一个\"prototype\"键。\n2. 一个对象的键只能是字符串或者Symbols，但一个Map的键可以是任意值。\n3. 你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。\n我们需要把问题升级一下，以前按钮点击时候只需要判断status，现在还需要判断用户的身份：\n```\n/**\n     * 按钮点击事件\n     * @param {number} status 活动状态：1开团进行中 2开团失败 3 开团成功 4 商品售罄 5 有库存未开团\n     * @param {string} identity 身份标识：guest客态 master主态\n     */const onButtonClick = (status,identity)=>{\n      if(identity == 'guest'){\n        if(status == 1){\n          //do sth\n        }elseif(status == 2){\n          //do sth\n        }elseif(status == 3){\n          //do sth\n        }elseif(status == 4){\n          //do sth\n        }elseif(status == 5){\n          //do sth\n        }else {\n          //do sth\n        }\n      }elseif(identity == 'master') {\n        if(status == 1){\n          //do sth\n        }elseif(status == 2){\n          //do sth\n        }elseif(status == 3){\n          //do sth\n        }elseif(status == 4){\n          //do sth\n        }elseif(status == 5){\n          //do sth\n        }else {\n          //do sth\n        }\n      }\n    }\n    ```\n原谅我不写每个判断里的具体逻辑了，因为代码太冗长了。\n\n原谅我又用了if/else，因为我看到很多人依然在用if/else写这种大段的逻辑判断。\n\n从上面的例子我们可以看到，当你的逻辑升级为二元判断时，你的判断量会加倍，你的代码量也会加倍，这时怎么写更清爽呢？\n\n```\nconst actions = newMap([\n      ['guest_1', ()=>{/*do sth*/}],\n      ['guest_2', ()=>{/*do sth*/}],\n      ['guest_3', ()=>{/*do sth*/}],\n      ['guest_4', ()=>{/*do sth*/}],\n      ['guest_5', ()=>{/*do sth*/}],\n      ['master_1', ()=>{/*do sth*/}],\n      ['master_2', ()=>{/*do sth*/}],\n      ['master_3', ()=>{/*do sth*/}],\n      ['master_4', ()=>{/*do sth*/}],\n      ['master_5', ()=>{/*do sth*/}],\n      ['default', ()=>{/*do sth*/}],\n    ])\n    \n    /**\n     * 按钮点击事件\n     * @param {string} identity 身份标识：guest客态 master主态\n     * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 开团成功 4 商品售罄 5 有库存未开团\n     */const onButtonClick = (identity,status)=>{\n      let action = actions.get(`${identity}_${status}`) || actions.get('default')\n      action.call(this)\n    }\n    ```\n上述代码核心逻辑是：把两个条件拼接成字符串，并通过以条件拼接字符串作为键，以处理函数作为值的Map对象进行查找并执行，这种写法在多元条件判断时候尤其好用。\n\n当然上述代码如果用Object对象来实现也是类似的：\n\n```\nconst actions = {\n      'guest_1':()=>{/*do sth*/},\n      'guest_2':()=>{/*do sth*/},\n      //....\n    }\n    \n    const onButtonClick = (identity,status)=>{\n      let action = actions[`${identity}_${status}`] || actions['default']\n      action.call(this)\n    }\n    ```\n如果有些同学觉得把查询条件拼成字符串有点别扭，那还有一种方案，就是用Map对象，以Object对象作为key：\n    \n    ```\n    const actions = newMap([\n      [{identity:'guest',status:1},()=>{/*do sth*/}],\n      [{identity:'guest',status:2},()=>{/*do sth*/}],\n      //...\n    ])\n    \n    const onButtonClick = (identity,status)=>{\n      let action = [...actions].filter(([key,value])=>(key.identity == identity && key.status == status))\n      action.forEach(([key,value])=>value.call(this))\n    }\n    ```\n是不是又高级了一点点？\n\n这里也看出来Map与Object的区别，Map可以用任何类型的数据作为key。\n\n我们现在再将难度升级一点点，假如guest情况下，status1-4的处理逻辑都一样怎么办，最差的情况是这样：\n\n```\nconst actions = newMap([\n      [{identity:'guest',status:1},()=>{/* functionA */}],\n      [{identity:'guest',status:2},()=>{/* functionA */}],\n      [{identity:'guest',status:3},()=>{/* functionA */}],\n      [{identity:'guest',status:4},()=>{/* functionA */}],\n      [{identity:'guest',status:5},()=>{/* functionB */}],\n      //...\n    ])\n    ```\n好一点的写法是将处理逻辑函数进行缓存：\n```\nconst actions = ()=>{\n      const functionA = ()=>{/*do sth*/}\n      const functionB = ()=>{/*do sth*/}\n      returnnewMap([\n        [{identity:'guest',status:1},functionA],\n        [{identity:'guest',status:2},functionA],\n        [{identity:'guest',status:3},functionA],\n        [{identity:'guest',status:4},functionA],\n        [{identity:'guest',status:5},functionB],\n        //...\n      ])\n    }\n    \n    const onButtonClick = (identity,status)=>{\n      let action = [...actions()].filter(([key,value])=>(key.identity == identity && key.status == status))\n      action.forEach(([key,value])=>value.call(this))\n    }\n    ```\n这样写已经能满足日常需求了，但认真一点讲，上面重写了4次functionA还是有点不爽，假如判断条件变得特别复杂，比如identity有3种状态，status有10种状态，那你需要定义30条处理逻辑，而往往这些逻辑里面很多都是相同的，这似乎也是笔者不想接受的，那可以这样实现:\n```\nconst actions = ()=>{\n      const functionA = ()=>{/*do sth*/}\n      const functionB = ()=>{/*do sth*/}\n      returnnewMap([\n        [/^guest_[1-4]$/,functionA],\n        [/^guest_5$/,functionB],\n        //...\n      ])\n    }\n    \n    const onButtonClick = (identity,status)=>{\n      let action = [...actions()].filter(([key,value])=>(key.test(`${identity}_${status}`)))\n      action.forEach(([key,value])=>value.call(this))\n    }\n```\n这里Map的优势更加凸显，可以用正则类型作为key了，这样就有了无限可能，假如需求变成，凡是guest情况都要发送一个日志埋点，不同status情况也需要单独的逻辑处理，那我们可以这样写:\n```\nconst actions = ()=>{\n      const functionA = ()=>{/*do sth*/}\n      const functionB = ()=>{/*do sth*/}\n      const functionC = ()=>{/*send log*/}\n      returnnewMap([\n        [/^guest_[1-4]$/,functionA],\n        [/^guest_5$/,functionB],\n        [/^guest_.*$/,functionC],\n        //...\n      ])\n    }\n    \n    const onButtonClick = (identity,status)=>{\n      let action = [...actions()].filter(([key,value])=>(key.test(`${identity}_${status}`)))\n      action.forEach(([key,value])=>value.call(this))\n    }\n    ```\n也就是说利用数组循环的特性，符合正则条件的逻辑都会被执行，那就可以同时执行公共逻辑和单独逻辑，因为正则的存在，你可以打开想象力解锁更多的玩法，本文就不赘述了。\n\n## 总结\n本文已经教你了8种逻辑判断写法，包括：\n\nif/else\nswitch\n一元判断时：存到Object里\n一元判断时：存到Map里\n多元判断时：将condition拼接成字符串存到Object里\n多元判断时：将condition拼接成字符串存到Map里\n多元判断时：将condition存为Object存到Map里\n多元判断时：将condition写作正则存到Map里\n至此，本文也将告一段落，愿你未来的人生里，不只是有if/else/switch。\n\n","slug":"JavaScript 复杂判断的更优雅写法","published":1,"date":"2020-07-06T02:26:58.596Z","updated":"2020-07-06T03:14:09.173Z","title":"JavaScript 复杂判断的更优雅写法","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc9xlw2c0000v6c86pjo6om1","content":"<h1 id=\"JavaScript-复杂判断的更优雅写法\"><a href=\"#JavaScript-复杂判断的更优雅写法\" class=\"headerlink\" title=\"JavaScript 复杂判断的更优雅写法\"></a>JavaScript 复杂判断的更优雅写法</h1><p>转载在<a href=\"https://mp.weixin.qq.com/s/JkZZbWOesqWDVGkUh2lRvg\" target=\"_blank\" rel=\"noopener\">JavaScript 复杂判断的更优雅写法</a></p>\n<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2><p>我们编写js代码时经常遇到复杂逻辑判断的情况，通常大家可以用if/else或者switch来实现多个条件判断，但这样会有个问题，随着逻辑复杂度的增加，代码中的if/else/switch会变得越来越臃肿，越来越看不懂，那么如何更优雅的写判断逻辑，本文带你试一下。</p>\n<h2 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h2><p>先看一段代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\">     * 按钮点击事件</span><br><span class=\"line\">     * @param &#123;number&#125; status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消</span><br><span class=\"line\">     *&#x2F;const onButtonClick &#x3D; (status)&#x3D;&gt;&#123;</span><br><span class=\"line\">      if(status &#x3D;&#x3D; 1)&#123;</span><br><span class=\"line\">        sendLog(&#39;processing&#39;)</span><br><span class=\"line\">        jumpTo(&#39;IndexPage&#39;)</span><br><span class=\"line\">      &#125;elseif(status &#x3D;&#x3D; 2)&#123;</span><br><span class=\"line\">        sendLog(&#39;fail&#39;)</span><br><span class=\"line\">        jumpTo(&#39;FailPage&#39;)</span><br><span class=\"line\">      &#125;elseif(status &#x3D;&#x3D; 3)&#123;</span><br><span class=\"line\">        sendLog(&#39;fail&#39;)</span><br><span class=\"line\">        jumpTo(&#39;FailPage&#39;)</span><br><span class=\"line\">      &#125;elseif(status &#x3D;&#x3D; 4)&#123;</span><br><span class=\"line\">        sendLog(&#39;success&#39;)</span><br><span class=\"line\">        jumpTo(&#39;SuccessPage&#39;)</span><br><span class=\"line\">      &#125;elseif(status &#x3D;&#x3D; 5)&#123;</span><br><span class=\"line\">        sendLog(&#39;cancel&#39;)</span><br><span class=\"line\">        jumpTo(&#39;CancelPage&#39;)</span><br><span class=\"line\">      &#125;else &#123;</span><br><span class=\"line\">        sendLog(&#39;other&#39;)</span><br><span class=\"line\">        jumpTo(&#39;Index&#39;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过代码可以看到这个按钮的点击逻辑：根据不同活动状态做两件事情，发送日志埋点和跳转到对应页面，大家可以很轻易的提出这段代码的改写方案，switch出场：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\">     * 按钮点击事件</span><br><span class=\"line\">     * @param &#123;number&#125; status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消</span><br><span class=\"line\">     *&#x2F;const onButtonClick &#x3D; (status)&#x3D;&gt;&#123;</span><br><span class=\"line\">      switch (status)&#123;</span><br><span class=\"line\">        case1:</span><br><span class=\"line\">          sendLog(&#39;processing&#39;)</span><br><span class=\"line\">          jumpTo(&#39;IndexPage&#39;)</span><br><span class=\"line\">          breakcase2:</span><br><span class=\"line\">        case3:</span><br><span class=\"line\">          sendLog(&#39;fail&#39;)</span><br><span class=\"line\">          jumpTo(&#39;FailPage&#39;)</span><br><span class=\"line\">          breakcase4:</span><br><span class=\"line\">          sendLog(&#39;success&#39;)</span><br><span class=\"line\">          jumpTo(&#39;SuccessPage&#39;)</span><br><span class=\"line\">          breakcase5:</span><br><span class=\"line\">          sendLog(&#39;cancel&#39;)</span><br><span class=\"line\">          jumpTo(&#39;CancelPage&#39;)</span><br><span class=\"line\">          breakdefault:</span><br><span class=\"line\">          sendLog(&#39;other&#39;)</span><br><span class=\"line\">          jumpTo(&#39;Index&#39;)</span><br><span class=\"line\">          break</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<pre><code>嗯，这样看起来比if/else清晰多了，细心的同学也发现了小技巧，case 2和case 3逻辑一样的时候，可以省去执行语句和break，则case 2的情况自动执行case 3的逻辑。</code></pre><p>这时有同学会说，还有更简单的写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const actions &#x3D; &#123;</span><br><span class=\"line\">      &#39;1&#39;: [&#39;processing&#39;,&#39;IndexPage&#39;],</span><br><span class=\"line\">      &#39;2&#39;: [&#39;fail&#39;,&#39;FailPage&#39;],</span><br><span class=\"line\">      &#39;3&#39;: [&#39;fail&#39;,&#39;FailPage&#39;],</span><br><span class=\"line\">      &#39;4&#39;: [&#39;success&#39;,&#39;SuccessPage&#39;],</span><br><span class=\"line\">      &#39;5&#39;: [&#39;cancel&#39;,&#39;CancelPage&#39;],</span><br><span class=\"line\">      &#39;default&#39;: [&#39;other&#39;,&#39;Index&#39;],</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;**</span><br><span class=\"line\">     * 按钮点击事件</span><br><span class=\"line\">     * @param &#123;number&#125; status 活动状态：1开团进行中 2开团失败 3 商品售罄 4 开团成功 5 系统取消</span><br><span class=\"line\">     *&#x2F;const onButtonClick &#x3D; (status)&#x3D;&gt;&#123;</span><br><span class=\"line\">      let action &#x3D; actions[status] || actions[&#39;default&#39;],</span><br><span class=\"line\">          logName &#x3D; action[0],</span><br><span class=\"line\">          pageName &#x3D; action[1]</span><br><span class=\"line\">      sendLog(logName)</span><br><span class=\"line\">      jumpTo(pageName)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<pre><code>上面代码确实看起来更清爽了，这种方法的聪明之处在于：将判断条件作为对象的属性名，将处理逻辑作为对象的属性值，在按钮点击的时候，通过对象属性查找的方式来进行逻辑判断，这种写法特别适合一元条件判断的情况。</code></pre><p>是不是还有其他写法呢？有的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const actions &#x3D; newMap([</span><br><span class=\"line\">      [1, [&#39;processing&#39;,&#39;IndexPage&#39;]],</span><br><span class=\"line\">      [2, [&#39;fail&#39;,&#39;FailPage&#39;]],</span><br><span class=\"line\">      [3, [&#39;fail&#39;,&#39;FailPage&#39;]],</span><br><span class=\"line\">      [4, [&#39;success&#39;,&#39;SuccessPage&#39;]],</span><br><span class=\"line\">      [5, [&#39;cancel&#39;,&#39;CancelPage&#39;]],</span><br><span class=\"line\">      [&#39;default&#39;, [&#39;other&#39;,&#39;Index&#39;]]</span><br><span class=\"line\">    ])</span><br><span class=\"line\">    &#x2F;**</span><br><span class=\"line\">     * 按钮点击事件</span><br><span class=\"line\">     * @param &#123;number&#125; status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消</span><br><span class=\"line\">     *&#x2F;const onButtonClick &#x3D; (status)&#x3D;&gt;&#123;</span><br><span class=\"line\">      let action &#x3D; actions.get(status) || actions.get(&#39;default&#39;)</span><br><span class=\"line\">      sendLog(action[0])</span><br><span class=\"line\">      jumpTo(action[1])</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<pre><code>这样写用到了es6里的Map对象，是不是更爽了？Map对象和Object对象有什么区别呢？</code></pre><ol>\n<li>一个对象通常都有自己的原型，所以一个对象总有一个”prototype”键。</li>\n<li>一个对象的键只能是字符串或者Symbols，但一个Map的键可以是任意值。</li>\n<li>你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。<br>我们需要把问题升级一下，以前按钮点击时候只需要判断status，现在还需要判断用户的身份：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\">     * 按钮点击事件</span><br><span class=\"line\">     * @param &#123;number&#125; status 活动状态：1开团进行中 2开团失败 3 开团成功 4 商品售罄 5 有库存未开团</span><br><span class=\"line\">     * @param &#123;string&#125; identity 身份标识：guest客态 master主态</span><br><span class=\"line\">     *&#x2F;const onButtonClick &#x3D; (status,identity)&#x3D;&gt;&#123;</span><br><span class=\"line\">      if(identity &#x3D;&#x3D; &#39;guest&#39;)&#123;</span><br><span class=\"line\">        if(status &#x3D;&#x3D; 1)&#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;elseif(status &#x3D;&#x3D; 2)&#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;elseif(status &#x3D;&#x3D; 3)&#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;elseif(status &#x3D;&#x3D; 4)&#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;elseif(status &#x3D;&#x3D; 5)&#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;elseif(identity &#x3D;&#x3D; &#39;master&#39;) &#123;</span><br><span class=\"line\">        if(status &#x3D;&#x3D; 1)&#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;elseif(status &#x3D;&#x3D; 2)&#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;elseif(status &#x3D;&#x3D; 3)&#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;elseif(status &#x3D;&#x3D; 4)&#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;elseif(status &#x3D;&#x3D; 5)&#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n原谅我不写每个判断里的具体逻辑了，因为代码太冗长了。</li>\n</ol>\n<p>原谅我又用了if/else，因为我看到很多人依然在用if/else写这种大段的逻辑判断。</p>\n<p>从上面的例子我们可以看到，当你的逻辑升级为二元判断时，你的判断量会加倍，你的代码量也会加倍，这时怎么写更清爽呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const actions &#x3D; newMap([</span><br><span class=\"line\">      [&#39;guest_1&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">      [&#39;guest_2&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">      [&#39;guest_3&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">      [&#39;guest_4&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">      [&#39;guest_5&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">      [&#39;master_1&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">      [&#39;master_2&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">      [&#39;master_3&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">      [&#39;master_4&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">      [&#39;master_5&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">      [&#39;default&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">    ])</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;**</span><br><span class=\"line\">     * 按钮点击事件</span><br><span class=\"line\">     * @param &#123;string&#125; identity 身份标识：guest客态 master主态</span><br><span class=\"line\">     * @param &#123;number&#125; status 活动状态：1 开团进行中 2 开团失败 3 开团成功 4 商品售罄 5 有库存未开团</span><br><span class=\"line\">     *&#x2F;const onButtonClick &#x3D; (identity,status)&#x3D;&gt;&#123;</span><br><span class=\"line\">      let action &#x3D; actions.get(&#96;$&#123;identity&#125;_$&#123;status&#125;&#96;) || actions.get(&#39;default&#39;)</span><br><span class=\"line\">      action.call(this)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码核心逻辑是：把两个条件拼接成字符串，并通过以条件拼接字符串作为键，以处理函数作为值的Map对象进行查找并执行，这种写法在多元条件判断时候尤其好用。</p>\n<p>当然上述代码如果用Object对象来实现也是类似的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const actions &#x3D; &#123;</span><br><span class=\"line\">      &#39;guest_1&#39;:()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;,</span><br><span class=\"line\">      &#39;guest_2&#39;:()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;,</span><br><span class=\"line\">      &#x2F;&#x2F;....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    const onButtonClick &#x3D; (identity,status)&#x3D;&gt;&#123;</span><br><span class=\"line\">      let action &#x3D; actions[&#96;$&#123;identity&#125;_$&#123;status&#125;&#96;] || actions[&#39;default&#39;]</span><br><span class=\"line\">      action.call(this)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>如果有些同学觉得把查询条件拼成字符串有点别扭，那还有一种方案，就是用Map对象，以Object对象作为key：</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const actions &#x3D; newMap([</span><br><span class=\"line\">  [&#123;identity:&#39;guest&#39;,status:1&#125;,()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">  [&#123;identity:&#39;guest&#39;,status:2&#125;,()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">  &#x2F;&#x2F;...</span><br><span class=\"line\">])</span><br><span class=\"line\"></span><br><span class=\"line\">const onButtonClick &#x3D; (identity,status)&#x3D;&gt;&#123;</span><br><span class=\"line\">  let action &#x3D; [...actions].filter(([key,value])&#x3D;&gt;(key.identity &#x3D;&#x3D; identity &amp;&amp; key.status &#x3D;&#x3D; status))</span><br><span class=\"line\">  action.forEach(([key,value])&#x3D;&gt;value.call(this))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>是不是又高级了一点点？</p>\n<p>这里也看出来Map与Object的区别，Map可以用任何类型的数据作为key。</p>\n<p>我们现在再将难度升级一点点，假如guest情况下，status1-4的处理逻辑都一样怎么办，最差的情况是这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const actions &#x3D; newMap([</span><br><span class=\"line\">      [&#123;identity:&#39;guest&#39;,status:1&#125;,()&#x3D;&gt;&#123;&#x2F;* functionA *&#x2F;&#125;],</span><br><span class=\"line\">      [&#123;identity:&#39;guest&#39;,status:2&#125;,()&#x3D;&gt;&#123;&#x2F;* functionA *&#x2F;&#125;],</span><br><span class=\"line\">      [&#123;identity:&#39;guest&#39;,status:3&#125;,()&#x3D;&gt;&#123;&#x2F;* functionA *&#x2F;&#125;],</span><br><span class=\"line\">      [&#123;identity:&#39;guest&#39;,status:4&#125;,()&#x3D;&gt;&#123;&#x2F;* functionA *&#x2F;&#125;],</span><br><span class=\"line\">      [&#123;identity:&#39;guest&#39;,status:5&#125;,()&#x3D;&gt;&#123;&#x2F;* functionB *&#x2F;&#125;],</span><br><span class=\"line\">      &#x2F;&#x2F;...</span><br><span class=\"line\">    ])</span><br></pre></td></tr></table></figure>\n<p>好一点的写法是将处理逻辑函数进行缓存：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const actions &#x3D; ()&#x3D;&gt;&#123;</span><br><span class=\"line\">      const functionA &#x3D; ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;</span><br><span class=\"line\">      const functionB &#x3D; ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;</span><br><span class=\"line\">      returnnewMap([</span><br><span class=\"line\">        [&#123;identity:&#39;guest&#39;,status:1&#125;,functionA],</span><br><span class=\"line\">        [&#123;identity:&#39;guest&#39;,status:2&#125;,functionA],</span><br><span class=\"line\">        [&#123;identity:&#39;guest&#39;,status:3&#125;,functionA],</span><br><span class=\"line\">        [&#123;identity:&#39;guest&#39;,status:4&#125;,functionA],</span><br><span class=\"line\">        [&#123;identity:&#39;guest&#39;,status:5&#125;,functionB],</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">      ])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    const onButtonClick &#x3D; (identity,status)&#x3D;&gt;&#123;</span><br><span class=\"line\">      let action &#x3D; [...actions()].filter(([key,value])&#x3D;&gt;(key.identity &#x3D;&#x3D; identity &amp;&amp; key.status &#x3D;&#x3D; status))</span><br><span class=\"line\">      action.forEach(([key,value])&#x3D;&gt;value.call(this))</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这样写已经能满足日常需求了，但认真一点讲，上面重写了4次functionA还是有点不爽，假如判断条件变得特别复杂，比如identity有3种状态，status有10种状态，那你需要定义30条处理逻辑，而往往这些逻辑里面很多都是相同的，这似乎也是笔者不想接受的，那可以这样实现:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const actions &#x3D; ()&#x3D;&gt;&#123;</span><br><span class=\"line\">      const functionA &#x3D; ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;</span><br><span class=\"line\">      const functionB &#x3D; ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;</span><br><span class=\"line\">      returnnewMap([</span><br><span class=\"line\">        [&#x2F;^guest_[1-4]$&#x2F;,functionA],</span><br><span class=\"line\">        [&#x2F;^guest_5$&#x2F;,functionB],</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">      ])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    const onButtonClick &#x3D; (identity,status)&#x3D;&gt;&#123;</span><br><span class=\"line\">      let action &#x3D; [...actions()].filter(([key,value])&#x3D;&gt;(key.test(&#96;$&#123;identity&#125;_$&#123;status&#125;&#96;)))</span><br><span class=\"line\">      action.forEach(([key,value])&#x3D;&gt;value.call(this))</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这里Map的优势更加凸显，可以用正则类型作为key了，这样就有了无限可能，假如需求变成，凡是guest情况都要发送一个日志埋点，不同status情况也需要单独的逻辑处理，那我们可以这样写:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const actions &#x3D; ()&#x3D;&gt;&#123;</span><br><span class=\"line\">      const functionA &#x3D; ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;</span><br><span class=\"line\">      const functionB &#x3D; ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;</span><br><span class=\"line\">      const functionC &#x3D; ()&#x3D;&gt;&#123;&#x2F;*send log*&#x2F;&#125;</span><br><span class=\"line\">      returnnewMap([</span><br><span class=\"line\">        [&#x2F;^guest_[1-4]$&#x2F;,functionA],</span><br><span class=\"line\">        [&#x2F;^guest_5$&#x2F;,functionB],</span><br><span class=\"line\">        [&#x2F;^guest_.*$&#x2F;,functionC],</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">      ])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    const onButtonClick &#x3D; (identity,status)&#x3D;&gt;&#123;</span><br><span class=\"line\">      let action &#x3D; [...actions()].filter(([key,value])&#x3D;&gt;(key.test(&#96;$&#123;identity&#125;_$&#123;status&#125;&#96;)))</span><br><span class=\"line\">      action.forEach(([key,value])&#x3D;&gt;value.call(this))</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说利用数组循环的特性，符合正则条件的逻辑都会被执行，那就可以同时执行公共逻辑和单独逻辑，因为正则的存在，你可以打开想象力解锁更多的玩法，本文就不赘述了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文已经教你了8种逻辑判断写法，包括：</p>\n<p>if/else<br>switch<br>一元判断时：存到Object里<br>一元判断时：存到Map里<br>多元判断时：将condition拼接成字符串存到Object里<br>多元判断时：将condition拼接成字符串存到Map里<br>多元判断时：将condition存为Object存到Map里<br>多元判断时：将condition写作正则存到Map里<br>至此，本文也将告一段落，愿你未来的人生里，不只是有if/else/switch。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript-复杂判断的更优雅写法\"><a href=\"#JavaScript-复杂判断的更优雅写法\" class=\"headerlink\" title=\"JavaScript 复杂判断的更优雅写法\"></a>JavaScript 复杂判断的更优雅写法</h1><p>转载在<a href=\"https://mp.weixin.qq.com/s/JkZZbWOesqWDVGkUh2lRvg\" target=\"_blank\" rel=\"noopener\">JavaScript 复杂判断的更优雅写法</a></p>\n<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2><p>我们编写js代码时经常遇到复杂逻辑判断的情况，通常大家可以用if/else或者switch来实现多个条件判断，但这样会有个问题，随着逻辑复杂度的增加，代码中的if/else/switch会变得越来越臃肿，越来越看不懂，那么如何更优雅的写判断逻辑，本文带你试一下。</p>\n<h2 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h2><p>先看一段代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\">     * 按钮点击事件</span><br><span class=\"line\">     * @param &#123;number&#125; status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消</span><br><span class=\"line\">     *&#x2F;const onButtonClick &#x3D; (status)&#x3D;&gt;&#123;</span><br><span class=\"line\">      if(status &#x3D;&#x3D; 1)&#123;</span><br><span class=\"line\">        sendLog(&#39;processing&#39;)</span><br><span class=\"line\">        jumpTo(&#39;IndexPage&#39;)</span><br><span class=\"line\">      &#125;elseif(status &#x3D;&#x3D; 2)&#123;</span><br><span class=\"line\">        sendLog(&#39;fail&#39;)</span><br><span class=\"line\">        jumpTo(&#39;FailPage&#39;)</span><br><span class=\"line\">      &#125;elseif(status &#x3D;&#x3D; 3)&#123;</span><br><span class=\"line\">        sendLog(&#39;fail&#39;)</span><br><span class=\"line\">        jumpTo(&#39;FailPage&#39;)</span><br><span class=\"line\">      &#125;elseif(status &#x3D;&#x3D; 4)&#123;</span><br><span class=\"line\">        sendLog(&#39;success&#39;)</span><br><span class=\"line\">        jumpTo(&#39;SuccessPage&#39;)</span><br><span class=\"line\">      &#125;elseif(status &#x3D;&#x3D; 5)&#123;</span><br><span class=\"line\">        sendLog(&#39;cancel&#39;)</span><br><span class=\"line\">        jumpTo(&#39;CancelPage&#39;)</span><br><span class=\"line\">      &#125;else &#123;</span><br><span class=\"line\">        sendLog(&#39;other&#39;)</span><br><span class=\"line\">        jumpTo(&#39;Index&#39;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过代码可以看到这个按钮的点击逻辑：根据不同活动状态做两件事情，发送日志埋点和跳转到对应页面，大家可以很轻易的提出这段代码的改写方案，switch出场：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\">     * 按钮点击事件</span><br><span class=\"line\">     * @param &#123;number&#125; status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消</span><br><span class=\"line\">     *&#x2F;const onButtonClick &#x3D; (status)&#x3D;&gt;&#123;</span><br><span class=\"line\">      switch (status)&#123;</span><br><span class=\"line\">        case1:</span><br><span class=\"line\">          sendLog(&#39;processing&#39;)</span><br><span class=\"line\">          jumpTo(&#39;IndexPage&#39;)</span><br><span class=\"line\">          breakcase2:</span><br><span class=\"line\">        case3:</span><br><span class=\"line\">          sendLog(&#39;fail&#39;)</span><br><span class=\"line\">          jumpTo(&#39;FailPage&#39;)</span><br><span class=\"line\">          breakcase4:</span><br><span class=\"line\">          sendLog(&#39;success&#39;)</span><br><span class=\"line\">          jumpTo(&#39;SuccessPage&#39;)</span><br><span class=\"line\">          breakcase5:</span><br><span class=\"line\">          sendLog(&#39;cancel&#39;)</span><br><span class=\"line\">          jumpTo(&#39;CancelPage&#39;)</span><br><span class=\"line\">          breakdefault:</span><br><span class=\"line\">          sendLog(&#39;other&#39;)</span><br><span class=\"line\">          jumpTo(&#39;Index&#39;)</span><br><span class=\"line\">          break</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<pre><code>嗯，这样看起来比if/else清晰多了，细心的同学也发现了小技巧，case 2和case 3逻辑一样的时候，可以省去执行语句和break，则case 2的情况自动执行case 3的逻辑。</code></pre><p>这时有同学会说，还有更简单的写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const actions &#x3D; &#123;</span><br><span class=\"line\">      &#39;1&#39;: [&#39;processing&#39;,&#39;IndexPage&#39;],</span><br><span class=\"line\">      &#39;2&#39;: [&#39;fail&#39;,&#39;FailPage&#39;],</span><br><span class=\"line\">      &#39;3&#39;: [&#39;fail&#39;,&#39;FailPage&#39;],</span><br><span class=\"line\">      &#39;4&#39;: [&#39;success&#39;,&#39;SuccessPage&#39;],</span><br><span class=\"line\">      &#39;5&#39;: [&#39;cancel&#39;,&#39;CancelPage&#39;],</span><br><span class=\"line\">      &#39;default&#39;: [&#39;other&#39;,&#39;Index&#39;],</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;**</span><br><span class=\"line\">     * 按钮点击事件</span><br><span class=\"line\">     * @param &#123;number&#125; status 活动状态：1开团进行中 2开团失败 3 商品售罄 4 开团成功 5 系统取消</span><br><span class=\"line\">     *&#x2F;const onButtonClick &#x3D; (status)&#x3D;&gt;&#123;</span><br><span class=\"line\">      let action &#x3D; actions[status] || actions[&#39;default&#39;],</span><br><span class=\"line\">          logName &#x3D; action[0],</span><br><span class=\"line\">          pageName &#x3D; action[1]</span><br><span class=\"line\">      sendLog(logName)</span><br><span class=\"line\">      jumpTo(pageName)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<pre><code>上面代码确实看起来更清爽了，这种方法的聪明之处在于：将判断条件作为对象的属性名，将处理逻辑作为对象的属性值，在按钮点击的时候，通过对象属性查找的方式来进行逻辑判断，这种写法特别适合一元条件判断的情况。</code></pre><p>是不是还有其他写法呢？有的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const actions &#x3D; newMap([</span><br><span class=\"line\">      [1, [&#39;processing&#39;,&#39;IndexPage&#39;]],</span><br><span class=\"line\">      [2, [&#39;fail&#39;,&#39;FailPage&#39;]],</span><br><span class=\"line\">      [3, [&#39;fail&#39;,&#39;FailPage&#39;]],</span><br><span class=\"line\">      [4, [&#39;success&#39;,&#39;SuccessPage&#39;]],</span><br><span class=\"line\">      [5, [&#39;cancel&#39;,&#39;CancelPage&#39;]],</span><br><span class=\"line\">      [&#39;default&#39;, [&#39;other&#39;,&#39;Index&#39;]]</span><br><span class=\"line\">    ])</span><br><span class=\"line\">    &#x2F;**</span><br><span class=\"line\">     * 按钮点击事件</span><br><span class=\"line\">     * @param &#123;number&#125; status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消</span><br><span class=\"line\">     *&#x2F;const onButtonClick &#x3D; (status)&#x3D;&gt;&#123;</span><br><span class=\"line\">      let action &#x3D; actions.get(status) || actions.get(&#39;default&#39;)</span><br><span class=\"line\">      sendLog(action[0])</span><br><span class=\"line\">      jumpTo(action[1])</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<pre><code>这样写用到了es6里的Map对象，是不是更爽了？Map对象和Object对象有什么区别呢？</code></pre><ol>\n<li>一个对象通常都有自己的原型，所以一个对象总有一个”prototype”键。</li>\n<li>一个对象的键只能是字符串或者Symbols，但一个Map的键可以是任意值。</li>\n<li>你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。<br>我们需要把问题升级一下，以前按钮点击时候只需要判断status，现在还需要判断用户的身份：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\">     * 按钮点击事件</span><br><span class=\"line\">     * @param &#123;number&#125; status 活动状态：1开团进行中 2开团失败 3 开团成功 4 商品售罄 5 有库存未开团</span><br><span class=\"line\">     * @param &#123;string&#125; identity 身份标识：guest客态 master主态</span><br><span class=\"line\">     *&#x2F;const onButtonClick &#x3D; (status,identity)&#x3D;&gt;&#123;</span><br><span class=\"line\">      if(identity &#x3D;&#x3D; &#39;guest&#39;)&#123;</span><br><span class=\"line\">        if(status &#x3D;&#x3D; 1)&#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;elseif(status &#x3D;&#x3D; 2)&#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;elseif(status &#x3D;&#x3D; 3)&#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;elseif(status &#x3D;&#x3D; 4)&#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;elseif(status &#x3D;&#x3D; 5)&#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;elseif(identity &#x3D;&#x3D; &#39;master&#39;) &#123;</span><br><span class=\"line\">        if(status &#x3D;&#x3D; 1)&#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;elseif(status &#x3D;&#x3D; 2)&#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;elseif(status &#x3D;&#x3D; 3)&#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;elseif(status &#x3D;&#x3D; 4)&#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;elseif(status &#x3D;&#x3D; 5)&#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">          &#x2F;&#x2F;do sth</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n原谅我不写每个判断里的具体逻辑了，因为代码太冗长了。</li>\n</ol>\n<p>原谅我又用了if/else，因为我看到很多人依然在用if/else写这种大段的逻辑判断。</p>\n<p>从上面的例子我们可以看到，当你的逻辑升级为二元判断时，你的判断量会加倍，你的代码量也会加倍，这时怎么写更清爽呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const actions &#x3D; newMap([</span><br><span class=\"line\">      [&#39;guest_1&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">      [&#39;guest_2&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">      [&#39;guest_3&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">      [&#39;guest_4&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">      [&#39;guest_5&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">      [&#39;master_1&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">      [&#39;master_2&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">      [&#39;master_3&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">      [&#39;master_4&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">      [&#39;master_5&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">      [&#39;default&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">    ])</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;**</span><br><span class=\"line\">     * 按钮点击事件</span><br><span class=\"line\">     * @param &#123;string&#125; identity 身份标识：guest客态 master主态</span><br><span class=\"line\">     * @param &#123;number&#125; status 活动状态：1 开团进行中 2 开团失败 3 开团成功 4 商品售罄 5 有库存未开团</span><br><span class=\"line\">     *&#x2F;const onButtonClick &#x3D; (identity,status)&#x3D;&gt;&#123;</span><br><span class=\"line\">      let action &#x3D; actions.get(&#96;$&#123;identity&#125;_$&#123;status&#125;&#96;) || actions.get(&#39;default&#39;)</span><br><span class=\"line\">      action.call(this)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码核心逻辑是：把两个条件拼接成字符串，并通过以条件拼接字符串作为键，以处理函数作为值的Map对象进行查找并执行，这种写法在多元条件判断时候尤其好用。</p>\n<p>当然上述代码如果用Object对象来实现也是类似的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const actions &#x3D; &#123;</span><br><span class=\"line\">      &#39;guest_1&#39;:()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;,</span><br><span class=\"line\">      &#39;guest_2&#39;:()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;,</span><br><span class=\"line\">      &#x2F;&#x2F;....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    const onButtonClick &#x3D; (identity,status)&#x3D;&gt;&#123;</span><br><span class=\"line\">      let action &#x3D; actions[&#96;$&#123;identity&#125;_$&#123;status&#125;&#96;] || actions[&#39;default&#39;]</span><br><span class=\"line\">      action.call(this)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>如果有些同学觉得把查询条件拼成字符串有点别扭，那还有一种方案，就是用Map对象，以Object对象作为key：</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const actions &#x3D; newMap([</span><br><span class=\"line\">  [&#123;identity:&#39;guest&#39;,status:1&#125;,()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">  [&#123;identity:&#39;guest&#39;,status:2&#125;,()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class=\"line\">  &#x2F;&#x2F;...</span><br><span class=\"line\">])</span><br><span class=\"line\"></span><br><span class=\"line\">const onButtonClick &#x3D; (identity,status)&#x3D;&gt;&#123;</span><br><span class=\"line\">  let action &#x3D; [...actions].filter(([key,value])&#x3D;&gt;(key.identity &#x3D;&#x3D; identity &amp;&amp; key.status &#x3D;&#x3D; status))</span><br><span class=\"line\">  action.forEach(([key,value])&#x3D;&gt;value.call(this))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>是不是又高级了一点点？</p>\n<p>这里也看出来Map与Object的区别，Map可以用任何类型的数据作为key。</p>\n<p>我们现在再将难度升级一点点，假如guest情况下，status1-4的处理逻辑都一样怎么办，最差的情况是这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const actions &#x3D; newMap([</span><br><span class=\"line\">      [&#123;identity:&#39;guest&#39;,status:1&#125;,()&#x3D;&gt;&#123;&#x2F;* functionA *&#x2F;&#125;],</span><br><span class=\"line\">      [&#123;identity:&#39;guest&#39;,status:2&#125;,()&#x3D;&gt;&#123;&#x2F;* functionA *&#x2F;&#125;],</span><br><span class=\"line\">      [&#123;identity:&#39;guest&#39;,status:3&#125;,()&#x3D;&gt;&#123;&#x2F;* functionA *&#x2F;&#125;],</span><br><span class=\"line\">      [&#123;identity:&#39;guest&#39;,status:4&#125;,()&#x3D;&gt;&#123;&#x2F;* functionA *&#x2F;&#125;],</span><br><span class=\"line\">      [&#123;identity:&#39;guest&#39;,status:5&#125;,()&#x3D;&gt;&#123;&#x2F;* functionB *&#x2F;&#125;],</span><br><span class=\"line\">      &#x2F;&#x2F;...</span><br><span class=\"line\">    ])</span><br></pre></td></tr></table></figure>\n<p>好一点的写法是将处理逻辑函数进行缓存：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const actions &#x3D; ()&#x3D;&gt;&#123;</span><br><span class=\"line\">      const functionA &#x3D; ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;</span><br><span class=\"line\">      const functionB &#x3D; ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;</span><br><span class=\"line\">      returnnewMap([</span><br><span class=\"line\">        [&#123;identity:&#39;guest&#39;,status:1&#125;,functionA],</span><br><span class=\"line\">        [&#123;identity:&#39;guest&#39;,status:2&#125;,functionA],</span><br><span class=\"line\">        [&#123;identity:&#39;guest&#39;,status:3&#125;,functionA],</span><br><span class=\"line\">        [&#123;identity:&#39;guest&#39;,status:4&#125;,functionA],</span><br><span class=\"line\">        [&#123;identity:&#39;guest&#39;,status:5&#125;,functionB],</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">      ])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    const onButtonClick &#x3D; (identity,status)&#x3D;&gt;&#123;</span><br><span class=\"line\">      let action &#x3D; [...actions()].filter(([key,value])&#x3D;&gt;(key.identity &#x3D;&#x3D; identity &amp;&amp; key.status &#x3D;&#x3D; status))</span><br><span class=\"line\">      action.forEach(([key,value])&#x3D;&gt;value.call(this))</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这样写已经能满足日常需求了，但认真一点讲，上面重写了4次functionA还是有点不爽，假如判断条件变得特别复杂，比如identity有3种状态，status有10种状态，那你需要定义30条处理逻辑，而往往这些逻辑里面很多都是相同的，这似乎也是笔者不想接受的，那可以这样实现:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const actions &#x3D; ()&#x3D;&gt;&#123;</span><br><span class=\"line\">      const functionA &#x3D; ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;</span><br><span class=\"line\">      const functionB &#x3D; ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;</span><br><span class=\"line\">      returnnewMap([</span><br><span class=\"line\">        [&#x2F;^guest_[1-4]$&#x2F;,functionA],</span><br><span class=\"line\">        [&#x2F;^guest_5$&#x2F;,functionB],</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">      ])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    const onButtonClick &#x3D; (identity,status)&#x3D;&gt;&#123;</span><br><span class=\"line\">      let action &#x3D; [...actions()].filter(([key,value])&#x3D;&gt;(key.test(&#96;$&#123;identity&#125;_$&#123;status&#125;&#96;)))</span><br><span class=\"line\">      action.forEach(([key,value])&#x3D;&gt;value.call(this))</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这里Map的优势更加凸显，可以用正则类型作为key了，这样就有了无限可能，假如需求变成，凡是guest情况都要发送一个日志埋点，不同status情况也需要单独的逻辑处理，那我们可以这样写:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const actions &#x3D; ()&#x3D;&gt;&#123;</span><br><span class=\"line\">      const functionA &#x3D; ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;</span><br><span class=\"line\">      const functionB &#x3D; ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;</span><br><span class=\"line\">      const functionC &#x3D; ()&#x3D;&gt;&#123;&#x2F;*send log*&#x2F;&#125;</span><br><span class=\"line\">      returnnewMap([</span><br><span class=\"line\">        [&#x2F;^guest_[1-4]$&#x2F;,functionA],</span><br><span class=\"line\">        [&#x2F;^guest_5$&#x2F;,functionB],</span><br><span class=\"line\">        [&#x2F;^guest_.*$&#x2F;,functionC],</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">      ])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    const onButtonClick &#x3D; (identity,status)&#x3D;&gt;&#123;</span><br><span class=\"line\">      let action &#x3D; [...actions()].filter(([key,value])&#x3D;&gt;(key.test(&#96;$&#123;identity&#125;_$&#123;status&#125;&#96;)))</span><br><span class=\"line\">      action.forEach(([key,value])&#x3D;&gt;value.call(this))</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说利用数组循环的特性，符合正则条件的逻辑都会被执行，那就可以同时执行公共逻辑和单独逻辑，因为正则的存在，你可以打开想象力解锁更多的玩法，本文就不赘述了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文已经教你了8种逻辑判断写法，包括：</p>\n<p>if/else<br>switch<br>一元判断时：存到Object里<br>一元判断时：存到Map里<br>多元判断时：将condition拼接成字符串存到Object里<br>多元判断时：将condition拼接成字符串存到Map里<br>多元判断时：将condition存为Object存到Map里<br>多元判断时：将condition写作正则存到Map里<br>至此，本文也将告一段落，愿你未来的人生里，不只是有if/else/switch。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}