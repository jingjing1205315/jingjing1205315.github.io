<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Javascript 加载方式async与defer的区别</title>
      <link href="/2021/10/09/Javascript-%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8Fasync%E4%B8%8Edefer%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/10/09/Javascript-%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8Fasync%E4%B8%8Edefer%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<blockquote class="pullquote mindmap mindmap-md"><ul><li><a href="https://hunterx.xyz/use-mindmap-in-hexo.html" target="_blank" rel="noopener">在 Hexo 中使用思维导图</a><ul><li>前言</li><li>操作指南<ul><li>准备需要的文件</li><li>为主题添加 CSS/JS 文件</li></ul></li><li>使用方法</li></ul></li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt;|a&#x3D;1| D[结果1]</span><br><span class="line">    C --&gt;|a&#x3D;2| E[结果2]</span><br><span class="line">    F[横向流程图]</span><br></pre></td></tr></table></figure><p>11<br>mermaid<br>graph LR<br>A[方形] –&gt;B(圆角)<br>    B –&gt; C{条件a}<br>    C –&gt;|a=1| D[结果1]<br>    C –&gt;|a=2| E[结果2]<br>    F[横向流程图]</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>长按不选中</title>
      <link href="/2021/08/12/%E9%95%BF%E6%8C%89%E4%B8%8D%E9%80%89%E4%B8%AD/"/>
      <url>/2021/08/12/%E9%95%BF%E6%8C%89%E4%B8%8D%E9%80%89%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    -webkit-touch-callout:none; </span><br><span class="line">    -webkit-user-select:none; </span><br><span class="line">    -moz-user-select:none; </span><br><span class="line">    -ms-user-select:none; </span><br><span class="line">    user-select:none; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue vue-router vuex</title>
      <link href="/2021/08/10/vue-vue-router-vuex/"/>
      <url>/2021/08/10/vue-vue-router-vuex/</url>
      
        <content type="html"><![CDATA[<h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h3 id="父子组件的生命周期"><a href="#父子组件的生命周期" class="headerlink" title="父子组件的生命周期"></a>父子组件的生命周期</h3><h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><p>父 beforeCreated<br>父 created<br>父 beforeMounted<br>子 beforeCreated<br>子 created<br>子 beforeMounted<br>子 mounted<br>父 mounted</p><h4 id="子更新"><a href="#子更新" class="headerlink" title="子更新"></a>子更新</h4><p>父 beforeUpdate<br>子 beforeUpdate<br>子 updated<br>父 updated</p><h4 id="父更新"><a href="#父更新" class="headerlink" title="父更新"></a>父更新</h4><p>父 beforeupdate<br>父 updated</p><h4 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h4><p>父 beforeDestroy<br>子 beforeDestroy<br>子 destroyed<br>父 destroyed</p><p><strong>子组件必须是同步组件，否则子组件生命周期都在父组件之后</strong></p><h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><h3 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h3><ol><li>导航被触发。</li><li>在失活的组件里调用 beforeRouteLeave 守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>正则学习</title>
      <link href="/2021/04/12/%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/04/12/%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="分割多个匹配的字段"><a href="#分割多个匹配的字段" class="headerlink" title="| 分割多个匹配的字段"></a>| 分割多个匹配的字段</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D;&quot;transform(&#39;1.25 发布&#39;)&quot;</span><br><span class="line">let replaceStr&#x3D; str.replace(&#x2F;(^transform\([\&#39;\&quot;]*)|&#x3D;g|&#x3D;|([\&quot;\&#39;]*\)$)&#x2F;g, (a) &#x3D;&gt; &#123;</span><br><span class="line">const info &#x3D; &#123;</span><br><span class="line">  &quot;transform(&#39;&quot;: &#39;&#39;,</span><br><span class="line">  &quot;&#39;)&quot;: &#39;&#39;,</span><br><span class="line">  &#39;&#x3D;&#39;: &#39;&lt;&#x2F;g&gt;&#39;,</span><br><span class="line">  &#39;&#x3D;g&#39;: &#39;&lt;g&gt;&#39;,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">return info[a]</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="原型继承，正则匹配替换、遍历获取json中的键和值"><a href="#原型继承，正则匹配替换、遍历获取json中的键和值" class="headerlink" title="原型继承，正则匹配替换、遍历获取json中的键和值"></a>原型继承，正则匹配替换、遍历获取json中的键和值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.render &#x3D; function(arr)&#123;</span><br><span class="line">var replaceKey &#x3D; [];</span><br><span class="line">var str &#x3D; [];</span><br><span class="line"></span><br><span class="line">for(var key in arr)&#123;</span><br><span class="line">   replaceKey.push(key);</span><br><span class="line">    str.push(arr[key]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var format &#x3D; this;</span><br><span class="line"></span><br><span class="line">for(var i&#x3D;0; i&lt;replaceKey.length;i++)&#123;</span><br><span class="line">    var reg &#x3D; new RegExp(&quot;\\$&#123;&quot; +replaceKey[i]+ &quot;&#125;&quot;, &quot;g&quot;);</span><br><span class="line">    format &#x3D; format.replace(reg,str[i]);</span><br><span class="line">    console.log(format);</span><br><span class="line">&#125;</span><br><span class="line">return format;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var greeting &#x3D; &#39;my name is $&#123;name&#125;, age $&#123;age&#125;&#39;;</span><br><span class="line">var result &#x3D; greeting.render(&#123;&#39;name&#39;:&#39;jack&#39;,&#39;age&#39;:16&#125;);</span><br><span class="line">&#x2F;&#x2F; my name is jack, age $&#123;age&#125;</span><br><span class="line">&#x2F;&#x2F; my name is jack, age 16</span><br></pre></td></tr></table></figure><p><strong>平时写正则是/${name}/就好，但是在new RegExp()不行，因为它的第一个参数是字符串，\在字符串中需要转义为\，所以需要双重转义符\.</strong></p><h3 id="校验手机号"><a href="#校验手机号" class="headerlink" title="校验手机号"></a>校验手机号</h3><h3 id="校验邮箱"><a href="#校验邮箱" class="headerlink" title="校验邮箱"></a>校验邮箱</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$</span><br></pre></td></tr></table></figure><p><strong>\w匹配的仅仅是中文，数字，字母和_</strong><br><strong>匹配中文字符的正则表达式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[\u4e00-\u9fa5]</span><br></pre></td></tr></table></figure><p><strong>匹配双字节字符(包括汉字在内)：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^\x00-\xff]</span><br></pre></td></tr></table></figure><p><strong>匹配中文，英文字母和数字及_:^[\u4e00-\u9fa5_a-zA-Z0-9]+$</strong></p><p>1、一个正则表达式，只含有汉字、数字、字母、下划线不能以下划线开头和结尾：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(?!_)(?!.*?_$)[a-zA-Z0-9_\u4e00-\u9fa5]+$</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Array方法对比</title>
      <link href="/2021/04/12/Array%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94/"/>
      <url>/2021/04/12/Array%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<p>各方法的区别，什么情况下用哪个方法比较好</p><p>*因为map生成一个新数组，当你不打算使用返回的新数组却使用map是违背设计初衷的，请用forEach或者for-of替代。你不该使用map: A)你不打算使用返回的新数组，或/且 B) 你没有从回调函数中返回值。</p><p>——由此总结：</p><p>1）需要返回索引，用indexOf ，findIndex() 方法，能用前者不用后者；</p><p>2）需要返回布尔，用includes(), some(), every()；</p><p>3)  需要返回新数组，只要一个符合条件的新数组用find(),  要多个符合条件的新数组用filter(), 包含所有元素运算出来的新数组用map()；</p><p>4）需要循环所有元素，用forEach()</p><p>5)  需要循环部分，用for，符合条件，跳出</p><a id="more"></a><hr><h3 id="1、for-循环-（for…in-for…of）"><a href="#1、for-循环-（for…in-for…of）" class="headerlink" title="1、for 循环 （for…in  for…of）"></a>1、for 循环 （for…in  for…of）</h3><p>1)  in结果是key， of结果是value</p><p>2）in 不保证顺序</p><p>3）in 是可枚举属性<br>4)  in 可以是对象</p><h3 id="2、forEach-amp-map-——没有办法中止或跳出-forEach-循环"><a href="#2、forEach-amp-map-——没有办法中止或跳出-forEach-循环" class="headerlink" title="2、forEach() &amp; map() ——没有办法中止或跳出 forEach() 循环"></a>2、forEach() &amp; map() ——没有办法中止或跳出 forEach() 循环</h3><p>forEach() 方法对数组的每个元素执行一次提供的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(callback(currentValue [, index [, array]])[, thisArg]);</span><br><span class="line"></span><br><span class="line">const array1 &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];</span><br><span class="line"></span><br><span class="line">array1.forEach(element &#x3D;&gt; console.log(element));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; expected output: &quot;a&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; expected output: &quot;b&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; expected output: “c&quot;</span><br></pre></td></tr></table></figure><p>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var new_array &#x3D; arr.map(function callback(currentValue[, index[, array]]) &#123;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; Return element for new_array </span><br><span class="line"></span><br><span class="line">&#125;[, thisArg])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const array1 &#x3D; [1, 4, 9, 16];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; pass a function to map</span><br><span class="line"></span><br><span class="line">const map1 &#x3D; array1.map(x &#x3D;&gt; x * 2);</span><br><span class="line"></span><br><span class="line">console.log(map1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; expected output: Array [2, 8, 18, 32]</span><br></pre></td></tr></table></figure><p>3、every() &amp; some() &amp; find() &amp;filter() —满足条件将不再循环</p><p><strong>every()</strong> 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">arr.every(callback[, thisArg])</span><br><span class="line"></span><br><span class="line">const isBelowThreshold &#x3D; (currentValue) &#x3D;&gt; currentValue &lt; 40;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const array1 &#x3D; [1, 30, 39, 29, 10, 13];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(array1.every(isBelowThreshold));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; expected output: true</span><br></pre></td></tr></table></figure><p><strong>some()</strong> 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arr.some(callback(element[, index[, array]])[, thisArg])</span><br><span class="line"></span><br><span class="line">const array &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; checks whether an element is even</span><br><span class="line"></span><br><span class="line">const even &#x3D; (element) &#x3D;&gt; element % 2 &#x3D;&#x3D;&#x3D; 0;</span><br><span class="line"></span><br><span class="line">console.log(array.some(even));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; expected output: true</span><br></pre></td></tr></table></figure><p><strong>find()</strong> 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">arr.find(callback[, thisArg])</span><br><span class="line"></span><br><span class="line">const array1 &#x3D; [5, 12, 8, 130, 44];</span><br><span class="line"></span><br><span class="line">const found &#x3D; array1.find(element &#x3D;&gt; element &gt; 10);</span><br><span class="line"></span><br><span class="line">console.log(found);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; expected output: 12</span><br></pre></td></tr></table></figure><p><strong>filter()</strong> 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var newArray &#x3D; arr.filter(callback(element[, index[, array]])[, thisArg])</span><br><span class="line"></span><br><span class="line">const words &#x3D; [&#39;spray&#39;, &#39;limit&#39;, &#39;elite&#39;, &#39;exuberant&#39;, &#39;destruction&#39;, &#39;present&#39;];</span><br><span class="line"></span><br><span class="line">const result &#x3D; words.filter(word &#x3D;&gt; word.length &gt; 6);</span><br><span class="line"></span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]</span><br></pre></td></tr></table></figure><h3 id="4、indexOf-amp-findIndex-amp-includes-amp-find"><a href="#4、indexOf-amp-findIndex-amp-includes-amp-find" class="headerlink" title="4、indexOf() &amp; findIndex() &amp; includes() &amp; find()"></a>4、indexOf() &amp; findIndex() &amp; includes() &amp; find()</h3><p><strong>findIndex()</strong>方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">arr.findIndex(callback[, thisArg])</span><br><span class="line"></span><br><span class="line">const array1 &#x3D; [5, 12, 8, 130, 44];</span><br><span class="line"></span><br><span class="line">const isLargeNumber &#x3D; (element) &#x3D;&gt; element &gt; 13;</span><br><span class="line"></span><br><span class="line">console.log(array1.findIndex(isLargeNumber));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; expected output: 3</span><br></pre></td></tr></table></figure><p><strong>includes()</strong> 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">arr.includes(valueToFind[, fromIndex])</span><br><span class="line"></span><br><span class="line">const array1 &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(array1.includes(2));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; expected output: true</span><br></pre></td></tr></table></figure><p><strong>indexOf()</strong>方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr.indexOf(searchElement[, fromIndex])</span><br><span class="line"></span><br><span class="line">var array &#x3D; [2, 5, 9];</span><br><span class="line"></span><br><span class="line">array.indexOf(2);     &#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">array.indexOf(7);     &#x2F;&#x2F; -1</span><br></pre></td></tr></table></figure><p>举例：</p><p>增信中有includes</p><p>春节活动有find</p><p>小明的年级排名</p><p>字符串实例方法：padStart()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1 +&#39;&#39;).padStart(2, ‘0’) &#x2F;&#x2F; “01”</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#39;12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) &#x2F;&#x2F; &quot;YYYY-MM-12&quot;</span><br><span class="line"></span><br><span class="line">&#39;09-12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) &#x2F;&#x2F; &quot;YYYY-09-12&quot;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sql查询</title>
      <link href="/2021/03/11/sql%E6%9F%A5%E8%AF%A2/"/>
      <url>/2021/03/11/sql%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<p>作为前端，可能认为数据层是后端的需要处理的事情。但现在是大数据时代，往往需要我们在页面中埋点来记录分析用户行为。我们如何检验我们的埋点是否埋上、埋对，就需要我们具有基础数据查询能力。</p><a id="more"></a><p>###基础查询<br>select 列名,列名,列名,列名,列名<br>from 表名<br>where 条件<br>and 条件<br>or 条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select date, user_id, distinct_id </span><br><span class="line">from</span><br><span class="line">events</span><br><span class="line">where date &gt;&#x3D; &#39;2021-03-01&#39;</span><br><span class="line">and event&#x3D;&#39;H5PageView&#39;</span><br><span class="line">and filename&#x3D;&#39;H5_WA_PaymentSuccess&#39;</span><br></pre></td></tr></table></figure><h3 id="limit-条数"><a href="#limit-条数" class="headerlink" title="limit 条数"></a>limit 条数</h3><p>假如不限制条数，查询的数据特别多的话，会非常慢，limit来限制返回多少条符合结果的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select date, user_id, distinct_id,project_uuid</span><br><span class="line">from</span><br><span class="line">events</span><br><span class="line">where date &gt;&#x3D; &#39;2021-03-01&#39;</span><br><span class="line">and event&#x3D;&#39;H5PageView&#39;</span><br><span class="line">and filename&#x3D;&#39;H5_WA_PaymentSuccess&#39;</span><br><span class="line">limit 10</span><br></pre></td></tr></table></figure><h3 id="group-by-列名"><a href="#group-by-列名" class="headerlink" title="group by 列名"></a>group by 列名</h3><p>将查询结果按**(列名)分组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select date</span><br><span class="line">from</span><br><span class="line">events</span><br><span class="line">where date &gt;&#x3D; &#39;2021-03-01&#39;</span><br><span class="line">and event&#x3D;&#39;H5PageView&#39;</span><br><span class="line">and filename&#x3D;&#39;H5_WA_PaymentSuccess&#39;</span><br><span class="line">group by date</span><br></pre></td></tr></table></figure><h3 id="distinct-列名"><a href="#distinct-列名" class="headerlink" title="distinct 列名"></a>distinct 列名</h3><p>根据列名去重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select date, distinct user_id</span><br><span class="line">from</span><br><span class="line">events</span><br><span class="line">where date &gt;&#x3D; &#39;2021-03-01&#39;</span><br><span class="line">and event&#x3D;&#39;H5PageView&#39;</span><br><span class="line">and filename&#x3D;&#39;H5_WA_PaymentSuccess&#39;</span><br><span class="line">group by date</span><br></pre></td></tr></table></figure><h3 id="as-列名-as-自己起的名字"><a href="#as-列名-as-自己起的名字" class="headerlink" title="as (列名 as 自己起的名字)"></a>as (列名 as 自己起的名字)</h3><p>为列名起个别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select date as &#39;日期&#39;, distinct user_id</span><br><span class="line">from</span><br><span class="line">events</span><br><span class="line">where date &gt;&#x3D; &#39;2021-03-01&#39;</span><br><span class="line">and event&#x3D;&#39;H5PageView&#39;</span><br><span class="line">and filename&#x3D;&#39;H5_WA_PaymentSuccess&#39;</span><br><span class="line">group by date</span><br></pre></td></tr></table></figure><h3 id="order-by-列名"><a href="#order-by-列名" class="headerlink" title="order by 列名"></a>order by 列名</h3><p>根据日期这一列来排序，可选择升序asc，和降序desc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select date as &#39;日期&#39;, distinct user_id</span><br><span class="line">from</span><br><span class="line">events</span><br><span class="line">where date &gt;&#x3D; &#39;2021-03-01&#39;</span><br><span class="line">and event&#x3D;&#39;H5PageView&#39;</span><br><span class="line">and filename&#x3D;&#39;H5_WA_PaymentSuccess&#39;</span><br><span class="line">order by date desc</span><br></pre></td></tr></table></figure><h3 id="count-列名"><a href="#count-列名" class="headerlink" title="count(列名)"></a>count(列名)</h3><p>根据列名统计总数，也可以用count(*)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select date as &#39;日期&#39;, count(distinct user_id)</span><br><span class="line">from</span><br><span class="line">events</span><br><span class="line">where date &gt;&#x3D; &#39;2021-03-01&#39;</span><br><span class="line">and event&#x3D;&#39;H5PageView&#39;</span><br><span class="line">and filename&#x3D;&#39;H5_WA_PaymentSuccess&#39;</span><br><span class="line">group by date desc</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>不同的数据库支持的函数不同。下面所用函数为<a href="https://impala.apache.org/docs/build/html/topics/impala_functions.html" target="_blank" rel="noopener">impala提供</a></p><p>Impala Mathematical Functions–数学方法<br>Impala Type Conversion Functions–转换方法<br>Impala Date and Time Functions–日期和事件方法<br>Impala Conditional Functions–条件方法<br>Impala String Functions–字符串方法<br>Impala Aggregate Functions–聚合方法<br>Impala Analytic Functions–分析方法<br>Impala Bit Functions–二进制方法<br>Impala Miscellaneous Functions–混杂方法</p><p>如下<br>cast( <strong>* as DECIMAL(9,8)) 将*</strong>转换为数字，精度为9，小数位为8</p><p>GET_JSON_OBJECT(字符串形式的json, ‘$.key值’) 将字符串形式的json转换为json，并取json中的这个key值。</p><p>replace(原始字符串, ‘要被替换的字符串’, ‘替换的字符串’) 替换字符串</p><p>parse_url(原始url, ‘QUERY’) –第二个参数可选值’PROTOCOL’, ‘HOST’, ‘PATH’, ‘REF’, ‘AUTHORITY’, ‘FILE’, ‘USERINFO’, or ‘QUERY’<br>第二个参数是’QUERY’，还可以有第三个参数parse_url(原始url, ‘QUERY’, ‘url参数的key’)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select date,</span><br><span class="line"> cast(GET_JSON_OBJECT(REPLACE(ExtraInfo, &#39;\\&#39;, &#39;&#39;),&#39;$.qscrnd&#39;) as DECIMAL(9,8)) as qscrnd ,</span><br><span class="line"> parse_url(origin_url, &#39;QUERY&#39;, &#39;projuuid&#39;) as project_uuid </span><br><span class="line">from</span><br><span class="line">events</span><br><span class="line">where date &gt;&#x3D; &#39;2021-03-01&#39;</span><br><span class="line">and event&#x3D;&#39;H5PageView&#39;</span><br><span class="line">and filename&#x3D;&#39;H5_WA_PaymentSuccess&#39;</span><br><span class="line">order by date</span><br></pre></td></tr></table></figure><h3 id="主表-join-副表-on-以-提交件"><a href="#主表-join-副表-on-以-提交件" class="headerlink" title="主表 join 副表 on 以**提交件"></a>主表 join 副表 on 以**提交件</h3><p>结合两张表来查询，也可以结合两个查询结果来查询。</p><h3 id="case-when-条件-then-输出-end"><a href="#case-when-条件-then-输出-end" class="headerlink" title="case when 条件 then 输出 end"></a>case when 条件 then 输出 end</h3><p>整合条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">select pv.date,</span><br><span class="line">case </span><br><span class="line">   when pv.qscrnd &lt; 0.5 </span><br><span class="line">   then &#39;&lt;0.5&#39;</span><br><span class="line">   when pv.qscrnd &gt;&#x3D; 0.5 </span><br><span class="line">   then &#39;&gt;0.5&#39;</span><br><span class="line">end as qscrnd,</span><br><span class="line"></span><br><span class="line">count(*) as pv, </span><br><span class="line">count(distinct pv.user_id) as uv</span><br><span class="line"></span><br><span class="line">from (</span><br><span class="line">    select date, user_id, distinct_id,project_uuid,</span><br><span class="line">      cast(GET_JSON_OBJECT(REPLACE(ExtraInfo, &#39;\\&#39;, &#39;&#39;),&#39;$.qscrnd&#39;) as DECIMAL(9,8)) as qscrnd </span><br><span class="line">    from</span><br><span class="line">    events</span><br><span class="line">    where date &gt;&#x3D; &#39;2021-03-01&#39;</span><br><span class="line">    and event&#x3D;&#39;H5PageView&#39;</span><br><span class="line">    and filename&#x3D;&#39;H5_WA_PaymentSuccess&#39;</span><br><span class="line">    --and filevalue&#x3D;&#39;H5_WA_PaymentSuccess&#39;</span><br><span class="line">  ) pv </span><br><span class="line">  </span><br><span class="line">  join (</span><br><span class="line">    select user_id, distinct_id,project_uuid</span><br><span class="line">    from</span><br><span class="line">    events</span><br><span class="line">    where date &gt;&#x3D; &#39;2021-03-01&#39;</span><br><span class="line">    and event &#x3D; &#39;FileClick&#39;</span><br><span class="line">    and filename&#x3D;&#39;Button_RedPocket&#39;</span><br><span class="line">    and filevalue&#x3D;&#39;H5_WA_PaymentSuccess&#39;</span><br><span class="line">  ) click</span><br><span class="line">  on pv.user_id &#x3D; click.user_id</span><br><span class="line">  --and pv.project_uuid &#x3D; click.project_uuid</span><br><span class="line"></span><br><span class="line">group by date, qscrnd</span><br><span class="line">order by date desc</span><br></pre></td></tr></table></figure><img style="margin: 0" src="/2021/03/11/sql%E6%9F%A5%E8%AF%A2/1615456235396.jpg"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网页性能优化</title>
      <link href="/2021/03/01/%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-1/"/>
      <url>/2021/03/01/%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-1/</url>
      
        <content type="html"><![CDATA[<p>一次性能优化实战经验总结</p><a id="more"></a><h3 id="关键节点数据采集"><a href="#关键节点数据采集" class="headerlink" title="关键节点数据采集"></a>关键节点数据采集</h3><p>如html加载完成时间点、js加载完成时间点、接口请求时间点、首屏渲染时间点</p><p>测试了请求6个并行接口和请求一个合并接口的时间，大致相同。400ms左右。后端检测到他们的时间是几十ms。优化意义不大。</p><p>因此，这次优化工作的重点放在前端。</p><h3 id="将首屏串行接口请求全部改为并行请求。"><a href="#将首屏串行接口请求全部改为并行请求。" class="headerlink" title="将首屏串行接口请求全部改为并行请求。"></a>将首屏串行接口请求全部改为并行请求。</h3><p>若依赖前一接口的返回，则和后端沟通是否合并接口。</p><h3 id="对需要登录的页面，去掉页面最开始是否登录的接口请求。"><a href="#对需要登录的页面，去掉页面最开始是否登录的接口请求。" class="headerlink" title="对需要登录的页面，去掉页面最开始是否登录的接口请求。"></a>对需要登录的页面，去掉页面最开始是否登录的接口请求。</h3><p>在请求首页页面数据接口时，会知道用户是否登录，如页面需强制登录，则根据某一字段判断是否跳转登录。这样，就减少了一个串行接口，大约减时400ms。</p><p>接下来是页面级的优化：</p><h3 id="首屏组件及任何父组件都应为同步加载"><a href="#首屏组件及任何父组件都应为同步加载" class="headerlink" title="首屏组件及任何父组件都应为同步加载"></a>首屏组件及任何父组件都应为同步加载</h3><p>对vue开发的网站，会先加载html，再加载html里引入的app.js，js中的代码去渲染页面，首屏代码不用同步方式加载的话，app.js下载完成，还需要串行去加载渲染首屏的的js。时间就被浪费掉了。</p><p>然后发现，app.js太大了，于是决定对js进行拆包。</p><h3 id="最大化利用浏览器并行请求数对首屏拆包，减小包的大小。用webpack-bundle-analyzer分析哪些可拆"><a href="#最大化利用浏览器并行请求数对首屏拆包，减小包的大小。用webpack-bundle-analyzer分析哪些可拆" class="headerlink" title="最大化利用浏览器并行请求数对首屏拆包，减小包的大小。用webpack-bundle-analyzer分析哪些可拆"></a>最大化利用浏览器并行请求数对首屏拆包，减小包的大小。用webpack-bundle-analyzer分析哪些可拆</h3><p>以chrome为例：同域名下最大并行请求数为6个。注意看有没有同域下的css、img占用资源数是否影响js的并行。</p><p>拆完包，发现首屏渲染速度反而变慢了……</p><h3 id="首屏同步加载部分组件"><a href="#首屏同步加载部分组件" class="headerlink" title="首屏同步加载部分组件"></a>首屏同步加载部分组件</h3><p>分析变慢的原因是整体包的大小，比未拆包前稍微大一点，而带宽资源有限。于是想首屏只加载部分组件，将整体包大小减小了1/3,上线后首屏渲染速度明显大幅提升</p><p> <strong>放在head中的js文件比body中的js文件加载优先级高</strong></p><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>prefetch 预加载其它页面所需的资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import(</span><br><span class="line">  &#96;.&#x2F;utilities&#x2F;divide&#96;</span><br><span class="line">  &#x2F;* webpackPrefetch: true *&#x2F;</span><br><span class="line">  &#x2F;* webpackChunkName: &quot;utilities&quot; *&#x2F;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>以上的导入会让<link rel="prefetch" as="script" href="utilities.js">被添加至页面的头部。因此浏览器会在空闲时间预先拉取该文件。</p><p>异步chunk会和父级chunk并行加载(webpack4.46并未实验成功)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* webpackPreload: true *&#x2F;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.cnblogs.com/powertoolsteam/p/10873677.html" target="_blank" rel="noopener">Webpack 4教程 - 第八部分 使用prefetch和preload进行动态加载</a></p><h3 id="去掉ajax的mothed为option的请求"><a href="#去掉ajax的mothed为option的请求" class="headerlink" title="去掉ajax的mothed为option的请求"></a>去掉ajax的mothed为option的请求</h3><p>由于浏览器的同源策略，非简单请求会发送option进行预检。猜测预检请求会影响加载速度，待验证</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.cnblogs.com/cczlovexw/p/11754301.html" target="_blank" rel="noopener">页面加载性能优化</a><br><a href="https://blog.csdn.net/haha223545/article/details/79675304" target="_blank" rel="noopener">H5首屏秒开方案探讨</a><br><a href="https://zhuanlan.zhihu.com/p/67098966" target="_blank" rel="noopener">页面性能优化办法有哪些？</a></p><p><a href="https://www.jianshu.com/p/cd7de34a759d" target="_blank" rel="noopener">Web性能优化-CSS和js的装载与执行</a></p><p><a href="https://blog.csdn.net/xiaoduanayu/article/details/78386508" target="_blank" rel="noopener">HTTP keep-alive详解</a><br><a href="https://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html" target="_blank" rel="noopener">HTTP头字段总结</a><br><a href="https://www.cnblogs.com/TankXiao/archive/2012/10/10/2711777.html" target="_blank" rel="noopener">Wireshark基本介绍和学习TCP三次握手</a></p><p><a href="https://www.cnblogs.com/ljx20180807/p/13543487.html" target="_blank" rel="noopener">前端常用性能优化方法</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>私有npm包创建及引用</title>
      <link href="/2021/01/29/%E7%A7%81%E6%9C%89npm%E5%8C%85%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%BC%95%E7%94%A8/"/>
      <url>/2021/01/29/%E7%A7%81%E6%9C%89npm%E5%8C%85%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>私有npm包创建和开发</p><a id="more"></a><h3 id="npm包创建"><a href="#npm包创建" class="headerlink" title="npm包创建"></a>npm包创建</h3><p>npm init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">This utility will walk you through creating a package.json file.</span><br><span class="line">It only covers the most common items, and tries to guess sensible defaults.</span><br><span class="line"></span><br><span class="line">See &#96;npm help json&#96; for definitive documentation on these fields</span><br><span class="line">and exactly what they do.</span><br><span class="line"></span><br><span class="line">Use &#96;npm install &lt;pkg&gt;&#96; afterwards to install a package and</span><br><span class="line">save it as a dependency in the package.json file.</span><br><span class="line"></span><br><span class="line">Press ^C at any time to quit.</span><br><span class="line">package name: (test)</span><br></pre></td></tr></table></figure><p>根据提示输入包名、版本、描述、入口文件、测试指令、keywords、author等，不需要更改的直接回车。</p><p>生成package.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;shareguidemask&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;a npm packege includes share guide mask&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;shareGuideMask&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;jing&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;vue&quot;: &quot;^2.6.12&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写好程序，在入口文件index.js export</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import vue from &#39;vue&#39;;</span><br><span class="line">import app from &#39;.&#x2F;src&#x2F;index.vue&#39;;</span><br><span class="line">export default app;</span><br></pre></td></tr></table></figure><h3 id="推到仓库"><a href="#推到仓库" class="headerlink" title="推到仓库"></a>推到仓库</h3><p>加入git版本控制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>提交到gitHub仓库做实验</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git ci -m &#39;massege&#39;</span><br></pre></td></tr></table></figure><p>添加远程仓库地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:jingjing1205315&#x2F;</span><br></pre></td></tr></table></figure><p>推到远程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="私有项目用npm包的方式引入"><a href="#私有项目用npm包的方式引入" class="headerlink" title="私有项目用npm包的方式引入"></a>私有项目用npm包的方式引入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;npm包名&gt; --registry&#x3D;&lt;npm包源&gt;</span><br></pre></td></tr></table></figure><h3 id="打包报错"><a href="#打包报错" class="headerlink" title="打包报错"></a>打包报错</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Vue warn]: You are using the runtime-only build of Vue where the template c</span><br></pre></td></tr></table></figure><p>因为vue包入口文件是runtime模式,这样引入的单文件组件就不能compiler，解决方式是webpack config中设置到compiler模式的vue别名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 省略...</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            &#39;vue&#39;: &#39;vue&#x2F;dist&#x2F;vue.js&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/wxl1555/article/details/83187647" target="_blank" rel="noopener">You are using the runtime-only build of Vue where the template compiler is not available. Either pre</a></p><p><a href="https://www.pianshen.com/article/4406262022/" target="_blank" rel="noopener">VUE问题：You are using the runtime-only build of Vue where the template compiler is not available.</a></p><h3 id="开发阶段修改私有npm包"><a href="#开发阶段修改私有npm包" class="headerlink" title="开发阶段修改私有npm包"></a>开发阶段修改私有npm包</h3><p>npm包修改，需要重新发版。项目中要安装相应的npm包版本，非常繁琐。找到了软连接的方式来做npm包修改的调试。</p><p>进入npm包的文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure><p>回到项目的文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link &lt;包名&gt;</span><br></pre></td></tr></table></figure><p>这时，修改npm包的内容，可以实时展现在项目中。调试起来很方便。</p><p><a href="https://www.jianshu.com/p/d0c887cf730e?utm_campaign" target="_blank" rel="noopener">npm 私有包依赖 本地开发调试频繁更新解决方案</a></p><h3 id="引入项目-No-ESLint-configuration-found报错"><a href="#引入项目-No-ESLint-configuration-found报错" class="headerlink" title="引入项目 No ESLint configuration found报错"></a>引入项目 No ESLint configuration found报错</h3><p> vue cli3解决办法 // vue.config.js添加如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  chainWebpack: config &#x3D;&gt; config.resolve.symlinks(false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack项目 webpack.config.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    symlinks: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_35261296/article/details/103990046" target="_blank" rel="noopener">webpack项目，link本地包出现No ESLint configuration found 问题解决</a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.cnblogs.com/cag2050/p/10724196.html" target="_blank" rel="noopener">如何安装私有 npm 包？</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git 命令</title>
      <link href="/2021/01/20/git-%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/01/20/git-%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>log,diff,reset,checkout</p><a id="more"></a><h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><p>查看暂存区中记录的冲突文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files -s</span><br></pre></td></tr></table></figure><p>日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">100644 ea9df2ef42c073de18bde4ebdf50e0ac6b1cdd2d 2 README.txt </span><br><span class="line">100644 633d2ed9d0ae01d0d07136c5b5bd857e4d945c14 3 README.txt </span><br><span class="line">100644 17874eaa4a398cc94ed294c93fdbf50f7f843d88 0 team&#x2F;user1.txt </span><br><span class="line">100644 2dcb7b6ac06d93ea8e6af21ded690f5e171a407c 0 team&#x2F;user2.txt</span><br></pre></td></tr></table></figure><p>编号为2表示暂存区用于保存冲突文件在当前分支中修改的副本，查看该文件的内容执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show :2:README.txt</span><br></pre></td></tr></table></figure><p>编号为3的为暂存区用于保存当前冲突文件在合并版本中修改的副本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show :3:README.txt</span><br></pre></td></tr></table></figure><p>最后看看工作区的README.txt文件的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat README.txt</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD&quot;</span><br><span class="line">Hello, user2.</span><br><span class="line">&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line">&quot;Hello, user1.&quot;</span><br><span class="line">“&gt;&gt;&gt;&gt;&gt;&gt;&gt; 04eed972e27e23a9874f984f08d6567e565d3436”</span><br></pre></td></tr></table></figure><p>手动解决这个冲突</p><p>选择我的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">todo</span><br></pre></td></tr></table></figure><p>选择他人的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">todo</span><br></pre></td></tr></table></figure><p>工作区和暂存区都干净时，都不要了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard FETCH_HEAD</span><br><span class="line">或</span><br><span class="line">git merge --abort</span><br></pre></td></tr></table></figure><p>git add -u -u参数表示把工作区被跟踪的文件添加到暂存区</p><p>编号都变成0，这样就说明已经成功解决了冲突。</p><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">commit 96f50451c6f24a221c58c58a8cae136858fed97e (HEAD -&gt; master)</span><br><span class="line">Author: April &lt;zhangyajing1205315@163.com&gt;</span><br><span class="line">Date:   Thu Jan 21 19:57:50 2021 +0800</span><br><span class="line"></span><br><span class="line">    change readme.md</span><br><span class="line"></span><br><span class="line">commit 347e5597bb222237bc4c61d87a232cfb5ab24916</span><br><span class="line">Author: April &lt;zhangyajing1205315@163.com&gt;</span><br><span class="line">Date:   Thu Jan 21 19:56:37 2021 +0800</span><br><span class="line"></span><br><span class="line">    add a readme.md</span><br><span class="line"></span><br><span class="line">commit 4d4ddfc6ca37c81b62a576bf47b47144cb63bd3e</span><br><span class="line">Author: April &lt;zhangyajing1205315@163.com&gt;</span><br><span class="line">Date:   Thu Jan 21 19:54:08 2021 +0800</span><br><span class="line"></span><br><span class="line">    init</span><br></pre></td></tr></table></figure><p>这时的git reflog 是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">96f5045 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: change readme.md</span><br><span class="line">347e559 HEAD@&#123;1&#125;: commit: add a readme.md</span><br><span class="line">4d4ddfc HEAD@&#123;2&#125;: commit (initial): init</span><br></pre></td></tr></table></figure><p>(第四条操作)在干净的工作区，git reset –hard 什么也不会发生</p><p>(第五条操作）回退一个版本 git reset –hard HEAD^ <strong>（log记录仅剩两条）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">commit 347e5597bb222237bc4c61d87a232cfb5ab24916 (HEAD -&gt; master)</span><br><span class="line">Author: April &lt;zhangyajing1205315@163.com&gt;</span><br><span class="line">Date:   Thu Jan 21 19:56:37 2021 +0800</span><br><span class="line"></span><br><span class="line">    add a readme.md</span><br><span class="line"></span><br><span class="line">commit 4d4ddfc6ca37c81b62a576bf47b47144cb63bd3e</span><br><span class="line">Author: April &lt;zhangyajing1205315@163.com&gt;</span><br><span class="line">Date:   Thu Jan 21 19:54:08 2021 +0800</span><br><span class="line"></span><br><span class="line">    init</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure><p>这时 git reflog 是这样<strong>(用来记录你的每一次命令，保留了所有的log)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">347e559 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">96f5045 HEAD@&#123;1&#125;: reset: moving to HEAD</span><br><span class="line">96f5045 HEAD@&#123;2&#125;: commit: change readme.md</span><br><span class="line">347e559 (HEAD -&gt; master) HEAD@&#123;3&#125;: commit: add a readme.md</span><br><span class="line">4d4ddfc HEAD@&#123;4&#125;: commit (initial): init</span><br></pre></td></tr></table></figure><h4 id="git-log-–pretty-oneline"><a href="#git-log-–pretty-oneline" class="headerlink" title="git log –pretty=oneline"></a>git log –pretty=oneline</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f571563b5593893b5daed871fc03575b32133046 (HEAD -&gt; learn_git_branch) Merge branch &#39;prelive&#39; of code.qschou.com:qschou&#x2F;h5_fund into prelive</span><br><span class="line">9d51a3471043a39203be9178cbafc98b0e70d71d Merge branch &#39;feature-73979557-zyj更换项目分享内容&#39; into prelive</span><br><span class="line">ebf3439722718482b1bf283d45cd4ac70c681392 Merge branch &#39;xc-baodai&#39; into prelive</span><br><span class="line">566971c7776e9b9c699a33b3ecb6f35f35b65e91 (origin&#x2F;xc-baodai) no message</span><br></pre></td></tr></table></figure><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>追踪当前<strong>修改</strong>内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">diff --git a&#x2F;source&#x2F;_posts&#x2F;Linux-Command.md b&#x2F;source&#x2F;_posts&#x2F;Linux-Command.md</span><br><span class="line">index b65319c..b53b18d 100644</span><br><span class="line">--- a&#x2F;source&#x2F;_posts&#x2F;Linux-Command.md</span><br><span class="line">+++ b&#x2F;source&#x2F;_posts&#x2F;Linux-Command.md</span><br><span class="line">@@ -9,7 +9,7 @@ tags:</span><br><span class="line"> print working directory</span><br><span class="line"> touch 文件名</span><br><span class="line"></span><br><span class="line">-</span><br><span class="line">+### mkdir 新建目录</span><br></pre></td></tr></table></figure><p> 新建的文件不会出现在这里。这时的git st 是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> On branch gh-pages</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;gh-pages&#39;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   &quot;source&#x2F;_posts&#x2F;git-\345\221\275\344\273\244.md&quot;</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   source&#x2F;_posts&#x2F;Linux-Command.md</span><br></pre></td></tr></table></figure><h3 id="git-reset-–hard-恢复文件为HEAD版本"><a href="#git-reset-–hard-恢复文件为HEAD版本" class="headerlink" title="git reset –hard 恢复文件为HEAD版本"></a>git reset –hard 恢复文件为HEAD版本</h3><p>可以恢复Changes not staged for commit中的文件。</p><p>这时<strong>git st</strong>的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n branch master</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;master&#39;.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        ..&#x2F;..&#x2F;..&#x2F;static&#x2F;project&#x2F;reward_rank&#x2F;css&#x2F;main_4b080aac.min.css</span><br><span class="line">        ..&#x2F;..&#x2F;..&#x2F;static&#x2F;project&#x2F;reward_rank&#x2F;js&#x2F;0.4b080aac.lazy.js</span><br><span class="line">        ..&#x2F;..&#x2F;..&#x2F;static&#x2F;project&#x2F;reward_rank&#x2F;js&#x2F;1.4b080aac.lazy.js</span><br><span class="line">        ..&#x2F;..&#x2F;..&#x2F;static&#x2F;project&#x2F;reward_rank&#x2F;js&#x2F;2.4b080aac.lazy.js</span><br><span class="line">        ..&#x2F;..&#x2F;..&#x2F;static&#x2F;project&#x2F;reward_rank&#x2F;js&#x2F;3.4b080aac.lazy.js</span><br><span class="line">        ..&#x2F;..&#x2F;..&#x2F;static&#x2F;project&#x2F;reward_rank&#x2F;js&#x2F;main_4b080aac.min.js</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>有两种方式，revert和reset</p><h4 id="git-revert-n-版本号"><a href="#git-revert-n-版本号" class="headerlink" title="git revert -n 版本号"></a>git revert -n 版本号</h4><p>指不要这个提交，其它提交还保留</p><h4 id="git-reset-–hard-版本号"><a href="#git-reset-–hard-版本号" class="headerlink" title="git reset –hard 版本号"></a>git reset –hard 版本号</h4><p>指回退到这个版本，后面的提交都不要。</p><p>在Git中，用HEAD表示当前版本，也就是最新的提交1094adb…（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 回到前一个版本</span><br><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 去到任一版本，cimmit记录的版本号1094a</span><br><span class="line">$ git reset --hard 1094a</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 所有版本的记录</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><p>打包后未add<br>出现两部分内容<br>Changes not staged for commit:（对之前文件的修改）<br>Untracked files:（新生产的文件）<br><strong>git st</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;master&#39;.</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add&#x2F;rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        deleted:    ..&#x2F;..&#x2F;..&#x2F;static&#x2F;project&#x2F;reward_rank&#x2F;css&#x2F;main_bdeaeb84.min.css</span><br><span class="line">        modified:   ..&#x2F;..&#x2F;..&#x2F;static&#x2F;project&#x2F;reward_rank&#x2F;index.html</span><br><span class="line">        deleted:    ..&#x2F;..&#x2F;..&#x2F;static&#x2F;project&#x2F;reward_rank&#x2F;js&#x2F;0.bdeaeb84.lazy.js</span><br><span class="line">        deleted:    ..&#x2F;..&#x2F;..&#x2F;static&#x2F;project&#x2F;reward_rank&#x2F;js&#x2F;1.bdeaeb84.lazy.js</span><br><span class="line">        deleted:    ..&#x2F;..&#x2F;..&#x2F;static&#x2F;project&#x2F;reward_rank&#x2F;js&#x2F;2.bdeaeb84.lazy.js</span><br><span class="line">        deleted:    ..&#x2F;..&#x2F;..&#x2F;static&#x2F;project&#x2F;reward_rank&#x2F;js&#x2F;3.bdeaeb84.lazy.js</span><br><span class="line">        deleted:    ..&#x2F;..&#x2F;..&#x2F;static&#x2F;project&#x2F;reward_rank&#x2F;js&#x2F;main_bdeaeb84.min.js</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        ..&#x2F;..&#x2F;..&#x2F;static&#x2F;project&#x2F;reward_rank&#x2F;css&#x2F;main_4b080aac.min.css</span><br><span class="line">        ..&#x2F;..&#x2F;..&#x2F;static&#x2F;project&#x2F;reward_rank&#x2F;js&#x2F;0.4b080aac.lazy.js</span><br><span class="line">        ..&#x2F;..&#x2F;..&#x2F;static&#x2F;project&#x2F;reward_rank&#x2F;js&#x2F;1.4b080aac.lazy.js</span><br><span class="line">        ..&#x2F;..&#x2F;..&#x2F;static&#x2F;project&#x2F;reward_rank&#x2F;js&#x2F;2.4b080aac.lazy.js</span><br><span class="line">        ..&#x2F;..&#x2F;..&#x2F;static&#x2F;project&#x2F;reward_rank&#x2F;js&#x2F;3.4b080aac.lazy.js</span><br><span class="line">        ..&#x2F;..&#x2F;..&#x2F;static&#x2F;project&#x2F;reward_rank&#x2F;js&#x2F;main_4b080aac.min.js</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><h4 id="git-checkout-–-文件名"><a href="#git-checkout-–-文件名" class="headerlink" title="git checkout – 文件名"></a>git checkout – 文件名</h4><p>– 文件名 不可少，要不然会变成切换分支<br>也可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout</span><br></pre></td></tr></table></figure><p><strong>下面文字的理解是：checkout 只能恢复没有add的修改</strong></p><blockquote><p>–以下来自廖雪峰的git<br>命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p></blockquote><blockquote><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p></blockquote><blockquote><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p></blockquote><blockquote><p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p></blockquote><ol><li>如果已经add 了，用git reset HEAD <file>,文件修改保留，只是从暂存区回到了工作区</file></li><li>已commit，用git reset HEAD^ 回退到上一个版本。文件修改保留，修改从仓库回到了工作区</li><li>git reset HEAD –hard 回到最后一次commit的版本，并且修改不会保留(无论修改是在工作区还是暂存区)(对untrack的修改没有)</li><li>git rm 只能删除版本库里的文件，对untrack的也没用。untrack文件add进暂存区，可以用git rm 文件名 –catched回到工作区。用git rm 文件名 -f 可以彻底删除文件。</li><li>git clean -f 清空工作区的untrack,但对not  staged的修改无效。</li></ol><p>参考：<br><a href="https://blog.csdn.net/weixin_43664308/article/details/100083246" target="_blank" rel="noopener">Git 清空工作区和暂存区</a><br><a href="https://www.liaoxuefeng.com/wiki/896043488029600/897271968352576" target="_blank" rel="noopener">廖雪峰Git教程</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux Command</title>
      <link href="/2021/01/14/Linux-Command/"/>
      <url>/2021/01/14/Linux-Command/</url>
      
        <content type="html"><![CDATA[<p>vim, cat, pwd, mkdir,touch, ls, chmod, chown, chgrp</p><a id="more"></a><hr><h3 id="sudo-lsof-i-1025-查看端口1025被什么程序占用"><a href="#sudo-lsof-i-1025-查看端口1025被什么程序占用" class="headerlink" title="sudo lsof -i:1025 查看端口1025被什么程序占用"></a>sudo lsof -i:1025 查看端口1025被什么程序占用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COMMAND   PID USER   FD   TYPE             DEVICE SIZE&#x2F;OFF NODE NAME</span><br><span class="line">node    63350 jing   24u  IPv4 0x506ba2f2071e30df      0t0  TCP localhost:blackjack (LISTEN)</span><br></pre></td></tr></table></figure><p>杀掉pid未63350的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kill -9 63350</span><br></pre></td></tr></table></figure><h3 id="vim-gitignore"><a href="#vim-gitignore" class="headerlink" title="vim .gitignore"></a>vim .gitignore</h3><p>编辑文件</p><h3 id="cat-gitignore"><a href="#cat-gitignore" class="headerlink" title="cat .gitignore"></a>cat .gitignore</h3><p>查看文件</p><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>print working directory<br>touch 文件名</p><h3 id="mkdir-新建目录"><a href="#mkdir-新建目录" class="headerlink" title="mkdir 新建目录"></a>mkdir 新建目录</h3><p>mkdir 目录名</p><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>创建文件<br>touch 文件名</p><h3 id="ls-a"><a href="#ls-a" class="headerlink" title="ls -a"></a>ls -a</h3><p>可看到隐藏文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br><span class="line"></span><br><span class="line">.                 .DS_Store         .gitignore        _config.yml       node_modules      package.json      scaffolds         themes</span><br><span class="line">..                .git              .travis.yml       db.json           package-lock.json public            source</span><br></pre></td></tr></table></figure><h3 id="ls-l"><a href="#ls-l" class="headerlink" title="ls -l"></a>ls -l</h3><p>查看文件权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">total 0</span><br><span class="line">drwxr-xr-x  31 jing  staff  992 Jan 14 19:09 _posts</span><br><span class="line">drwxr-xr-x   3 jing  staff   96 Jul  7  2020 about</span><br><span class="line">drwxr-xr-x   3 jing  staff   96 Jul  7  2020 archives</span><br><span class="line">drwxr-xr-x   3 jing  staff   96 Jul  7  2020 categories</span><br><span class="line">drwxr-xr-x   3 jing  staff   96 Jul  7  2020 tags</span><br></pre></td></tr></table></figure><p><strong>字段含义：<br>-文件类型权限<br>-文件硬链接数（如果是一个目录，则第2字段表示该目录所含子目录的个数。空文件为2，1个目录为指向自己，一个目录为指向附近）<br>-所属用户<br>-所属群组<br>-文件所占用的空间(以字节为单位)<br>-文件（目录）<br>-最近访问（修改）时间<br>-文件名</strong></p><p><strong>权限：</strong><br>drwxr-xr-x/-rwxr-xr-x共10位，第一位代表类型，后面三位一组分别代表：文件拥有者的权限，文件所属组拥有的权限，其他用户拥有的权限</p><p><strong>权限中第一位类型：</strong></p><ol><li>d: directory</li><li>-: 普通文件</li><li>l: 链接文件link</li><li>b: 块设备文件(block)一般置于/dev目录下，设备文件是普通文件和程序访问硬件设备的入口，是很特殊的文件。没有文件大小，只有一个主设备号和一个辅设备号。一次传输数据为一整块的被称为块设备，如硬盘、光盘等。最小数据传输单位为一个数据块(通常一个数据块的大小为512字节)</li><li>c: 字符设备文件(character) 一般置于/dev目录下，一次传输一个字节的设备被称为字符设备，如键盘、字符终端等，传输数据的最小单位为一个字节。</li><li>p: 命令管道文件。与shell编程有关的文件。</li><li>s: sock文件。与shell编程有关的文件。</li></ol><p><strong>权限字母其余位字母含义：</strong><br>r: read<br>w: write<br>x: eXecute</p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p><strong>例:对/opt/Oracle/目录下的所有文件与子目录执行相同的权限变更：</strong></p><p>chmod -R(递归) 700(权限) 目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 700 &#x2F;opt&#x2F;oracle&#x2F;</span><br></pre></td></tr></table></figure><p>-R参数是<strong>递归</strong> 处理目录下的所有文件以及子文件夹</p><p>700是变更后的权限表示（只有所有者有读和写以及执行的权限）</p><p>/opt/oracle/ 是需要执行的目录</p><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p><strong>例:对 /opt/oracle/  目录下的所有文件与子目录执行相同的所有者变更，使所有者修改为oinstall用户组的oracle用户</strong></p><p>chown -R(递归) 用户:用户组 目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R oracle:oinstall &#x2F;opt&#x2F;oracle&#x2F;</span><br></pre></td></tr></table></figure><p>oracle:oinstall oinstall用户组的oracle，用户组不必须</p><h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p>chgrp 组名 目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp localaccounts mysql-init</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ios 兼容问题Safari调试&amp;真机调试</title>
      <link href="/2021/01/13/ios-%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98Safari%E8%B0%83%E8%AF%95/"/>
      <url>/2021/01/13/ios-%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98Safari%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p> ios手机和Safari真机调试</p><a id="more"></a><h3 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h3><p>Mac电脑，iPhone手机，数据线</p><h3 id="1、mac中Safari设置："><a href="#1、mac中Safari设置：" class="headerlink" title="1、mac中Safari设置："></a>1、mac中Safari设置：</h3><p>打开Safari偏好者设置，选中“高级菜单”，将页面最下方的“在菜单中显示开发菜单”复选框打钩，这样设置完毕后就能在Safari菜单中看到开发菜单</p><img style="margin: 0" src="/2021/01/13/ios-%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98Safari%E8%B0%83%E8%AF%95/20181112144458575.png"><h3 id="2、iPhone-设置："><a href="#2、iPhone-设置：" class="headerlink" title="2、iPhone 设置："></a>2、iPhone 设置：</h3><p>打开iPhone手机设置——&gt;选择Safari，找到高级选项，有JavaScript开关、web检查器开关，将两个开关打开</p><img style="margin: 0" src="/2021/01/13/ios-%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98Safari%E8%B0%83%E8%AF%95/20181112144511290.png"><h3 id="3、iPhone连接mac上，打开Safari浏览器，运行App（开发版）或者手机Safari的web页面，在开发菜单中选择连接的手机，找到调试的网页，就能在Safari里面调试"><a href="#3、iPhone连接mac上，打开Safari浏览器，运行App（开发版）或者手机Safari的web页面，在开发菜单中选择连接的手机，找到调试的网页，就能在Safari里面调试" class="headerlink" title="3、iPhone连接mac上，打开Safari浏览器，运行App（开发版）或者手机Safari的web页面，在开发菜单中选择连接的手机，找到调试的网页，就能在Safari里面调试"></a>3、iPhone连接mac上，打开Safari浏览器，运行App（开发版）或者手机Safari的web页面，在开发菜单中选择连接的手机，找到调试的网页，就能在Safari里面调试</h3><img style="margin: 0" src="/2021/01/13/ios-%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98Safari%E8%B0%83%E8%AF%95/aHR0cHM6Ly93d3cud2FuZ3lhbmFuLm9ubGluZS9tZWRpYS8yMDE4LzEyLzYucG5n.png"><p>4、定位问题出现区域的布局和样式<br><img style="margin: 0" src="/2021/01/13/ios-%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98Safari%E8%B0%83%E8%AF%95/aHR0cHM6Ly93d3cud2FuZ3lhbmFuLm9ubGluZS9tZWRpYS8yMDE4LzEyLzcucG5n.png"></p><p>扩展： Chrome调试 Android web页面<br>1、安装Chrome浏览器<br>2、使用Android 真机连接电脑<br>3、最后，打开Chrome ,输入：chrome://inspect<br><a href="https://blog.csdn.net/whh181/article/details/77930870" target="_blank" rel="noopener">https://blog.csdn.net/whh181/article/details/77930870</a></p><p>参考原文：<br><a href="https://blog.csdn.net/heqiang2015/article/details/83991986" target="_blank" rel="noopener">Safari 调试iPhone web页面（App为开发版）</a><br><a href="https://blog.csdn.net/longlc123/article/details/56370004?utm_medium=distribute.pc_feed_404.none-task-blog-BlogCommendFromBaidu-1.nonecase&depth_1-utm_source=distribute.pc_feed_404.none-task-blog-BlogCommendFromBaidu-1.nonecas" target="_blank" rel="noopener">chrome实现pc端调试-移动端调试（Android）</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>npm packege 遇到的坑</title>
      <link href="/2020/12/31/npm-packege-%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
      <url>/2020/12/31/npm-packege-%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>2020年的最后一天，就用来记录下这些日子来使用npm包遇到的坑。给自己加深下记忆。</p><a id="more"></a><h3 id="vue-infinite-scroll无限加载"><a href="#vue-infinite-scroll无限加载" class="headerlink" title="vue-infinite-scroll无限加载"></a>vue-infinite-scroll无限加载</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-infinite-scroll --save</span><br></pre></td></tr></table></figure><h4 id="使用（vue中）"><a href="#使用（vue中）" class="headerlink" title="使用（vue中）"></a>使用（vue中）</h4><h5 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import infiniteScroll from &#39;vue-infinite-scroll&#39;</span><br><span class="line">Vue.use(infiniteScroll)</span><br></pre></td></tr></table></figure><h5 id="或者在组件中directive引入"><a href="#或者在组件中directive引入" class="headerlink" title="或者在组件中directive引入"></a>或者在组件中directive引入</h5><h5 id="代码中片段"><a href="#代码中片段" class="headerlink" title="代码中片段"></a>代码中片段</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-infinite-scroll&#x3D;&quot;loadMore&quot; infinite-scroll-disabled&#x3D;&quot;busy&quot; infinite-scroll-distance&#x3D;&quot;10&quot;&gt;</span><br><span class="line">    &lt;div v-for&#x3D;&quot;item in data&quot; :key&#x3D;&quot;item.index&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0,</span><br><span class="line">      data: [],</span><br><span class="line">      busy: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    loadMore: function() &#123;</span><br><span class="line">      this.busy &#x3D; true</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        for (var i &#x3D; 0, j &#x3D; 10; i &lt; j; i++) &#123;</span><br><span class="line">          this.data.push(&#123;name: this.count++ &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(this.data)</span><br><span class="line">        this.busy &#x3D; false</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>v-infinite-scroll=”loadMore”表示回调函数是loadMore<br>infinite-scroll-disabled=”busy”表示由变量busy决定是否执行loadMore，false则执行loadMore，true则不执行，看清楚，busy表示繁忙，繁忙的时候是不执行的。<br>infinite-scroll-distance=”10”这里10决定了页面滚动到离页尾多少像素的时候触发回调函数，10是像素值。通常我们会在页尾做一个几十像素高的“正在加载中…”，这样的话，可以把这个div的高度设为infinite-scroll-distance的值即可。</p><p>其他选项：</p><p>infinite-scroll-immediate-check 默认值为true，该指令意思是，应该在绑定后立即检查busy的值和是否滚动到底。如果你的初始内容高度不够高、不足以填满可滚动的容器的话，你应设为true，这样会立即执行一次loadMore，会帮你填充一些初始内容。<br>infinite-scroll-listen-for-event 当事件在Vue实例中发出时，无限滚动将再次检查。<br>infinite-scroll-throttle-delay 检查busy的值的时间间隔，默认值是200，因为vue-infinite-scroll的基础原理就是，vue-infinite-scroll会循环检查busy的值，以及是否滚动到底，只有当：busy为false且滚动到底，回调函数才会执行。</p><h4 id="我遇到的坑"><a href="#我遇到的坑" class="headerlink" title="我遇到的坑"></a>我遇到的坑</h4><p>承载v-infinite-scroll=”loadMore” infinite-scroll-disabled=”busy” infinite-scroll-distance=”10”的元素上有个<strong><em>v-if</em></strong>，导致loadMore根本就不会执行，这块一定要特别注意</p><h3 id="swiper-轮播图"><a href="#swiper-轮播图" class="headerlink" title="swiper 轮播图"></a>swiper 轮播图</h3><p>引用，以下或者cdn</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;CommonJs</span><br><span class="line">var Swiper &#x3D; require(&#39;swiper&#39;);    </span><br><span class="line">var mySwiper &#x3D; new Swiper(&#39;.swiper-container&#39;, &#123; &#x2F;* ... *&#x2F; &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ES</span><br><span class="line">import Swiper from &#39;swiper&#39;;    </span><br><span class="line">var mySwiper &#x3D; new Swiper(&#39;.swiper-container&#39;, &#123; &#x2F;* ... *&#x2F; &#125;);</span><br></pre></td></tr></table></figure><p>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;swiper-container&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;swiper-wrapper&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;swiper-slide&quot;&gt;Slide 1&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;swiper-slide&quot;&gt;Slide 2&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;swiper-slide&quot;&gt;Slide 3&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 如果需要分页器 --&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;swiper-pagination&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 如果需要导航按钮 --&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;swiper-button-prev&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;swiper-button-next&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 如果需要滚动条 --&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;swiper-scrollbar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">导航等组件可以放在container之外</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;        </span><br><span class="line">  var mySwiper &#x3D; new Swiper (&#39;.swiper-container&#39;, &#123;</span><br><span class="line">    direction: &#39;vertical&#39;, &#x2F;&#x2F; 垂直切换选项</span><br><span class="line">    loop: true, &#x2F;&#x2F; 循环模式选项</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 如果需要分页器</span><br><span class="line">    pagination: &#123;</span><br><span class="line">      el: &#39;.swiper-pagination&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 如果需要前进后退按钮</span><br><span class="line">    navigation: &#123;</span><br><span class="line">      nextEl: &#39;.swiper-button-next&#39;,</span><br><span class="line">      prevEl: &#39;.swiper-button-prev&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 如果需要滚动条</span><br><span class="line">    scrollbar: &#123;</span><br><span class="line">      el: &#39;.swiper-scrollbar&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)        </span><br><span class="line">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="不同版本API变化"><a href="#不同版本API变化" class="headerlink" title="不同版本API变化"></a>不同版本API变化</h4><img style="margin: 0 " src="/2020/12/31/npm-packege-%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/zujianhua.png"><h4 id="swiper6"><a href="#swiper6" class="headerlink" title="swiper6"></a>swiper6</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import Swiper, &#123; Autoplay, Pagination &#125; from &quot;swiper&quot;;</span><br><span class="line">Swiper.use([Autoplay, Pagination]);</span><br><span class="line">import &quot;swiper&#x2F;swiper-bundle.min.css&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">new Swiper(&quot;.swiper-container&quot;, &#123;</span><br><span class="line">                initialSlide: 2,</span><br><span class="line">                speed: 300,</span><br><span class="line">                autoplay: &#123;</span><br><span class="line">                    delay: 3000,</span><br><span class="line">                &#125;,</span><br><span class="line">                loop: true,</span><br><span class="line">                slidesPerView: 3,</span><br><span class="line">                spaceBetween: &#39;6%&#39;,</span><br><span class="line">                centeredSlides: true,</span><br><span class="line">                &#x2F;&#x2F; pagination: &#123;</span><br><span class="line">                &#x2F;&#x2F;     el: &quot;.swiper-pagination&quot;,</span><br><span class="line">                &#x2F;&#x2F;     clickable: true,</span><br><span class="line">                &#x2F;&#x2F; &#125;,</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><h4 id="使用文档API"><a href="#使用文档API" class="headerlink" title="使用文档API"></a>使用文档API</h4><p><a href="https://www.swiper.com.cn/api/index.html" target="_blank" rel="noopener">使用文档API</a></p><h4 id="使用swiper遇到的坑"><a href="#使用swiper遇到的坑" class="headerlink" title="使用swiper遇到的坑"></a>使用swiper遇到的坑</h4><p>不同的版本调用不用api，巨坑！<br>一定要注意版本！一定要注意版本！！一定要注意版本！！！</p><h3 id="html2canvas"><a href="#html2canvas" class="headerlink" title="html2canvas"></a>html2canvas</h3><ol><li>图片跨域——前后端都需设置crossorigin，允许跨域</li><li>css样式导致ios手机报错不能生成图——某css中背景图未设置background-size</li><li>图片未加载完成就开始绘制导致失败——绘制放在所有图片onload后</li><li>安卓手机多次保存，有时保存的非绘制图（1.0.0-rc.7）</li><li>ios手机带3DTouch,长按出蓝色半透明遮罩出光标（1.0.0-rc.7）</li></ol><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.zhihu.com/question/265838834" target="_blank" rel="noopener">浏览器端网页截图方案详解</a><br><a href="https://www.jianshu.com/p/e3a59a9fb817" target="_blank" rel="noopener">html2canvas踩坑记</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack config遇到的系列问题</title>
      <link href="/2020/12/23/webpack-config/"/>
      <url>/2020/12/23/webpack-config/</url>
      
        <content type="html"><![CDATA[<p>webpack5、npm包的兼容及遇到的错误解决</p><a id="more"></a><p><a href="https://blog.csdn.net/weixin_40906515/article/details/109376256" target="_blank" rel="noopener">webpack 中最易混淆的 5 个知识点</a><br><a href="https://www.cnblogs.com/sloong/p/5689162.html" target="_blank" rel="noopener">webpack - 多页面/入口支持 &amp; 公共组件单独打包</a></p><h3 id="webpack-5-与-webpack-dev-server-3兼容性问题"><a href="#webpack-5-与-webpack-dev-server-3兼容性问题" class="headerlink" title="webpack 5 与 webpack-dev-server 3兼容性问题"></a>webpack 5 与 webpack-dev-server 3兼容性问题</h3><p>用webpack-dev-server启动项目失败，报错：Error: Cannot find module ‘webpack-cli/bin/config-yargs’</p><p>解决办法：使用 webpack serve </p><p>此时已实现live reload</p><h3 id="npm安装webpack插件报checkPermissions错误"><a href="#npm安装webpack插件报checkPermissions错误" class="headerlink" title="npm安装webpack插件报checkPermissions错误"></a>npm安装webpack插件报checkPermissions错误</h3><p>起因是运行webpack-dev-server时，各种报错Cannot find module，然后卸载、安装npm包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm WARN deprecated chokidar@2.1.8: Chokidar 2 will break on node v14+. Upgrade to chokidar 3 with 15x less dependencies.</span><br><span class="line">npm WARN deprecated fsevents@1.2.13: fsevents 1 will break on node v14+ and could be using insecure binaries. Upgrade to fsevents 2.</span><br><span class="line">npm WARN deprecated resolve-url@0.2.1: https:&#x2F;&#x2F;github.com&#x2F;lydell&#x2F;resolve-url#deprecated</span><br><span class="line">npm WARN deprecated urix@0.1.0: Please see https:&#x2F;&#x2F;github.com&#x2F;lydell&#x2F;urix#deprecated</span><br><span class="line">npm WARN checkPermissions Missing write access to &#x2F;Users&#x2F;jing&#x2F;Documents&#x2F;testwebpack&#x2F;node_modules&#x2F;_p-locate@5.0.0@p-locate&#x2F;node_modules&#x2F;p-limit</span><br><span class="line">npm WARN checkPermissions Missing write access to &#x2F;Users&#x2F;jing&#x2F;Documents&#x2F;testwebpack&#x2F;node_modules&#x2F;_schema-utils@3.0.0@schema-utils&#x2F;node_modules&#x2F;ajv</span><br><span class="line">npm WARN checkPermissions Missing write access to &#x2F;Users&#x2F;jing&#x2F;Documents&#x2F;testwebpack&#x2F;node_modules&#x2F;_schema-utils@3.0.0@schema-utils&#x2F;node_modules&#x2F;ajv-keywords</span><br><span class="line">npm WARN checkPermissions Missing write access to &#x2F;Users&#x2F;jing&#x2F;Documents&#x2F;testwebpack&#x2F;node_modules&#x2F;ajv-errors</span><br><span class="line">npm WARN checkPermissions Missing write access to &#x2F;Users&#x2F;jing&#x2F;Documents&#x2F;testwebpack&#x2F;node_modules&#x2F;assign-symbols</span><br><span class="line">npm WARN checkPermissions Missing write access to &#x2F;Users&#x2F;jing&#x2F;Documents&#x2F;testwebpack&#x2F;node_modules&#x2F;async-limiter</span><br><span class="line">npm WARN checkPermissions Missing write access to &#x2F;Users&#x2F;jing&#x2F;Documents&#x2F;testwebpack&#x2F;node_modules&#x2F;default-gateway</span><br></pre></td></tr></table></figure><p>然后用sudo npm i，还是会报错。</p><p>有人说可能是npm和cnpm交叉使用造成的。</p><p>于是暴利删除node_modules.</p><p>再运行下面代码，终于不再报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm i</span><br></pre></td></tr></table></figure><h3 id="hotModule不起效果"><a href="#hotModule不起效果" class="headerlink" title="hotModule不起效果"></a>hotModule不起效果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">log.js:26 [HMR] Update failed: ChunkLoadError: Loading hot update chunk 143 failed.</span><br><span class="line">(missing: http:&#x2F;&#x2F;localhost:8080&#x2F;143.f7a142c5c6905a4f3f57.hot-update.js)</span><br><span class="line">    at http:&#x2F;&#x2F;localhost:8080&#x2F;app.bundle.js:2:233347</span><br><span class="line">    at new Promise (&lt;anonymous&gt;)</span><br><span class="line">    at s (http:&#x2F;&#x2F;localhost:8080&#x2F;app.bundle.js:2:233299)</span><br><span class="line">    at http:&#x2F;&#x2F;localhost:8080&#x2F;app.bundle.js:2:237441</span><br><span class="line">    at Array.forEach (&lt;anonymous&gt;)</span><br><span class="line">    at Object.o.hmrC.jsonp (http:&#x2F;&#x2F;localhost:8080&#x2F;app.bundle.js:2:237387)</span><br><span class="line">    at http:&#x2F;&#x2F;localhost:8080&#x2F;app.bundle.js:2:229707</span><br><span class="line">    at Array.reduce (&lt;anonymous&gt;)</span><br><span class="line">    at http:&#x2F;&#x2F;localhost:8080&#x2F;app.bundle.js:2:229669</span><br></pre></td></tr></table></figure><p>解决方案：入口文件改为一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    app: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">    &#x2F;&#x2F;print: &#39;.&#x2F;src&#x2F;print.js&#39;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>这时候更改入口index.js引入的print.js里的内容，并不能起到热更新的效果。想要print.js的修改也适用热更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ if (module.hot) &#123;</span><br><span class="line">+   module.hot.accept(&#39;.&#x2F;print.js&#39;, function() &#123;</span><br><span class="line">+     console.log(&#39;Accepting the updated printMe module!&#39;);</span><br><span class="line">+     printMe();</span><br><span class="line">+   &#125;)</span><br><span class="line">+ &#125;</span><br></pre></td></tr></table></figure><p>热更新会在css、vue文件中起效果。因为style-loader、vue-loder已经替我们做了 module.hot.accept</p><h3 id="webpack版本"><a href="#webpack版本" class="headerlink" title="webpack版本"></a>webpack版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;webpack&quot;: &quot;^5.11.0&quot;,</span><br><span class="line">&quot;webpack-cli&quot;: &quot;^4.2.0&quot;,</span><br><span class="line">&quot;webpack-dev-server&quot;: &quot;^3.11.0&quot;</span><br></pre></td></tr></table></figure><h3 id="webpack-config"><a href="#webpack-config" class="headerlink" title="webpack config"></a>webpack config</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line">const &#123; CleanWebpackPlugin &#125; &#x3D; require(&#39;clean-webpack-plugin&#39;);</span><br><span class="line">const webpack &#x3D; require(&#39;webpack&#39;);</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">    &#x2F;&#x2F;print: &#39;.&#x2F;src&#x2F;print.js&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;[name].bundle.js&#39;,</span><br><span class="line">    path: path.resolve(__dirname, &#39;dist&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: &#39;inline-source-map&#39;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: &#39;.&#x2F;dist&#39;,</span><br><span class="line">    hot: true,</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.css$&#x2F;,</span><br><span class="line">        use: [</span><br><span class="line">          &#39;style-loader&#39;,</span><br><span class="line">          &#39;css-loader&#39;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.(png|svg|jpg|gif)$&#x2F;,</span><br><span class="line">        use: [</span><br><span class="line">          &#39;file-loader&#39;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.(xml)$&#x2F;,</span><br><span class="line">        use: [</span><br><span class="line">          &#39;xml-loader&#39;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &#39;Output Management&#39;</span><br><span class="line">    &#125;),</span><br><span class="line">    new CleanWebpackPlugin(&#123;</span><br><span class="line">      cleanOnceBeforeBuildPatterns: &#39;dist&#39;</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; new webpack.NamedModulesPlugin(),</span><br><span class="line">    new webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="入口文件hotModule测试"><a href="#入口文件hotModule测试" class="headerlink" title="入口文件hotModule测试"></a>入口文件hotModule测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">index.js</span><br><span class="line">import _ from &#39;lodash&#39;;</span><br><span class="line">import &#39;.&#x2F;style.css&#39;;</span><br><span class="line">import MyImage from &#39;.&#x2F;icon.png&#39;;</span><br><span class="line">import data from &#39;.&#x2F;mock&#x2F;data.xml&#39;;</span><br><span class="line">import printMe from &#39;.&#x2F;print.js&#39;;</span><br><span class="line"></span><br><span class="line">function component() &#123;</span><br><span class="line">  var element &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">  var btn &#x3D; document.createElement(&#39;button&#39;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Lodash（目前通过一个 script 脚本引入）对于执行这一行是必需的</span><br><span class="line">  element.innerHTML &#x3D; _.join([&#39;Hello&#39;, &#39;webpack&#39;], &#39; &#39;);</span><br><span class="line">  element.classList.add(&#39;hello&#39;);</span><br><span class="line"></span><br><span class="line">  btn.innerHTML &#x3D; &#39;Click me and check the console!&#39;;</span><br><span class="line">  btn.onclick &#x3D; printMe;</span><br><span class="line"></span><br><span class="line">  element.appendChild(btn);</span><br><span class="line">  return element;</span><br><span class="line">&#125;</span><br><span class="line">document.body.appendChild(component());</span><br><span class="line">if (module.hot) &#123;</span><br><span class="line">  module.hot.accept(&#39;.&#x2F;print.js&#39;, function () &#123;&#x2F;&#x2F; print.js 文件改动会触发hotModule</span><br><span class="line">    console.log(&#39;Accepting the updated printMe module!&#39;); </span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">  module.hot.accept(); &#x2F;&#x2F; index文件有改动会触发hotModule，不加这行，index文件的改动触发的是liveReload</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print.js</span><br><span class="line">export default function printMe() &#123;</span><br><span class="line">    console.log(&#39;I got called from print.js!&#39;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>问题是：print文件改动了，点击按钮时 btn.onclick触发的仍旧是旧的printMe。</p><p>index文件改动了，页面会再写入一条component();</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://www.qiutianaimeili.com/html/page/2020/02/zde66zxtxpd.html" target="_blank" rel="noopener">npm安装webpack插件报checkPermissions错误</a></p><p><a href="https://blog.csdn.net/sxs7970/article/details/88746939" target="_blank" rel="noopener">解决报错Cannot find module ‘webpack-cli/bin/config-yargs’</a></p><p><a href="https://www.cnblogs.com/xiaorong-9/p/14069684.html" target="_blank" rel="noopener">webpack 5 与 webpack-dev-server 3兼容性问题</a></p><p><a href="https://segmentfault.com/a/1190000003872635" target="_blank" rel="noopener">Webpack 用来做模块热替换(hot module replacement)</a></p><p><a href="http://www.myjscode.com/page/article109.html" target="_blank" rel="noopener">模块热替换api</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>write bug</title>
      <link href="/2020/12/01/write-bug/"/>
      <url>/2020/12/01/write-bug/</url>
      
        <content type="html"><![CDATA[<p>开发中遇到的一些bug</p><a id="more"></a><h3 id="IOS手机在微信登录时报redirect-uri错误"><a href="#IOS手机在微信登录时报redirect-uri错误" class="headerlink" title="IOS手机在微信登录时报redirect_uri错误"></a>IOS手机在微信登录时报redirect_uri错误</h3><p>原因是redirect_uri长度有限制，可能要求解析后不可超过1024字符。</p><h3 id="一些布尔值判断转义问题"><a href="#一些布尔值判断转义问题" class="headerlink" title="一些布尔值判断转义问题"></a>一些布尔值判断转义问题</h3><p>null == 0 || null &gt;0<br>=&gt;false<br>null &gt;= 0<br>=&gt;true<br>undefined &gt;= 0<br>=&gt;false<br>undefined &gt; 0 || undefined == 0<br>=&gt;false</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自签名ssl证书生成与使用-知识搬运</title>
      <link href="/2020/11/26/ssl%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/11/26/ssl%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>nginx的https证书配置</p><a id="more"></a><h3 id="创建密钥"><a href="#创建密钥" class="headerlink" title="创建密钥"></a>创建密钥</h3><p>首先，进入 nginx 配置目录，创建 openssl 配置文件 <strong>req.conf</strong>，其中的 CN, DNS.1, DNS.2 等需要替换为自己的域名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[req]</span><br><span class="line">distinguished_name &#x3D; req_distinguished_name</span><br><span class="line">x509_extensions &#x3D; v3_req</span><br><span class="line">prompt &#x3D; no</span><br><span class="line">[req_distinguished_name]</span><br><span class="line">C &#x3D; US</span><br><span class="line">ST &#x3D; VA</span><br><span class="line">L &#x3D; SomeCity</span><br><span class="line">O &#x3D; MyCompany</span><br><span class="line">OU &#x3D; MyDivision</span><br><span class="line">CN &#x3D; www.company.com</span><br><span class="line">[v3_req]</span><br><span class="line">keyUsage &#x3D; keyEncipherment, dataEncipherment</span><br><span class="line">extendedKeyUsage &#x3D; serverAuth</span><br><span class="line">subjectAltName &#x3D; @alt_names</span><br><span class="line">[alt_names]</span><br><span class="line">DNS.1 &#x3D; www.company.net</span><br><span class="line">DNS.2 &#x3D; company.com</span><br><span class="line">DNS.3 &#x3D; company.net</span><br></pre></td></tr></table></figure><p>如果域名较多，且都隶属于同一个主域名，可以将 DNS.1、DNS.2 等简化为 *.example.com。即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[alt_names]</span><br><span class="line">DNS.1 &#x3D; *.example.com</span><br></pre></td></tr></table></figure><p>接着，执行如下命令，创建证书：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -nodes -days 730 -newkey rsa:2048 -keyout cert.pem -out cert.pem -config req.conf -extensions &#39;v3_req&#39;</span><br></pre></td></tr></table></figure><h3 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name www.example.com;</span><br><span class="line">    ssl_certificate cert.pem;</span><br><span class="line">    ssl_certificate_key cert.pem;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root &#x2F;Users&#x2F;example&#x2F;hello&#x2F;world;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器证书（ssl_certificate）是一个公开文件，每个请求连接的客户端都会收到一份。私有密钥（ssl_certificate_key）是加密单元，需要存储在保密的地方，但要确保 nginx 主线程可访问。私有密钥一般和证书存储到同一位置。</p><p>cert.pem 就是上一个步骤产生的证书和密钥，在一个文件中。</p><h3 id="配置浏览器"><a href="#配置浏览器" class="headerlink" title="配置浏览器"></a>配置浏览器</h3><p>打开 Chrome 的开发者工具下的【security】选项卡，查看当前的证书，然后下载下来，双击添加到操作系统中，修改为始终信任就可以了。</p><h3 id="采坑"><a href="#采坑" class="headerlink" title="采坑"></a>采坑</h3><p>1、mac-keychain Access 找到对应的证书改为 Always Trust</p><img style="margin: 0 " src="/2020/11/26/ssl%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1606391025496.jpg"><p>2、如果钥匙串中没有相应证书，找到nginx中配置的证书，双击添加到钥匙串中。</p><p>2、由于我是在原证书中加了一个域名，重新生成的证书，发现刷新、重启浏览器、删除老证书，都不能让本地起的nginx服务变安全。解决方法是重启nginx。配置成功！<br><img style="margin: 0 " src="/2020/11/26/ssl%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/1606391344586.jpg"></p><h3 id="转载自"><a href="#转载自" class="headerlink" title="转载自"></a>转载自</h3><p><a href="https://www.1zh.tech/2017/12/15/setup-local-https/" target="_blank" rel="noopener">设置本地 nginx 的 HTTPS</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github上传图片到博客(知识搬运)</title>
      <link href="/2020/11/26/hexo-github%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%88%B0%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/11/26/hexo-github%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%88%B0%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>hexo使用及如何添加图片</p><a id="more"></a><p>1、cd到博客根目录下 查看_config.yml文件 查找 post_asset_folder 字段确定post_asset_folder 设置为true -&gt; post_asset_folder:true</p><p>2、当您设置 post_asset_folder 参数后，在建立文件时，Hexo 会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到此文件夹内，这样就可以更方便的使用资源。</p><p>3、到博客的根目录下执行以下命令来进行插件的安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>4、然后创建一文章 hexo new “test” 然后查看博客的 ../source/_posts 目录下的文件，会看到存在一个test 文件夹 和 test.md 文件<br><img style="margin:0" src="/2020/11/26/hexo-github%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%88%B0%E5%8D%9A%E5%AE%A2/203414-3e5d297effdff3d6.webp"></p><p>5、将所需要的图片资源放到test 文件夹 内 目录结构如下：<br><img style="margin:0" src="/2020/11/26/hexo-github%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%88%B0%E5%8D%9A%E5%AE%A2/203414-7a4566f5a8901158.webp"></p><p>6、书写文章使用test文件内 的图片<br><img style="margin:0" src="/2020/11/26/hexo-github%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%88%B0%E5%8D%9A%E5%AE%A2/203414-670dc6930c83cb4c.webp"></p><p>7、使用hexo s 命令运行本地博客如图<br><img style="margin:0" src="/2020/11/26/hexo-github%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%88%B0%E5%8D%9A%E5%AE%A2/203414-26eb8fcdcd17ceee.webp"></p><p>8、使用hexo clean hexo g hexo deploy 将本地博客推送到远程，即可看到文章中的图片。<br>✅Done！</p><p>9、看效果不是很满意，图片居中，很丑。需html语法让图片居左。由于编译器给img加了margin:0 auto，还是会居中，需在设置一下style</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img style&#x3D;&quot;margin:0&quot; src&#x3D;&quot;hexo-github上传图片到博客&#x2F;203414-26eb8fcdcd17ceee.webp&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>作者：iOS收藏家<br>链接：<a href="https://www.jianshu.com/p/8d28027fec76" target="_blank" rel="noopener">https://www.jianshu.com/p/8d28027fec76</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>postman 使用</title>
      <link href="/2020/11/18/postman%20%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/11/18/postman%20%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Postman是一款功能强大的接口调试工具</p><a id="more"></a><p>1、发送put、get、post请求</p><p>2、Headers设置</p><p>3、Body：post请求时必须要带的参数，里面放一些key-value键值对</p><p>4、params：get请求的参数出现在这里</p><p>5、tests检测response</p><p>6、Pre-requerst Script请求前设置请求数据<br>7、设置全局变量、环境变量</p><p>8、文件夹run自动化测试</p><p>参考文章：<br><a href="https://www.jianshu.com/p/97ba64888894" target="_blank" rel="noopener">Postman教程大全</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网页性能优化</title>
      <link href="/2020/11/01/%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2020/11/01/%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>页面速度和访客的滞留时间，跳出率以及收入都有直接的关系。<br>小于2秒的页载入时间被认为是优良的，而且高达4秒是可接受的。而大于5秒的页面载入时间不仅影响你网站的搜索引擎排名，还会严重影响用户体验。<br>网页性能优化分为很多维度，在各个维度我们需要做什么？</p><a id="more"></a><h3 id="一、网络"><a href="#一、网络" class="headerlink" title="一、网络"></a>一、网络</h3><p>1、减少DNS<br>域名解析的时候页面是没有任何反应的，需要解析的域名越多，页面加载时长会越长。</p><p>2、减少请求<br>1）css sprite<br>2）小图片转为base64<br>3）使用浏览器缓存</p><p>3、优化TCP协议<br>1）TCP连接复用，使用keep-alive：连接回复加上请求头：keep-alive。第一次请求不断开，第二次请求复用。<br>2）使用http 2.0版本：多路复用，连接复用率会更高</p><p>4、同时发送多个请求（浏览器自带）IE8可以同时请求下载4个的css文件，Chrome可以同时请求下载8个 。</p><p>5、减小cookie体积，每个请求都会附带cookie，所以不要滥用cookie。</p><h3 id="二、服务器"><a href="#二、服务器" class="headerlink" title="二、服务器"></a>二、服务器</h3><p>1、使用CDN<br>2、接口keep-alive<br>3、最小化重定向<br>4、Accept-Encoding: gzip, deflate</p><h3 id="三、渲染"><a href="#三、渲染" class="headerlink" title="三、渲染"></a>三、渲染</h3><p>1、减少回流和重绘</p><p>2、懒加载、预加载</p><h3 id="四、图片"><a href="#四、图片" class="headerlink" title="四、图片"></a>四、图片</h3><p>1、选择正确的格式。<br>1）最适合网页的格式是webp<br>2）色彩多适宜用jpg<br>3）半透明、透明图片适宜用png<br>4）动图适宜用gif<br>2、选择合适的尺寸<br>2、压缩图片<br>有很多工具可以压缩图片，压缩的程度需与视觉效果做权衡<br>3、能用文字代替最好用文字</p><h3 id="五、js"><a href="#五、js" class="headerlink" title="五、js"></a>五、js</h3><p>1、压缩js<br>去掉注释、空格等多余的行，减少js的大小；<br>长变量名用简单的字母代替，使用压缩工具可以实现</p><p>2、减少不必要的引用<br>一个文件只需要引用一次</p><p>3、去掉不必要的插件</p><p>4、Ajax的get可缓存</p><p>5、减少监听器，使用事件委托</p><p>6、减少或合并DOM操作或使用虚拟DOM</p><p>7、对大量数据计算使用缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(var i &#x3D; 0,len &#x3D; data.length;i &lt; len;i++)&#123;</span><br><span class="line">     &#x2F;&#x2F; do something...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="六、html"><a href="#六、html" class="headerlink" title="六、html"></a>六、html</h3><p>1、减少嵌套层级</p><p>2、css放在head中，js放在最后</p><h3 id="七、css"><a href="#七、css" class="headerlink" title="七、css"></a>七、css</h3><p>1、避免CSS表达式<br>2、压缩<br>3、精简（合并相同的属性、删除不用的class）</p><h3 id="八、优化用户体验"><a href="#八、优化用户体验" class="headerlink" title="八、优化用户体验"></a>八、优化用户体验</h3><p>用户看到哪些内容就请求哪些内容<br>加一个loading动画用户会感觉时间变快</p><p>参考文章：<br><a href="https://www.diybloghome.com/frontlogy/1036.html" target="_blank" rel="noopener">10种优化页面加载速度的方法</a><br><a href="https://www.cnblogs.com/yzhihao/p/9385467.html" target="_blank" rel="noopener">Web前端性能优化——如何提高页面加载速度</a><br><a href="https://zhuanlan.zhihu.com/p/59681837" target="_blank" rel="noopener">web前端性能优化——如何提高页面加载速度</a><br><a href="https://www.cnblogs.com/xianyulaodi/p/5755079.html" target="_blank" rel="noopener">【原】雅虎前端优化的35条军规</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac du disk usage命令统计文件夹大小</title>
      <link href="/2020/10/31/mac%20du%E5%91%BD%E4%BB%A4%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F/"/>
      <url>/2020/10/31/mac%20du%E5%91%BD%E4%BB%A4%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F/</url>
      
        <content type="html"><![CDATA[<p>查看文件夹的大小适用命令</p><a id="more"></a><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du [-abcDhHklmsSx][-L &lt;符号连接&gt;][-X &lt;文件&gt;][--block-size][--exclude&#x3D;&lt;目录或文件&gt;][--max-depth&#x3D;&lt;目录层数&gt;][--help][--version][目录或文件]</span><br></pre></td></tr></table></figure><h4 id="当du不带任何参数时，会递归显示当前目录下的所有文件夹和子文件夹的大小。"><a href="#当du不带任何参数时，会递归显示当前目录下的所有文件夹和子文件夹的大小。" class="headerlink" title="当du不带任何参数时，会递归显示当前目录下的所有文件夹和子文件夹的大小。"></a>当du不带任何参数时，会递归显示当前目录下的所有文件夹和子文件夹的大小。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">32.&#x2F;const</span><br><span class="line">248.</span><br></pre></td></tr></table></figure><p>参数</p><table><thead><tr><th>参数</th><th>含义</th><th></th></tr></thead><tbody><tr><td>h</td><td>Humanbeing readable 好读模式</td><td></td></tr><tr><td>d</td><td>deep 1—一级目录  2—二级目录……</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h -d 2</span><br></pre></td></tr></table></figure><h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><p>-a或-all 显示目录中个别文件的大小。<br>-b或-bytes 显示目录或文件大小时，以byte为单位。<br>-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。<br>-D或–dereference-args 显示指定符号连接的源文件大小。<br>-h或–human-readable 以K，M，G为单位，提高信息的可读性。<br>-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。<br>-k或–kilobytes 以1024 bytes为单位。<br>-l或–count-links 重复计算硬件连接的文件。<br>-L&lt;符号连接&gt;或–dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文件大小。<br>-m或–megabytes 以1MB为单位。<br>-s或–summarize 仅显示总计。<br>-S或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。<br>-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。<br>-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。<br>–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。<br>–max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。<br>–help 显示帮助。<br>–version 显示版本信息。</p><p>参考文章：<br><a href="https://www.runoob.com/linux/linux-comm-du.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-du.html</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大图详情页问题</title>
      <link href="/2020/09/23/%E5%A4%A7%E5%9B%BE%E6%A8%A1%E5%BC%8F%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2020/09/23/%E5%A4%A7%E5%9B%BE%E6%A8%A1%E5%BC%8F%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>开发中遇到的问题<br>检测全面屏<br>-webkit-overflow-scrolling:touch<br>冒泡导致问题<br>swiper要定义好高度<br>meta referre问题</p><a id="more"></a><h2 id="检测全面屏"><a href="#检测全面屏" class="headerlink" title="检测全面屏"></a>检测全面屏</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function judgeBigScreen() &#123;  </span><br><span class="line">    &#x2F;&#x2F; 这里根据返回值 true 或false ,返回true的话 则为全面屏</span><br><span class="line">     var result &#x3D; false;</span><br><span class="line">     var rate &#x3D; window.screen.height &#x2F; window.screen.width;</span><br><span class="line">     var limit &#x3D;  window.screen.height &#x3D;&#x3D; window.screen.availHeight ? 1.8 : 1.65; &#x2F;&#x2F; 临界判断值</span><br><span class="line"> </span><br><span class="line">     &#x2F;&#x2F; window.screen.height为屏幕高度</span><br><span class="line">     &#x2F;&#x2F;  window.screen.availHeight 为浏览器 可用高度</span><br><span class="line">     if (rate &gt; limit) &#123;</span><br><span class="line">         result &#x3D; true;</span><br><span class="line">     &#125;</span><br><span class="line">     return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="overflow-hidden和-webkit-overflow-scrolling-touch引起的一系列问题"><a href="#overflow-hidden和-webkit-overflow-scrolling-touch引起的一系列问题" class="headerlink" title="overflow:hidden和-webkit-overflow-scrolling:touch引起的一系列问题"></a>overflow:hidden和-webkit-overflow-scrolling:touch引起的一系列问题</h2><ol><li><p>有-webkit-overflow-scrolling:touch属性，会导致正常的横屏滑动（某些ios），划过去不渲染的问题。需上下滑动，才能渲染出。</p></li><li><p>去掉overflow:hidden和-webkit-overflow-scrolling:touch，导致页面之前的scroll事件监听都失效了。需监听document.documentElement。</p></li><li><p>滚动到指点位置的设置，Iphone中设置document.documentElement.scrollTop；Android中设置document.body.scrollTop；</p></li><li><p>输入完成点击支付，软键盘收起，在某些手机支付按钮的焦点并不在你可视的位置。为解决这个问题设置的收起软键盘后scrollTop(0,0)。还会发现，弹窗中的支付按钮，点击时，软键盘收起，并没有跳转到支付页。需在软键盘关闭后再点击一次。去掉overflow:hidden和-webkit-overflow-scrolling:touch，无需再设置scrollTop(0,0)。在软键盘打开的情况下，点击支付按钮，就可以调走。</p></li></ol><p>总结：如非必要，不要用-webkit-overflow-scrolling:touch！<br>不要用-webkit-overflow-scrolling:touch！<br>不要用-webkit-overflow-scrolling:touch！<br>都是坑！</p><h2 id="冒泡导致问题"><a href="#冒泡导致问题" class="headerlink" title="冒泡导致问题"></a>冒泡导致问题</h2><p>前端埋点用来数据统计。<br>用冒泡事件监听body，在遇到需跳转的按钮时，click事件很少能捕捉到。而监听当前元素的点击，发送的click事件则大部分可以被捕捉。</p><p>–在跳转的按钮上，另有click需发送请求，最好不要用冒泡在body上监听。往往服务端接受不到此请求。</p><p>–又遇到一种情况，但点击“查看更多“时，会变为“加载中……“，“查看更多”按钮上的埋点，如果加在父标签上，事件的发送都是通过body上的click检测父标签有没有一个属性，有则发送埋点请求。<br>这时就遇到问题了。点击的目标元素event.target会一直存在，即使父标签已移除，依然可以拿到event.target。但event.target.parentNode这时候就会使null。检测它上面的属性就会检测不到。<br>event.target从DOM中删除了，但还存在内存中。</p><h2 id="swiper要定义好高度"><a href="#swiper要定义好高度" class="headerlink" title="swiper要定义好高度"></a>swiper要定义好高度</h2><p>高度自适应且slide图片有大有小时，会在某些ios手机上滑动方向相反的一边闪屏。</p><h2 id="1px问题"><a href="#1px问题" class="headerlink" title="1px问题"></a>1px问题</h2><p>设计稿上1px的边框，通常我们会用0.5px来实现，一般在ios可以表现正常。但在某些Android手机可能会出现线条出不来的问题。<br>解决：设为1px；用transform:scale(0.5),来启动GPU加速，就会正常渲染</p><p><a href="https://baijiahao.baidu.com/s?id=1564835558133838&wfr=spider&for=pc" target="_blank" rel="noopener">关于GPU</a></p><h2 id="referre问题"><a href="#referre问题" class="headerlink" title="referre问题"></a>referre问题</h2><p>chrome浏览器重85后的版本,meta—referrer的content默认是改为’strict-origin-when-cross-origin’,即跨域请求时，后端拿到的referrer只包括origin，不含路径。在之前的版本上默认no-referrer-when-downgrade，即降级从https到http时，才会只传origin。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;referrer&quot; content&#x3D;&quot;no-referrer-when-downgrade&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>content后面的“属性值”，常见有以下几种：</p><ol><li><p>no-referrer：任何情况下都不发送Referrer信息；</p></li><li><p>no-referrer-when-downgrade：仅当协议降级（如从HTTPS页面跳转到HTTP页面）时不发送Referrer信息。是大部分浏览器默认策略。</p></li><li><p>origin：发送只包含host部分的referrer信息，也就是只包含了协议和域名的url，不包含域名后面部分，比如，来源网页url是<a href="https://www.liudaima.com/1.html，但referrer值只包含http://www.liudaima.com；" target="_blank" rel="noopener">https://www.liudaima.com/1.html，但referrer值只包含http://www.liudaima.com；</a></p></li><li><p>origin-when-cross-origin：仅在发生跨域访问时，发送只包含host的Referer信息，但在同域下还是完整的，而只有协议、域名和端口都一致时，浏览器才认为是同域。</p></li><li><p>unsafe-url：全部都发送Referrer信息，是最宽松，也是最不安全的策略</p></li></ol><p>参考文章：</p><ol><li><a href="https://www.liudaima.com/a/132.html" target="_blank" rel="noopener">meta标签name=”referrer”属性的写法和用法</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy" target="_blank" rel="noopener">MDN:Referrer-Policy </a></li><li><a href="https://developers.google.cn/web/updates/2020/07/referrer-policy-new-chrome-default" target="_blank" rel="noopener">chrome 修改日志</a></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IOS滑动引起卡死现象解决及fixed定位元素抖动问题</title>
      <link href="/2020/09/08/IOS%20%E6%BB%91%E5%8A%A8%E5%BC%95%E8%B5%B7%E5%8D%A1%E6%AD%BB%E7%8E%B0%E8%B1%A1%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/09/08/IOS%20%E6%BB%91%E5%8A%A8%E5%BC%95%E8%B5%B7%E5%8D%A1%E6%AD%BB%E7%8E%B0%E8%B1%A1%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>-webkit-overflow-scrolling:touch 使滑动更加顺滑，但他又会引起一系列问题。</p><p>问题一：滚动到底部上划触发加载更多，触发IOS回弹，页面卡死。</p><p>问题二：点击链接，进入页面，当没有渲染出内容时，手指就不停的往上滑动，内容被渲染出来，手指是一直保持滑动的，但却没有使内容往上移动。</p><p>问题三：触发回弹时，header和footer要固定在页面的上部和下部，不能被遮挡。</p><a id="more"></a><p>困扰我已久，终于有个说的明白的人了！建议先阅读<a href="https://www.cnblogs.com/xiahj/p/8036419.html" target="_blank" rel="noopener">深入研究-webkit-overflow-scrolling:touch及ios滚动</a>，如果未能解决您的问题，接着往下看！</p><p>20200911 ——————————-<br>20200908发现的解决方案，是能解决问题，但实际操作的时候，还需要精确判断页面渲染完成的时间。增加无谓的消耗。<br>于是深入研究了一下其它网站（其实是竞品），为什么人家好像也没有特殊处理，反而没有这个bug呢。</p><p>以下是实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">            &lt;header&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;content&quot;&gt;</span><br><span class="line">                内容</span><br><span class="line">                内容</span><br><span class="line">                很多内容</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;footer&gt;</span><br></pre></td></tr></table></figure><p>html和body的height都是100%(比如672px)</p><p>header和footer是fixed定位。</p><p>container被content撑起来了，比如高度都是3000px;</p><p>就是很普通的布局，但为什么我的页面会出现问题呢？</p><p>重点来了：</p><p>设置content的css，overflow-y和-webkit-overflow-scrolling一定要设置在 content上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">content&#123;</span><br><span class="line">    ···</span><br><span class="line">    overflow-y: scroll;</span><br><span class="line">    -webkit-overflow-scrolling: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>重点是：<br>1、overflow-y和-webkit-overflow-scrolling的设置位置是content，并不是body。<br>2、container body html上都不能设置overflow-y：scroll</strong></p><hr><p>然后，问题一二三都解决了。完美！</p><p>哦，上文所写的参考文章中动态添加元素啥的，也并没有影响。我的页面中container里的内容都是vue动态渲染的，也不需要设置子元素height为100%+1之类的。但文章依然有参考价值。可以深入了解-webkit-overflow-scrolling，知其然和所以然。</p><p>*—————————————<br>然而，在监听scroll事件拿到scrollTop时，又出现问题……</p><p>以上面的布局为例，原来我的overflow-y是写到container(height是100%)上的，这样监听container就可以了。拿container元素的scrollTop就可以了。</p><p>现在overflow-y加到了content(height为3000px)上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以</span><br><span class="line">document.onscroll &#x3D; () &#x3D;&gt; &#123; </span><br><span class="line">    console.log(111);</span><br><span class="line">    console.log(document.body.scrollTop || document.documentElement.scrollTop);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可以</span><br><span class="line">window.onscroll &#x3D; () &#x3D;&gt; &#123; console.log(111)</span><br><span class="line">    console.log(document.body.scrollTop || document.documentElement.scrollTop);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>就需要监听document或者window了。</p><p>以下为20200908所写 ——————————–</p><h3 id="问题三解决：—回弹时header和footer不会被遮挡"><a href="#问题三解决：—回弹时header和footer不会被遮挡" class="headerlink" title="问题三解决：—回弹时header和footer不会被遮挡"></a>问题三解决：—回弹时header和footer不会被遮挡</h3><p>header和footer要和滚动元素位于同一级，main设置滚动，并不是滚动body</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">html, body &#123;</span><br><span class="line">   height: 100%;</span><br><span class="line">  &#125;</span><br><span class="line">  main &#123;</span><br><span class="line">      padding: 50px 0;</span><br><span class="line">      height: 100%;</span><br><span class="line">      overflow-y: scroll;</span><br><span class="line">      -webkit-overflow-scrolling: touch;</span><br><span class="line">  &#125;</span><br><span class="line">  header&#123;</span><br><span class="line">      position:fixed;</span><br><span class="line">      ......</span><br><span class="line">  &#125;</span><br><span class="line">  footer&#123;</span><br><span class="line">      position:fixed;</span><br><span class="line">      ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="问题二解决："><a href="#问题二解决：" class="headerlink" title="问题二解决："></a>问题二解决：</h3><p>参考文章 <a href="https://www.cnblogs.com/xiahj/p/8036419.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiahj/p/8036419.html</a></p><p>尝试文中“3.2如果添加动态内容页面不能滚动，让子元素height+1“方法，能解决页面已经渲染出一屏内容，下面的内容加载慢，手指就开始上划，而出现的卡死。</p><p>但此情形和问题二还不同，猜测可能是由于所设置的“子元素height+1”子元素都是动态添加原因。</p><p>通过测试得知，-webkit-overflow-scrolling设置为auto时，没有回弹，也不会阻碍渲染后页面向上滑动。只有设置了touch才会有这个现象。</p><p>因此我的解决方案是页面loading空白时，-webkit-overflow-scrolling设置为auto，当页面渲染完后，设置-webkit-overflow-scrolling为touch。</p><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>问题二和问题三解决后，问题一并未复现。能够很顺利的上划加载下一页。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>夏大师 <a href="https://www.cnblogs.com/xiahj/p/8036419.html" target="_blank" rel="noopener">深入研究-webkit-overflow-scrolling:touch及ios滚动</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>跨域</title>
      <link href="/2020/09/07/%E8%B7%A8%E5%9F%9F/"/>
      <url>/2020/09/07/%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>跨域的几种方式</p><a id="more"></a><p>同源：<br>协议相同<br>域名相同<br>端口相同</p><p>非同源限制<br>LocalStore 和 IndexDB 无法读取。这两个显然是不能读取的，但是 cookie 有点不一样，放在后面单独说明<br>DOM 无法获取,比如如法在页面 A 中通过 iframe 获取异源页面 B 的 DOM<br>AJAX 请求无法读取（可以发送请求，但是无法读取到请求结果。比如在页面 A 中请求异源接口 B，请求会正常发出处理，但是在页面 A 中无法获取请求结果，除非响应头 Access-Control-Allow-Headers 中允许了页面 A 的源，这样就能读取到结果）<br>  但是这里有个例外，所有带“src”属性的标签都可以跨域加载资源，不受同源策略的限制，这样你应该可以想到一个比较古老的跨域解决方案（JSONP）,同时这个特性也会被用作 CSRF 攻击。</p><h3 id="1-JS设置document-domain实现跨域—iframe-DOM操作"><a href="#1-JS设置document-domain实现跨域—iframe-DOM操作" class="headerlink" title="1 JS设置document.domain实现跨域—iframe DOM操作"></a>1 JS设置document.domain实现跨域—iframe DOM操作</h3><p>这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域.<br>Javascript出于对安全性的考虑，而禁止两个或者多个不同域的页面进行互相操作。<br>相同域的页面在相互操作的时候不会有任何问题。</p><p>有另一种情况，两个子域名：<br>aaa.xxx.com<br>bbb.xxx.com<br>aaa里的一个网页(a.html)引入了bbb 里的一个网页(b.html)<br>通过Javascript，将两个页面的domain改成一样的，<br>需要在a.html里与b.html里都加入：</p><p>代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.domain &#x3D; &quot;***.net&quot;</span><br></pre></td></tr></table></figure><p>这样这两个页面就可以互相操作了。也就是实现了同一基础域名之间的”跨域”。</p><h3 id="http-请求跨域"><a href="#http-请求跨域" class="headerlink" title="http 请求跨域"></a>http 请求跨域</h3><p> 在前端开发中经常会遇到跨域的问题，比如前后端分离中前后端部署在不同的端口上，或者在前端页面中需要向另外一个服务请求数据，这些都会被跨域所阻挡。<br>目前主要有以下几种办法解决跨域问题：</p><p>1、关闭浏览器同源检查(方法：<a href="https://blog.csdn.net/cgs1999/article/details/90751757" target="_blank" rel="noopener">https://blog.csdn.net/cgs1999/article/details/90751757</a>)<br>  这个太暴力，也太不安全了，不用考虑。</p><p>2、jsonp 实现跨域请求<br>  前面说过了浏览器对于带 src 属性的标签都可以跨域的。因此 jsonp 的实现流失利用了这个特性，在页面中动态插入一个<code>&lt;script/&gt;</code>标签,然后他的 src 属性就是接口调用地址，这样就能访问过去了，然后再讲返回内容特殊处理成立即执行的函数，这样就看起像进行了一次跨域请求。之所以不推荐这种方式，主要有以下两个原因：</p><p>1) 实现复杂,且需要前后台同时修改才能实现<br>2)只能进行 get 请求</p><p>3、服务器设置运行跨域<br>  这种方法只需要后台做处理便能实现跨域，前面说的 http 跨域请求是能够发出去的，只是不能接收，那我们只要在响应头Access-Control-Allow-Headers中加入允许请求的地址即可，以,分隔，同时*代表所有地址都允许。比如：    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;localhost:8081,http:&#x2F;&#x2F;localhost:8082</span><br></pre></td></tr></table></figure><p>本方法是较为常用的一种跨域办法,只需简单修改服务端代码即可。</p><p>但是会发现，这些跨域的请求，cookie并未被携带，这时，我们就要加上 withCredentials: true 当前请求为跨域类型时是否在请求中协带cookie</p><p><strong>后端增加 response 头信息Access-Control-Allow-Origin，且必须指定域名，而不能指定为*</strong></p><p><a href="https://blog.csdn.net/chjj0904/article/details/90268813" target="_blank" rel="noopener">ajax中的withCredentials使用效果</a></p><p><a href="https://blog.csdn.net/yasha009/article/details/78784620" target="_blank" rel="noopener">CORS 跨域 access-control-allow-headers 的问题</a></p><p>4、请求代理<br>  这也是非常常用的一种跨域方法。跨域限制只是浏览器限制，服务端并没有这个概念，因此我们在前端还是请求同域地址，然后在服务端做一个代理，将请求转发到真正的 ip 和端口上。通常使用 nginx 实现端口转发，比如下面一段 nginx 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # &#x2F;test1&#x2F;abc 转发到 http:&#x2F;&#x2F;a.com:8011&#x2F;abc</span><br><span class="line">    location &#x2F;test1&#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;a.com:8011&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # &#x2F;test2&#x2F;abc 转发到 http:&#x2F;&#x2F;b.com:8011&#x2F;main&#x2F;abc</span><br><span class="line">    location &#x2F;test2&#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;b.com:8011&#x2F;main&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # &#x2F;test3&#x2F;abc 转发到 http:&#x2F;&#x2F;c.com:8011&#x2F;test3&#x2F;abc</span><br><span class="line">    location &#x2F;test3&#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;c.com:8081;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cookie-同源策略-仅限制域名"><a href="#cookie-同源策略-仅限制域名" class="headerlink" title="cookie 同源策略(仅限制域名)"></a>cookie 同源策略(仅限制域名)</h3><p>cookie 的同源策略是通过“Domain“和“path“两个部分来共同确认一个 cookie 在哪些页面上可用。</p><p>1、设置cookie的domaim和path<br>Domain确定这个 cookie 所属的域名，不能带端口或协议。因此 cookie 便可在不同端口/不同协议下共享,只要域名相同。有一个例外是父子域名间也能共享 cookie，只需将 Domain 设置为.父域名或者父域名（不带.）。<strong><em>domain设为主域名即baidu.com或者.baidu.com,那么cookie在任何百度的子域名下都可共享</em></strong> <a href="http://www.baidu.com仅是baidu.com的子域名，同样受限制。Í" target="_blank" rel="noopener">www.baidu.com仅是baidu.com的子域名，同样受限制。Í</a></p><p>  path就简单多了，通过 Domain 确定哪些域名可以共享 cookie，然后在通过path来确定 cookie 在哪些路径下可用。使用/表示所有路径都可共享。</p><p>具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Domain : example,path : &#x2F;a可获取 cookie:http:&#x2F;&#x2F;example:8081&#x2F;a,https:&#x2F;&#x2F;example:8081&#x2F;a</span><br><span class="line">Domain : example,path : &#x2F;可获取 cookie:http:&#x2F;&#x2F;example:8081&#x2F;a,https:&#x2F;&#x2F;example:8081&#x2F;a , http:&#x2F;&#x2F;example:12&#x2F;abcd</span><br><span class="line">Domain : .example,path : &#x2F;a可获取 cookie:http:&#x2F;&#x2F;example:8081&#x2F;a , https:&#x2F;&#x2F;localhost:8081&#x2F;a , http:&#x2F;&#x2F;test.example:889&#x2F;a</span><br><span class="line"></span><br><span class="line">注意:在跨域请求中，即时目标地址有 cookie 且发起请求的页面也能读取到该 cookie，浏览器也不会将 cookie 自动设置到该跨域请求中。比如在http:&#x2F;&#x2F;localhost:8082&#x2F;a页面中请求http:&#x2F;&#x2F;localhost:8081&#x2F;abc,这两个地址下拥有共享cookie，http请求也不会携带cookie。</span><br></pre></td></tr></table></figure><p>2、设置反向代理，使两个页面位于同一domain和path下。<br>3、jsonp方法<br>文件a/b处于相同域下，不同路径，设置的cookie在b路径下。<br>a.html访问b路径下的jsonp文件。此jsonp文件可以访问b下的cookie。同时可以设置cookie的路径为a。这样a就可以拿到b下的cookie。</p><p>猜测（未经实验）：a通过jsonp请求不用b域上的文件。那个文件能拿到b域上的cookie。回传给a，就可以试想cookie的跨域访问<br>4、nodejs superagent（可参考下方参考文章）<br>5、同一域下，不同工程之间cookie携带<br>（1）. 使用jsonp格式发送<br>（2）. ajax请求中加上字段 xhrFields: {withCredentials: true}，这样可以携带上cookie。这样后台配置就出现了限制，需要配置一个解决跨域访问的过滤器，而且header字段Access-Control-Allow-Origin的值不能为”*”, 必须是一个确定的域。</p><h3 id="image跨域"><a href="#image跨域" class="headerlink" title="image跨域"></a>image跨域</h3><p>在页面上src加载图片资源无跨域问题。但canvas绘图时，加载的资源图和当前域名不使同一域名时，就会加载不出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img.src&#x3D;&quot;shareImages&#x2F;cz.jpg&quot;;</span><br><span class="line">        img2.src&#x3D;app25.newLevelImage;&#x2F;&#x2F;图片的路径</span><br><span class="line">&#x2F;&#x2F; 解决图片的跨域问题</span><br><span class="line">image.setAttribute(&quot;crossOrigin&quot;,&#39;anonymous&#39;)    &#x2F;&#x2F; 添加改代码， 防止跨域</span><br><span class="line">  image.src &#x3D;  item.src + &#39;?v&#x3D;3&#39; ;   &#x2F;&#x2F;添加后缀， 防止缓存；</span><br></pre></td></tr></table></figure><p>cnd源站添加header头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_header Access-Control-Allow-Origin *;</span><br><span class="line">add_header Access-Control-Allow-Headers X-Requested-With;</span><br><span class="line">add_header Access-Control-Allow-Methods Get, Post, Options;</span><br></pre></td></tr></table></figure><p>第三方图片：<br>把第三方图片通过php处理，然后直接输出图片，就可以使用，需要注意的是在请求后台的时候需要用encodeURIComponent转码，不然碰到图片链接里带%号的就呵呵了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let url &#x3D; encodeURIComponent(&#39;图片地址.jpg&#39;)</span><br><span class="line"></span><br><span class="line">this.toDataURL(&#96;后台接口地址.php?url&#x3D;$&#123;url&#125;&#96;, function(dataUrl) &#123;</span><br><span class="line"></span><br><span class="line">      self.dataUrl &#x3D; dataUrl</span><br><span class="line"></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>参考地址 <a href="https://www.jianshu.com/p/f1d0b107e912" target="_blank" rel="noopener">https://www.jianshu.com/p/f1d0b107e912</a><br>参考地址 <a href="https://www.jianshu.com/p/18823f15b31d" target="_blank" rel="noopener">https://www.jianshu.com/p/18823f15b31d</a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.cnblogs.com/lonelyshy/p/10179762.html" target="_blank" rel="noopener">https://www.cnblogs.com/lonelyshy/p/10179762.html</a><br><a href="https://www.cnblogs.com/wuyoucao/p/11075435.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuyoucao/p/11075435.html</a></p><p><a href="https://www.cnblogs.com/hujunzheng/p/5744755.html" target="_blank" rel="noopener">https://www.cnblogs.com/hujunzheng/p/5744755.html</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>静态资源另起域名的意义</title>
      <link href="/2020/09/05/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8F%A6%E8%B5%B7%E5%9F%9F%E5%90%8D%E7%9A%84%E6%84%8F%E4%B9%89/"/>
      <url>/2020/09/05/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8F%A6%E8%B5%B7%E5%9F%9F%E5%90%8D%E7%9A%84%E6%84%8F%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么图片等静态资源最好单独一个域名"><a href="#为什么图片等静态资源最好单独一个域名" class="headerlink" title="为什么图片等静态资源最好单独一个域名"></a>为什么图片等静态资源最好单独一个域名</h1><p>1、cdn加速</p><p>2、可以单独设置缓存策略</p><p>3、突破浏览器并发限制</p><p>4、降低cookie的流量占用</p><p>5.减少主站压力</p><p>6.单独的低权限域名，即使伪装的病毒也不会造成大的损失。—安全</p><p>7.价格便宜（云存储），相对于服务器</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Module的加载实现学习</title>
      <link href="/2020/07/20/Module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/20/Module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>es6Module 和commonJS</p><a id="more"></a><p>原文 <a href="https://es6.ruanyifeng.com/#docs/module-loader" target="_blank" rel="noopener">ES6标准入门</a></p><h3 id="1-浏览器加载"><a href="#1-浏览器加载" class="headerlink" title="1 浏览器加载"></a>1 浏览器加载</h3><ol><li>script标签多了type=”module”属性可以加载es6的Module.同异步模式是defer。<br>script默认是同步，defer指异步下载，渲染完执行（DOM 结构完全生成，以及其他脚本执行完成）。async指异步下载，下载完终断渲染立即执行。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 外联</span><br><span class="line">&lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;.&#x2F;foo.js&quot;&gt;</span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 内嵌   </span><br><span class="line">&lt;script type&#x3D;&quot;module&quot;&gt;</span><br><span class="line">    import $ from &quot;.&#x2F;jquery&#x2F;src&#x2F;jquery.js&quot;;</span><br><span class="line">    $(&#39;#message&#39;).text(&#39;Hi from jQuery!&#39;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h3><p>| — | — | —<br>|  | 输出值 | 值的生成 |<br>| — | — | — |<br>| commonJs | 值的拷贝 | 运行时 |<br>| ES6 | 值的引用 | 编译时 |</p><p><strong><em>值的拷贝</em></strong><br>commonJS模块一旦加载，生成的原始类型的的值就不会改变</p><p><strong><em>值的引用–只读</em></strong><br>脚本真正执行时，根据只读引用去拿值，值变，拿到的会跟着变。</p><h3 id="Node-js-加载"><a href="#Node-js-加载" class="headerlink" title="Node.js 加载"></a>Node.js 加载</h3><p>Node.js 要求 ES6 模块采用.mjs后缀文件名</p><p>*注意，ES6 模块与 CommonJS 模块尽量不要混用。require命令不能加载.mjs文件，会报错，只有import命令才可以加载.mjs文件。反过来，.mjs文件里面也不能使用require命令，必须使用import。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;module&quot;, &#x2F;&#x2F; module时ES6的模块不用.mjs后缀; commonJs时加载commonJS模块不用.cjs后缀。默认commonJS</span><br><span class="line">  &quot;main&quot;: &quot;.&#x2F;src&#x2F;index.js&quot;, &#x2F;&#x2F; 入口文件--优先级低于exports</span><br><span class="line">  &quot;exports&quot;: &#123; 只有支持 ES6 的 Node.js 才认识</span><br><span class="line">   &quot;.&quot;: &quot;.&#x2F;main.js&quot;, &#x2F;&#x2F; main的别名，优先于main</span><br><span class="line">   &quot;.&quot;: &#123; &#x2F;&#x2F; 为 ES6 模块和 CommonJS 指定不同的入口</span><br><span class="line">      &quot;require&quot;: &quot;.&#x2F;main.cjs&quot;,</span><br><span class="line">      &quot;default&quot;: &quot;.&#x2F;main.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    &quot;.&#x2F;submodule&quot;: &quot;.&#x2F;src&#x2F;submodule.js&quot; &#x2F;&#x2F; 子目录</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import feature from &#39;es-module-package&#x2F;features&#x2F;x.js&#39;;</span><br></pre></td></tr></table></figure><h4 id="ES6-模块加载-CommonJS-模块"><a href="#ES6-模块加载-CommonJS-模块" class="headerlink" title="ES6 模块加载 CommonJS 模块"></a>ES6 模块加载 CommonJS 模块</h4><p>*注意，import命令加载 CommonJS 模块，只能整体加载，不能只加载单一的输出项。<br>还有一种变通的加载方法，就是使用 Node.js 内置的module.createRequire()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; cjs.cjs</span><br><span class="line">module.exports &#x3D; &#39;cjs&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; esm.mjs</span><br><span class="line">import &#123; createRequire &#125; from &#39;module&#39;;</span><br><span class="line"></span><br><span class="line">const require &#x3D; createRequire(import.meta.url);</span><br><span class="line"></span><br><span class="line">const cjs &#x3D; require(&#39;.&#x2F;cjs.cjs&#39;);</span><br><span class="line">cjs &#x3D;&#x3D;&#x3D; &#39;cjs&#39;; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h4 id="CommonJS-模块加载-ES6-模块"><a href="#CommonJS-模块加载-ES6-模块" class="headerlink" title="CommonJS 模块加载 ES6 模块"></a>CommonJS 模块加载 ES6 模块</h4><p>只能使用import()这个方法加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(async () &#x3D;&gt; &#123;</span><br><span class="line">  await import(&#39;.&#x2F;my-app.mjs&#39;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h4 id="ES6-模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。"><a href="#ES6-模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。" class="headerlink" title="ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。"></a>ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。</h4><p>不要使用<br>this<br>arguments<br>require<br>module<br>exports<br>__filename<br>__dirname</p><h3 id="循环加载"><a href="#循环加载" class="headerlink" title="循环加载"></a>循环加载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">var b &#x3D; require(&#39;b&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">var a &#x3D; require(&#39;a&#39;);</span><br></pre></td></tr></table></figure><h4 id="commonJS"><a href="#commonJS" class="headerlink" title="commonJS"></a>commonJS</h4><p>只输出已经执行的部分，还未执行的部分不会输出。<br>b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。于是，a.js接着往下执行，直到执行完毕。</p><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><p>需要开发者自己保证，真正取值的时候能够取到值。</p><p>执行a.js, a中引用b.js，b输入a的接口，这时认为a的接口是存在的，接着执行a的接口。如果a并没有执行到此接口，则会报错。解决方式是将a的此接口提前。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网站性能优化</title>
      <link href="/2020/07/14/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2020/07/14/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>从图片、css、js、html、网络、渲染、用户体验、缓存多维度优化网站</p><a id="more"></a><p>转载自视频</p><h3 id="文件放在合适的位置。"><a href="#文件放在合适的位置。" class="headerlink" title="文件放在合适的位置。"></a>文件放在合适的位置。</h3><p><strong>*Css样式文件链接尽量放在头部</strong><br>Css加载不会阻碍DOM tree解析，但是会阻塞到DOM tree渲染，也会阻塞后面js执行。任何body元素之前，可以确保在文档部分中解析了所有的css样式（内联和外联），从而减少了浏览器必须重排文档的次数，如果放置页面底部，就要等待最后一个css文件下载完成，此时会出现“白屏”影响用户体验。</p><p><strong>*Js引用放在html底部</strong><br>防止js的加载、解析、执行对阻塞页面后续元素的正常渲染。</p><h3 id="精简html代码，"><a href="#精简html代码，" class="headerlink" title="精简html代码，"></a>精简html代码，</h3><p><strong>减少html的嵌套</strong><br><strong>减少当节点数</strong><br><strong>减少无语意代码。如消除浮动。</strong><br><strong>删除http或者https，如果url的协议头和当前页面的协议头一致的，或者此url在多个协议里头都是可用的，则可以考虑删除协议头</strong><br><strong>删除多余的空格，换行符、缩进和不必要的注释</strong><br><strong>省略冗余标签和属性</strong><br><strong>使用相对路径的url</strong></p><h3 id="增强用户体验"><a href="#增强用户体验" class="headerlink" title="增强用户体验"></a>增强用户体验</h3><p><strong>设置favicon.ico</strong><br>网站如果不设置favicon.ico，控制台会报错，另外页面加载过程中也没有图标loading过程,同时也不利于记忆网站品牌，建议统一添加</p><p><strong>增加首屏必要的css和js</strong></p><p>页面如果需要等待所有的依赖解释和css加载完成才显示，则在渲染过程中，页面会一直显示空白，影响用户体验，建议增加首屏必要的css和js，比如页面框架背景图片或者loading图标,内联在html页面中，这样做首屏能快速显示出来，相对减少用户对页面加载等待过程.(比如新浪微博M站页面框架)</p><h3 id="提升css渲染性能"><a href="#提升css渲染性能" class="headerlink" title="提升css渲染性能"></a>提升css渲染性能</h3><p><strong>谨慎使用expensive属性</strong><br>如:nth-child伪类；position:fix的定位</p><p><strong>尽量减少样式层级数</strong></p><p>如div ul li span i{ color: blue;}</p><p><strong>尽量避免使用占用过多的CPU和内存的属性</strong></p><p>如text-indent: -99999 px</p><p><strong>尽量避免使用或电量大的属性</strong></p><p>如CSS3 3D transforms、 CSS3 transitions、 opacity</p><h3 id="合理使用CSS选择器"><a href="#合理使用CSS选择器" class="headerlink" title="合理使用CSS选择器"></a>合理使用CSS选择器</h3><p><strong>尽量避免使用CS表达式</strong><br>background-color: expression((new data()).getHours()/2?’#fff’:’#000’);</p><p><strong>尽量避免使用通配选择器</strong><br>body &gt; a{ font-weight:blod;}</p><p><strong>尽量避免类正则的属性选择器</strong><br>*=，|=， ^=, &amp;=</p><h3 id="精简css代码"><a href="#精简css代码" class="headerlink" title="精简css代码"></a>精简css代码</h3><p><strong>使用缩写语句</strong><br><strong>删除不必要的零</strong><br><strong>删除不必要的单位，如px</strong><br><strong>删除过多分好</strong><br><strong>删除空格和注释</strong><br><strong>尽量减少样式表的大小</strong></p><h3 id="合理使用Web-Fonts"><a href="#合理使用Web-Fonts" class="headerlink" title="合理使用Web Fonts"></a>合理使用Web Fonts</h3><p><strong>将字体部署在cdn上</strong><br><strong>将字体以base64形式保存在css中，并通过localStorage进行缓存</strong><br><strong>谷歌字体库，因为某些不可抗拒原因，应该使用国内托管服务</strong></p><h3 id="Css动画优化"><a href="#Css动画优化" class="headerlink" title="Css动画优化"></a>Css动画优化</h3><p><strong>尽量避免同时动画</strong><br><strong>延迟动画初始化</strong><br><strong>结合svg</strong></p><h3 id="JS优化总体原则"><a href="#JS优化总体原则" class="headerlink" title="JS优化总体原则"></a>JS优化总体原则</h3><p><strong>当需要时才优</strong><br><strong>考虑可维护性</strong></p><h3 id="Js变量和函数优化"><a href="#Js变量和函数优化" class="headerlink" title="Js变量和函数优化"></a>Js变量和函数优化</h3><p><strong>尽量使用ID选择器</strong><br><strong>尽量避免使用eval</strong><br><strong>Js函数尽可能保持简洁</strong><br><strong>使用事件节流函数</strong><br><strong>使用事件委托</strong></p><h3 id="提升js文件加载性能"><a href="#提升js文件加载性能" class="headerlink" title="提升js文件加载性能"></a>提升js文件加载性能</h3><p><strong>加载元素的顺序，css文件放在&lt;head&gt;里，js文件放在&lt;body&gt;里</strong></p><h3 id="Js动画优化"><a href="#Js动画优化" class="headerlink" title="Js动画优化"></a>Js动画优化</h3><p><strong>尽量避免添加大量js动画</strong><br><strong>尽量使用css3动画</strong><br><strong>尽量使用Canvas动画</strong><br><strong>合理使用RequestAnimationFrame动画代替setTimeout(callback)、setInterval(callback)无法保证callback回调函数的执行时机</strong> </p><h3 id="合理使用缓存"><a href="#合理使用缓存" class="headerlink" title="合理使用缓存"></a>合理使用缓存</h3><p><strong>合理缓存DOM对象</strong><br><strong>缓存列表长度</strong><br><strong>使用可缓存的AJAX</strong></p><h2 id="9-JavaScript：如何对JavaScript进行缓存优化"><a href="#9-JavaScript：如何对JavaScript进行缓存优化" class="headerlink" title="9 JavaScript：如何对JavaScript进行缓存优化"></a>9 JavaScript：如何对JavaScript进行缓存优化</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>通常有浏览器存储，然后将cookie与每个后续请求一起发送到同一服务器。收到http请求时，服务器可以发送带有cookie的header头，可以给Cookie设置有效时间。</p><p>应用于：</p><ul><li>会话管理：登录名、购物车商品、游戏得分或服务器应要记录的其他任何内容</li><li>个性化：用户首选项、主题或其他设置</li><li>跟踪：记录和分析用户行为，比如埋点</li></ul><h3 id="Session-storage"><a href="#Session-storage" class="headerlink" title="Session storage"></a>Session storage</h3><p>建立一个本地存储的键/值对<br>应用于：页面应用页面之间传值</p><h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><p>索引数据库<br>应用于:</p><ul><li>客户端存储大量结构化数据</li><li>没有网络连接的情况下使用(比如Google DOC、石墨文档）</li><li>将冗余、很少修改、但经常访问的数据，以避免随时从服务器获取数据</li></ul><h3 id="Local-storage"><a href="#Local-storage" class="headerlink" title="Local storage"></a>Local storage</h3><p>本地存储<br>应用于：</p><ul><li>缓存静态文件内容js/css(比如百度M站首页)</li><li>缓存不常变更的API接口数据</li><li>储存地理位置信息</li><li>浏览在页面的具体位置</li></ul><h3 id="JS模块化加载方案和选型"><a href="#JS模块化加载方案和选型" class="headerlink" title="JS模块化加载方案和选型"></a>JS模块化加载方案和选型</h3><p><strong>commonJS</strong></p><ul><li>旨在web浏览器之外为JavaScript建立模块生态系统。</li><li>Node.js 模块化方案受commonJS</li><li>*Amd(Asynchronous Module Definition)(异步模块定义)规范</li><li>RequireJS模块化加载器:基于AMD API实现</li><li>*CMD(Common Module Definition)(通用模块定义)规范</li><li>SeaJS模块加载器:遵循CMD API的编写</li><li><em>ES6 import*</em></li></ul><h3 id="Css"><a href="#Css" class="headerlink" title="Css"></a>Css</h3><ul><li>避免过多样式嵌套</li><li>避免使用css表达式</li><li>使用绝对定位,可以让动画元素脱离文档流</li><li>避免使用table布局</li><li>尽量不使用float布局</li><li>图片最好设置好width和height</li><li>尽量简化浏览器不必要的任务，减少页面重新布局</li><li>使用viewpoint设置屏幕缩放级别</li><li>避免频繁设置样式，最好把新style属性设置完成后,进行一次性更改</li><li>避免使用引流引起回流/重绘的属性，最好把相应变量缓存起来</li></ul><p>JS<br><strong>最小化回流和重排</strong></p><ul><li>为了减少回流发生次数，避免频繁或操作DOM,可以合并多次对DOM修改，然后一次性批量处理</li><li><em>控制绘制过程和绘制区域*</em></li><li>绘制过程开销比较大的属性设置应该尽量避免减少使用</li><li>减少绘制区域范围</li></ul><h2 id="12-DOM编程优化：怎样控制DOM大小并简化DOM操作"><a href="#12-DOM编程优化：怎样控制DOM大小并简化DOM操作" class="headerlink" title="12 DOM编程优化：怎样控制DOM大小并简化DOM操作"></a>12 DOM编程优化：怎样控制DOM大小并简化DOM操作</h2><h3 id="控制DOM大小"><a href="#控制DOM大小" class="headerlink" title="控制DOM大小"></a>控制DOM大小</h3><ul><li><p>众所周知，页面交互卡顿和流畅度很大一部分原因就是页面有大量的DOM元素，想象一下，从一个上万个节点的DOM Tree上，使用querySelectorAll或者getElementByTagName方法查找某一个节点,是非常耗时的.另外元素绑定事件、事件冒泡或事件捕获的执行也会相对耗时</p></li><li><p>通常控制DOM大小的技巧包括：</p><ul><li>合理业务逻辑</li><li>延迟加载即将呈现的内容</li></ul></li></ul><h3 id="简化DOM操作"><a href="#简化DOM操作" class="headerlink" title="简化DOM操作"></a>简化DOM操作</h3><ul><li>对DOM节点的操作处理后统一插入到DOM Tree中。</li><li>可以使用fragment，尽量不在页面DOM Tree里直接操作.</li><li>现在流行的框架Angular、react、 vue，都在使用虚拟DOM技术，通过diff算法简化和减少DOM操作</li></ul><h2 id="13静态文件：有哪些常用的压缩工具？"><a href="#13静态文件：有哪些常用的压缩工具？" class="headerlink" title="13静态文件：有哪些常用的压缩工具？"></a>13静态文件：有哪些常用的压缩工具？</h2><h3 id="静态文件压缩工具介绍"><a href="#静态文件压缩工具介绍" class="headerlink" title="静态文件压缩工具介绍"></a>静态文件压缩工具介绍</h3><ul><li>html压缩工具，<ul><li>html-minifier</li></ul></li><li>CSS压缩工具<ul><li>clean-css</li></ul></li><li>JS压缩工具<ul><li>uglify-js</li><li>使用方法：uglifyjs in.js -o out.js</li></ul></li></ul><h3 id="静态文件打包方案"><a href="#静态文件打包方案" class="headerlink" title="静态文件打包方案"></a>静态文件打包方案</h3><ul><li>公共组件拆分</li><li>压缩:JS/CSS/图片</li><li>合并:JS/CSS文件合并, CSS Sprite</li><li>Combo: JS/CSS文件 Combo <a href="http://cdn.com/??a.js,b.js内容" target="_blank" rel="noopener">http://cdn.com/??a.js,b.js内容</a></li></ul><h2 id="静态文件-版本号更新-你应该遵循哪些策略"><a href="#静态文件-版本号更新-你应该遵循哪些策略" class="headerlink" title="静态文件:版本号更新,你应该遵循哪些策略"></a>静态文件:版本号更新,你应该遵循哪些策略</h2><h3 id="静态文件版本号更新策略"><a href="#静态文件版本号更新策略" class="headerlink" title="静态文件版本号更新策略"></a>静态文件版本号更新策略</h3><ul><li><p>缓存更新</p><ul><li>CDN或ng后台刷新文件路径，更新文件header头</li></ul></li><li><p>文件name.v1-v100.js</p><ul><li>大功能迭代每次新增一个大版本，比如由v1到v2</li><li>小功能迭代新增加0.0.1或者0.1.0，比如从v1.0.0至v1.0.1</li><li>年末ng统一配置所有版本302至最新版</li></ul></li><li><p>时间戳.文件name.js</p><ul><li>以每次上线时间点做差异</li></ul></li><li><p>文件hash.文件name.js</p><ul><li>以文件内容hash值做key，每次上线,文件路径不一致</li></ul></li></ul><p><img src alt></p><h3 id="前端构建工具介绍和选型建议"><a href="#前端构建工具介绍和选型建议" class="headerlink" title="前端构建工具介绍和选型建议"></a>前端构建工具介绍和选型建议</h3><ul><li>Grunt<ul><li>最早，一个项目需要定制多个小任务和引用多个插件（质量参差不齐）</li></ul></li><li>Gulp<ul><li>通过流（Stream）来简化多个任务间的配置和输出，配置代码相对较少</li></ul></li><li>Webpack<ul><li>预编译，中间文件在内存中处理，支持多种模块化，配置相对很简单</li></ul></li><li>FIS</li><li>JDF</li></ul><h3 id="webpack打包优化"><a href="#webpack打包优化" class="headerlink" title="webpack打包优化"></a>webpack打包优化</h3><ul><li>定位体积大的模块</li><li>删除没有使用的依赖</li><li>生产模式进行公共依赖包抽离</li><li>开发模式进行DLL&amp;DllReference方案优化</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo和travis建github.io个人博客</title>
      <link href="/2020/07/07/hexo%E5%92%8Ctravis%E5%BB%BAgithub.io%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/07/07/hexo%E5%92%8Ctravis%E5%BB%BAgithub.io%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>hexo和travis建github.io个人博客</p><a id="more"></a><h2 id="建name-github-io-仓库-开源"><a href="#建name-github-io-仓库-开源" class="headerlink" title="建name.github.io 仓库(开源)"></a>建name.github.io 仓库(开源)</h2><p>可以自行百度，相关文章很多</p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a> </p><h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><p>Node.js (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)<br>Git</p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><h3 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="配置_config.yml"></a>配置_config.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">title: April的个人小站</span><br><span class="line">subtitle: &#39;&#39;</span><br><span class="line">description: &#39;&#39;</span><br><span class="line">keywords:</span><br><span class="line">author: April</span><br><span class="line">language: zh_CN</span><br><span class="line">timezone: &#39;&#39;</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: http:&#x2F;&#x2F;yoursite.com</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads&#x2F;code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link:</span><br><span class="line">  enable: true # Open external links in new tab</span><br><span class="line">  field: site # Apply to the whole site</span><br><span class="line">  exclude: &#39;&#39;</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace: &#39;&#39;</span><br><span class="line">  wrap: true</span><br><span class="line">  hljs: false</span><br><span class="line"></span><br><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default &#x3D; &#39;&#39;)</span><br><span class="line"># per_page: Posts displayed per page. (0 &#x3D; disable pagination)</span><br><span class="line"># order_by: Posts order. (Order by date descending by default)</span><br><span class="line">index_generator:</span><br><span class="line">  path: &#39;&#39;</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -date</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"># Metadata elements</span><br><span class="line">## https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;HTML&#x2F;Element&#x2F;meta</span><br><span class="line">meta_generator: true</span><br><span class="line"></span><br><span class="line"># Date &#x2F; Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http:&#x2F;&#x2F;momentjs.com&#x2F;docs&#x2F;#&#x2F;displaying&#x2F;format&#x2F;</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line">## Use post&#39;s date for updated date unless set in front-matter</span><br><span class="line">use_date_for_updated: false</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># Include &#x2F; Exclude file(s)</span><br><span class="line">## include:&#x2F;exclude: options only apply to the &#39;source&#x2F;&#39; folder</span><br><span class="line">include:</span><br><span class="line">exclude:</span><br><span class="line">ignore:</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: next1</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;jingjing1205315&#x2F;jingjing1205315.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h2 id="安装travis-ci"><a href="#安装travis-ci" class="headerlink" title="安装travis-ci"></a>安装travis-ci</h2><p><a href="https://www.travis-ci.org/getting_started" target="_blank" rel="noopener">官网</a> 点点点就好了。</p><h2 id="将-Hexo-部署到-GitHub-Pages-配置io库时，官方文档有误"><a href="#将-Hexo-部署到-GitHub-Pages-配置io库时，官方文档有误" class="headerlink" title="将 Hexo 部署到 GitHub Pages(配置io库时，官方文档有误)"></a>将 Hexo 部署到 GitHub Pages(配置io库时，官方文档有误)</h2><p><a href="https://hexo.io/zh-cn/docs/github-pages" target="_blank" rel="noopener">官方文档</a><br>从第8条开始有误，第10条中后缀为io的库不可以修改GitHub Pages 的部署分支为 gh-pages。以至于我们需要将源代码提交到gh-pages，travis-ci将push的代码构建成html放到master。<br>这时就要修改以下几条<br>8. 在你的 Hexo 站点文件夹中新建一个 .travis.yml 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">sudo: false</span><br><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - 10 # use nodejs v10 LTS</span><br><span class="line">cache: npm</span><br><span class="line">before_install:               # install 阶段之前执行</span><br><span class="line">  - npm install -g hexo-cli   # 全局安装 Hexo 命令行工具</span><br><span class="line"></span><br><span class="line">install:                      # 在安装项目环境阶段需要运行的命令，一条一行，类似的还有 before_install</span><br><span class="line">  - npm install               # 安装 package.json 中的依赖</span><br><span class="line"></span><br><span class="line">script:                       # 在构建阶段需要运行的命令，一条一行，类似的还有 before_script、after_script</span><br><span class="line">  - hexo clean</span><br><span class="line">  - hexo generate             # Hexo 常规命令，执行清理和生成</span><br><span class="line"></span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - gh-pages # build gh-pages branch only</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  provider: pages</span><br><span class="line">  skip-cleanup: true</span><br><span class="line">  github-token: $GH_TOKEN</span><br><span class="line">  keep-history: true</span><br><span class="line">  on:</span><br><span class="line">    branch: gh-pages</span><br><span class="line">  local-dir: public</span><br><span class="line">  target-branch: master</span><br></pre></td></tr></table></figure><ol start="9"><li>将 .travis.yml 推送到 repository 中的gh-pages分支，Travis CI 应该会自动开始运行，并将生成的文件推送到同一 repository 下的 master 分支下<br><u>10. 在 GitHub 中前往你的 repository 的设置页面，修改 GitHub Pages 的部署分支为 gh-pages。</u> (非io仓库可以)</li><li>前往 https://&lt;你的 GitHub 用户名&gt;.github.io 查看你的站点是否可以访问。这可能需要一些时间。</li></ol><h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><h3 id="给博客换主题"><a href="#给博客换主题" class="headerlink" title="给博客换主题"></a>给博客换主题</h3><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网</a>,下载自己喜欢的主题。以next主题为例。</p><p>将_config.yml中的theme设置成下载的主题，本地运行没有问题，但是push到gh—pages时，就会发现themes下的next文件夹一直是空的。这时因为next主题有自己的.git。形成了git的submodule。</p><p>删掉.git，push，还是空的。</p><p>然后……  给next文件夹改个名字，如next1，可以push了……</p><p>这时_config.yml中的theme需要设置为next1，push，构建成功！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Include &#x2F; Exclude file(s)</span><br><span class="line">## include:&#x2F;exclude: options only apply to the &#39;source&#x2F;&#39; folder</span><br><span class="line">include:</span><br><span class="line">exclude:</span><br><span class="line">ignore:</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: next1 &#x2F;&#x2F; 下载的主题，要改个名字</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;jingjing1205315&#x2F;jingjing1205315.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Back-Forward cache</title>
      <link href="/2020/07/06/Back-Forward%20cache/"/>
      <url>/2020/07/06/Back-Forward%20cache/</url>
      
        <content type="html"><![CDATA[<p>往返缓存（Back/Forward cache，下文中简称bfcache）是浏览器为了在用户页面间执行前进后退操作时拥有更加流畅体验的一种策略。该策略具体表现为，当用户前往新页面时，将当前页面的浏览器DOM状态保存到bfcache中；当用户点击后退按钮的时候，将页面直接从bfcache中加载，节省了网络请求的时间。</p><a id="more"></a><p>往返缓存（Back/Forward cache，下文中简称bfcache）是浏览器为了在用户页面间执行前进后退操作时拥有更加流畅体验的一种策略。该策略具体表现为，当用户前往新页面时，将当前页面的浏览器DOM状态保存到bfcache中；当用户点击后退按钮的时候，将页面直接从bfcache中加载，节省了网络请求的时间。</p><p>比如：二级页面有用户操作行为导致的状态变更，我们希望回退时一级页面有相应的体现。这时希望浏览器不要展现缓存页面。</p><p><strong>解决方案：</strong>根据<a href="https://github.com/LeuisKen/leuisken.github.io/issues/6" target="_blank" rel="noopener">浏览器往返缓存（Back/Forward cache）问题的分析与解决</a>，尝试用worker，无效果。</p><p>回退会触发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;pageshow&#39;, event &#x3D;&gt; &#123;</span><br><span class="line">  if (event.persisted) &#123;</span><br><span class="line">    window.location.reload();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样页面会重新加载，但缓存的页面会闪现一下。如果页面有load动画，动画在闪现的缓存页面也会执行。</p><p><strong>解决方案：</strong>首页进入页面，动画执行完，移除动画dom，这样回退的时候，在缓存的页面就不会有动画。</p><p><strong>完美方案：</strong>缓存页面不闪现。（未解决）</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> PHONE </category>
          
          <category> IOS </category>
          
          <category> JS </category>
          
          <category> ACCUMULATION </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 复杂判断的更优雅写法</title>
      <link href="/2020/07/05/JavaScript%20%E5%A4%8D%E6%9D%82%E5%88%A4%E6%96%AD%E7%9A%84%E6%9B%B4%E4%BC%98%E9%9B%85%E5%86%99%E6%B3%95/"/>
      <url>/2020/07/05/JavaScript%20%E5%A4%8D%E6%9D%82%E5%88%A4%E6%96%AD%E7%9A%84%E6%9B%B4%E4%BC%98%E9%9B%85%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>我们编写js代码时经常遇到复杂逻辑判断的情况，通常大家可以用if/else或者switch来实现多个条件判断，但这样会有个问题，随着逻辑复杂度的增加，代码中的if/else/switch会变得越来越臃肿，越来越看不懂，那么如何更优雅的写判断逻辑，本文带你试一下。</p><a id="more"></a><p>转载在<a href="https://mp.weixin.qq.com/s/JkZZbWOesqWDVGkUh2lRvg" target="_blank" rel="noopener">JavaScript 复杂判断的更优雅写法</a></p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>我们编写js代码时经常遇到复杂逻辑判断的情况，通常大家可以用if/else或者switch来实现多个条件判断，但这样会有个问题，随着逻辑复杂度的增加，代码中的if/else/switch会变得越来越臃肿，越来越看不懂，那么如何更优雅的写判断逻辑，本文带你试一下。</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>先看一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 按钮点击事件</span><br><span class="line">     * @param &#123;number&#125; status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消</span><br><span class="line">     *&#x2F;const onButtonClick &#x3D; (status)&#x3D;&gt;&#123;</span><br><span class="line">      if(status &#x3D;&#x3D; 1)&#123;</span><br><span class="line">        sendLog(&#39;processing&#39;)</span><br><span class="line">        jumpTo(&#39;IndexPage&#39;)</span><br><span class="line">      &#125;elseif(status &#x3D;&#x3D; 2)&#123;</span><br><span class="line">        sendLog(&#39;fail&#39;)</span><br><span class="line">        jumpTo(&#39;FailPage&#39;)</span><br><span class="line">      &#125;elseif(status &#x3D;&#x3D; 3)&#123;</span><br><span class="line">        sendLog(&#39;fail&#39;)</span><br><span class="line">        jumpTo(&#39;FailPage&#39;)</span><br><span class="line">      &#125;elseif(status &#x3D;&#x3D; 4)&#123;</span><br><span class="line">        sendLog(&#39;success&#39;)</span><br><span class="line">        jumpTo(&#39;SuccessPage&#39;)</span><br><span class="line">      &#125;elseif(status &#x3D;&#x3D; 5)&#123;</span><br><span class="line">        sendLog(&#39;cancel&#39;)</span><br><span class="line">        jumpTo(&#39;CancelPage&#39;)</span><br><span class="line">      &#125;else &#123;</span><br><span class="line">        sendLog(&#39;other&#39;)</span><br><span class="line">        jumpTo(&#39;Index&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过代码可以看到这个按钮的点击逻辑：根据不同活动状态做两件事情，发送日志埋点和跳转到对应页面，大家可以很轻易的提出这段代码的改写方案，switch出场：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 按钮点击事件</span><br><span class="line">     * @param &#123;number&#125; status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消</span><br><span class="line">     *&#x2F;const onButtonClick &#x3D; (status)&#x3D;&gt;&#123;</span><br><span class="line">      switch (status)&#123;</span><br><span class="line">        case1:</span><br><span class="line">          sendLog(&#39;processing&#39;)</span><br><span class="line">          jumpTo(&#39;IndexPage&#39;)</span><br><span class="line">          breakcase2:</span><br><span class="line">        case3:</span><br><span class="line">          sendLog(&#39;fail&#39;)</span><br><span class="line">          jumpTo(&#39;FailPage&#39;)</span><br><span class="line">          breakcase4:</span><br><span class="line">          sendLog(&#39;success&#39;)</span><br><span class="line">          jumpTo(&#39;SuccessPage&#39;)</span><br><span class="line">          breakcase5:</span><br><span class="line">          sendLog(&#39;cancel&#39;)</span><br><span class="line">          jumpTo(&#39;CancelPage&#39;)</span><br><span class="line">          breakdefault:</span><br><span class="line">          sendLog(&#39;other&#39;)</span><br><span class="line">          jumpTo(&#39;Index&#39;)</span><br><span class="line">          break</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>嗯，这样看起来比if/else清晰多了，细心的同学也发现了小技巧，case 2和case 3逻辑一样的时候，可以省去执行语句和break，则case 2的情况自动执行case 3的逻辑。</p><p>这时有同学会说，还有更简单的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const actions &#x3D; &#123;</span><br><span class="line">      &#39;1&#39;: [&#39;processing&#39;,&#39;IndexPage&#39;],</span><br><span class="line">      &#39;2&#39;: [&#39;fail&#39;,&#39;FailPage&#39;],</span><br><span class="line">      &#39;3&#39;: [&#39;fail&#39;,&#39;FailPage&#39;],</span><br><span class="line">      &#39;4&#39;: [&#39;success&#39;,&#39;SuccessPage&#39;],</span><br><span class="line">      &#39;5&#39;: [&#39;cancel&#39;,&#39;CancelPage&#39;],</span><br><span class="line">      &#39;default&#39;: [&#39;other&#39;,&#39;Index&#39;],</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 按钮点击事件</span><br><span class="line">     * @param &#123;number&#125; status 活动状态：1开团进行中 2开团失败 3 商品售罄 4 开团成功 5 系统取消</span><br><span class="line">     *&#x2F;const onButtonClick &#x3D; (status)&#x3D;&gt;&#123;</span><br><span class="line">      let action &#x3D; actions[status] || actions[&#39;default&#39;],</span><br><span class="line">          logName &#x3D; action[0],</span><br><span class="line">          pageName &#x3D; action[1]</span><br><span class="line">      sendLog(logName)</span><br><span class="line">      jumpTo(pageName)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面代码确实看起来更清爽了，这种方法的聪明之处在于：将判断条件作为对象的属性名，将处理逻辑作为对象的属性值，在按钮点击的时候，通过对象属性查找的方式来进行逻辑判断，这种写法特别适合一元条件判断的情况。</p><p>是不是还有其他写法呢？有的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const actions &#x3D; newMap([</span><br><span class="line">      [1, [&#39;processing&#39;,&#39;IndexPage&#39;]],</span><br><span class="line">      [2, [&#39;fail&#39;,&#39;FailPage&#39;]],</span><br><span class="line">      [3, [&#39;fail&#39;,&#39;FailPage&#39;]],</span><br><span class="line">      [4, [&#39;success&#39;,&#39;SuccessPage&#39;]],</span><br><span class="line">      [5, [&#39;cancel&#39;,&#39;CancelPage&#39;]],</span><br><span class="line">      [&#39;default&#39;, [&#39;other&#39;,&#39;Index&#39;]]</span><br><span class="line">    ])</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 按钮点击事件</span><br><span class="line">     * @param &#123;number&#125; status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消</span><br><span class="line">     *&#x2F;const onButtonClick &#x3D; (status)&#x3D;&gt;&#123;</span><br><span class="line">      let action &#x3D; actions.get(status) || actions.get(&#39;default&#39;)</span><br><span class="line">      sendLog(action[0])</span><br><span class="line">      jumpTo(action[1])</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样写用到了es6里的Map对象，是不是更爽了？Map对象和Object对象有什么区别呢？</p><ol><li>一个对象通常都有自己的原型，所以一个对象总有一个”prototype”键。</li><li>一个对象的键只能是字符串或者Symbols，但一个Map的键可以是任意值。</li><li>你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。</li></ol><p>我们需要把问题升级一下，以前按钮点击时候只需要判断status，现在还需要判断用户的身份：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 按钮点击事件</span><br><span class="line">     * @param &#123;number&#125; status 活动状态：1开团进行中 2开团失败 3 开团成功 4 商品售罄 5 有库存未开团</span><br><span class="line">     * @param &#123;string&#125; identity 身份标识：guest客态 master主态</span><br><span class="line">     *&#x2F;const onButtonClick &#x3D; (status,identity)&#x3D;&gt;&#123;</span><br><span class="line">      if(identity &#x3D;&#x3D; &#39;guest&#39;)&#123;</span><br><span class="line">        if(status &#x3D;&#x3D; 1)&#123;</span><br><span class="line">          &#x2F;&#x2F;do sth</span><br><span class="line">        &#125;elseif(status &#x3D;&#x3D; 2)&#123;</span><br><span class="line">          &#x2F;&#x2F;do sth</span><br><span class="line">        &#125;elseif(status &#x3D;&#x3D; 3)&#123;</span><br><span class="line">          &#x2F;&#x2F;do sth</span><br><span class="line">        &#125;elseif(status &#x3D;&#x3D; 4)&#123;</span><br><span class="line">          &#x2F;&#x2F;do sth</span><br><span class="line">        &#125;elseif(status &#x3D;&#x3D; 5)&#123;</span><br><span class="line">          &#x2F;&#x2F;do sth</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">          &#x2F;&#x2F;do sth</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;elseif(identity &#x3D;&#x3D; &#39;master&#39;) &#123;</span><br><span class="line">        if(status &#x3D;&#x3D; 1)&#123;</span><br><span class="line">          &#x2F;&#x2F;do sth</span><br><span class="line">        &#125;elseif(status &#x3D;&#x3D; 2)&#123;</span><br><span class="line">          &#x2F;&#x2F;do sth</span><br><span class="line">        &#125;elseif(status &#x3D;&#x3D; 3)&#123;</span><br><span class="line">          &#x2F;&#x2F;do sth</span><br><span class="line">        &#125;elseif(status &#x3D;&#x3D; 4)&#123;</span><br><span class="line">          &#x2F;&#x2F;do sth</span><br><span class="line">        &#125;elseif(status &#x3D;&#x3D; 5)&#123;</span><br><span class="line">          &#x2F;&#x2F;do sth</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">          &#x2F;&#x2F;do sth</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>原谅我不写每个判断里的具体逻辑了，因为代码太冗长了。</p><p>原谅我又用了if/else，因为我看到很多人依然在用if/else写这种大段的逻辑判断。</p><p>从上面的例子我们可以看到，当你的逻辑升级为二元判断时，你的判断量会加倍，你的代码量也会加倍，这时怎么写更清爽呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const actions &#x3D; newMap([</span><br><span class="line">      [&#39;guest_1&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class="line">      [&#39;guest_2&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class="line">      [&#39;guest_3&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class="line">      [&#39;guest_4&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class="line">      [&#39;guest_5&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class="line">      [&#39;master_1&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class="line">      [&#39;master_2&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class="line">      [&#39;master_3&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class="line">      [&#39;master_4&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class="line">      [&#39;master_5&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class="line">      [&#39;default&#39;, ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class="line">    ])</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 按钮点击事件</span><br><span class="line">     * @param &#123;string&#125; identity 身份标识：guest客态 master主态</span><br><span class="line">     * @param &#123;number&#125; status 活动状态：1 开团进行中 2 开团失败 3 开团成功 4 商品售罄 5 有库存未开团</span><br><span class="line">     *&#x2F;const onButtonClick &#x3D; (identity,status)&#x3D;&gt;&#123;</span><br><span class="line">      let action &#x3D; actions.get(&#96;$&#123;identity&#125;_$&#123;status&#125;&#96;) || actions.get(&#39;default&#39;)</span><br><span class="line">      action.call(this)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述代码核心逻辑是：把两个条件拼接成字符串，并通过以条件拼接字符串作为键，以处理函数作为值的Map对象进行查找并执行，这种写法在多元条件判断时候尤其好用。</p><p>当然上述代码如果用Object对象来实现也是类似的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const actions &#x3D; &#123;</span><br><span class="line">      &#39;guest_1&#39;:()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;,</span><br><span class="line">      &#39;guest_2&#39;:()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;,</span><br><span class="line">      &#x2F;&#x2F;....</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const onButtonClick &#x3D; (identity,status)&#x3D;&gt;&#123;</span><br><span class="line">      let action &#x3D; actions[&#96;$&#123;identity&#125;_$&#123;status&#125;&#96;] || actions[&#39;default&#39;]</span><br><span class="line">      action.call(this)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果有些同学觉得把查询条件拼成字符串有点别扭，那还有一种方案，就是用Map对象，以Object对象作为key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const actions &#x3D; newMap([</span><br><span class="line">  [&#123;identity:&#39;guest&#39;,status:1&#125;,()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class="line">  [&#123;identity:&#39;guest&#39;,status:2&#125;,()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;],</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">const onButtonClick &#x3D; (identity,status)&#x3D;&gt;&#123;</span><br><span class="line">  let action &#x3D; [...actions].filter(([key,value])&#x3D;&gt;(key.identity &#x3D;&#x3D; identity &amp;&amp; key.status &#x3D;&#x3D; status))</span><br><span class="line">  action.forEach(([key,value])&#x3D;&gt;value.call(this))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是又高级了一点点？</p><p>这里也看出来Map与Object的区别，Map可以用任何类型的数据作为key。</p><p>我们现在再将难度升级一点点，假如guest情况下，status1-4的处理逻辑都一样怎么办，最差的情况是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const actions &#x3D; newMap([</span><br><span class="line">      [&#123;identity:&#39;guest&#39;,status:1&#125;,()&#x3D;&gt;&#123;&#x2F;* functionA *&#x2F;&#125;],</span><br><span class="line">      [&#123;identity:&#39;guest&#39;,status:2&#125;,()&#x3D;&gt;&#123;&#x2F;* functionA *&#x2F;&#125;],</span><br><span class="line">      [&#123;identity:&#39;guest&#39;,status:3&#125;,()&#x3D;&gt;&#123;&#x2F;* functionA *&#x2F;&#125;],</span><br><span class="line">      [&#123;identity:&#39;guest&#39;,status:4&#125;,()&#x3D;&gt;&#123;&#x2F;* functionA *&#x2F;&#125;],</span><br><span class="line">      [&#123;identity:&#39;guest&#39;,status:5&#125;,()&#x3D;&gt;&#123;&#x2F;* functionB *&#x2F;&#125;],</span><br><span class="line">      &#x2F;&#x2F;...</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><p>好一点的写法是将处理逻辑函数进行缓存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const actions &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">      const functionA &#x3D; ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;</span><br><span class="line">      const functionB &#x3D; ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;</span><br><span class="line">      returnnewMap([</span><br><span class="line">        [&#123;identity:&#39;guest&#39;,status:1&#125;,functionA],</span><br><span class="line">        [&#123;identity:&#39;guest&#39;,status:2&#125;,functionA],</span><br><span class="line">        [&#123;identity:&#39;guest&#39;,status:3&#125;,functionA],</span><br><span class="line">        [&#123;identity:&#39;guest&#39;,status:4&#125;,functionA],</span><br><span class="line">        [&#123;identity:&#39;guest&#39;,status:5&#125;,functionB],</span><br><span class="line">        &#x2F;&#x2F;...</span><br><span class="line">      ])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const onButtonClick &#x3D; (identity,status)&#x3D;&gt;&#123;</span><br><span class="line">      let action &#x3D; [...actions()].filter(([key,value])&#x3D;&gt;(key.identity &#x3D;&#x3D; identity &amp;&amp; key.status &#x3D;&#x3D; status))</span><br><span class="line">      action.forEach(([key,value])&#x3D;&gt;value.call(this))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样写已经能满足日常需求了，但认真一点讲，上面重写了4次functionA还是有点不爽，假如判断条件变得特别复杂，比如identity有3种状态，status有10种状态，那你需要定义30条处理逻辑，而往往这些逻辑里面很多都是相同的，这似乎也是笔者不想接受的，那可以这样实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const actions &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">      const functionA &#x3D; ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;</span><br><span class="line">      const functionB &#x3D; ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;</span><br><span class="line">      returnnewMap([</span><br><span class="line">        [&#x2F;^guest_[1-4]$&#x2F;,functionA],</span><br><span class="line">        [&#x2F;^guest_5$&#x2F;,functionB],</span><br><span class="line">        &#x2F;&#x2F;...</span><br><span class="line">      ])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const onButtonClick &#x3D; (identity,status)&#x3D;&gt;&#123;</span><br><span class="line">      let action &#x3D; [...actions()].filter(([key,value])&#x3D;&gt;(key.test(&#96;$&#123;identity&#125;_$&#123;status&#125;&#96;)))</span><br><span class="line">      action.forEach(([key,value])&#x3D;&gt;value.call(this))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里Map的优势更加凸显，可以用正则类型作为key了，这样就有了无限可能，假如需求变成，凡是guest情况都要发送一个日志埋点，不同status情况也需要单独的逻辑处理，那我们可以这样写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const actions &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">      const functionA &#x3D; ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;</span><br><span class="line">      const functionB &#x3D; ()&#x3D;&gt;&#123;&#x2F;*do sth*&#x2F;&#125;</span><br><span class="line">      const functionC &#x3D; ()&#x3D;&gt;&#123;&#x2F;*send log*&#x2F;&#125;</span><br><span class="line">      returnnewMap([</span><br><span class="line">        [&#x2F;^guest_[1-4]$&#x2F;,functionA],</span><br><span class="line">        [&#x2F;^guest_5$&#x2F;,functionB],</span><br><span class="line">        [&#x2F;^guest_.*$&#x2F;,functionC],</span><br><span class="line">        &#x2F;&#x2F;...</span><br><span class="line">      ])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const onButtonClick &#x3D; (identity,status)&#x3D;&gt;&#123;</span><br><span class="line">      let action &#x3D; [...actions()].filter(([key,value])&#x3D;&gt;(key.test(&#96;$&#123;identity&#125;_$&#123;status&#125;&#96;)))</span><br><span class="line">      action.forEach(([key,value])&#x3D;&gt;value.call(this))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>也就是说利用数组循环的特性，符合正则条件的逻辑都会被执行，那就可以同时执行公共逻辑和单独逻辑，因为正则的存在，你可以打开想象力解锁更多的玩法，本文就不赘述了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文已经教你了8种逻辑判断写法，包括：</p><p>if/else<br>switch<br>一元判断时：存到Object里<br>一元判断时：存到Map里<br>多元判断时：将condition拼接成字符串存到Object里<br>多元判断时：将condition拼接成字符串存到Map里<br>多元判断时：将condition存为Object存到Map里<br>多元判断时：将condition写作正则存到Map里<br>至此，本文也将告一段落，愿你未来的人生里，不只是有if/else/switch。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js防抖和节流</title>
      <link href="/2020/07/04/js%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
      <url>/2020/07/04/js%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。</p><a id="more"></a><h2 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h2><p>函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</p><p>一起来实现个简单的debounce~</p><p>防抖debounce代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 防抖</span><br><span class="line"><span class="keyword">function</span> debounce(fn, <span class="built_in">wait</span>) &#123;    </span><br><span class="line">    var timeout = null;    </span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;        </span><br><span class="line">        <span class="keyword">if</span>(timeout !== null)   clearTimeout(timeout);        </span><br><span class="line">        timeout = setTimeout(fn, <span class="built_in">wait</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 处理函数</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">handle</span></span>() &#123;    </span><br><span class="line">    console.log(Math.random()); </span><br><span class="line">&#125;</span><br><span class="line">// 滚动事件</span><br><span class="line">window.addEventListener(<span class="string">'scroll'</span>, debounce(handle, 1000));</span><br></pre></td></tr></table></figure><p>当持续触发scroll事件时，事件处理函数handle只在停止滚动1000毫秒之后才会调用一次，也就是说在持续触发scroll事件的过程中，事件处理函数handle一直没有执行。</p><h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><p>函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。</p><p>函数节流主要有两种实现方法：时间戳和定时器。接下来分别用两种方法实现throttle~</p><p>节流throttle代码（时间戳）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var throttle &#x3D; function(func, delay) &#123;            </span><br><span class="line">　　var prev &#x3D; Date.now();            </span><br><span class="line">　　return function() &#123;                </span><br><span class="line">　　　　var context &#x3D; this;                </span><br><span class="line">　　　　var args &#x3D; arguments;                </span><br><span class="line">　　　　var now &#x3D; Date.now();                </span><br><span class="line">　　　　if (now - prev &gt;&#x3D; delay) &#123;                    </span><br><span class="line">　　　　　　func.apply(context, args);                    </span><br><span class="line">　　　　　　prev &#x3D; Date.now();                </span><br><span class="line">　　　　&#125;            </span><br><span class="line">　　&#125;        </span><br><span class="line">&#125;        </span><br><span class="line">function handle() &#123;            </span><br><span class="line">　　console.log(Math.random());        </span><br><span class="line">&#125;        </span><br><span class="line">window.addEventListener(&#39;scroll&#39;, throttle(handle, 1000));</span><br></pre></td></tr></table></figure><p>当高频事件触发时，第一次会立即执行（给scroll事件绑定函数与真正触发事件的间隔一般大于delay，如果你非要在网页加载1000毫秒以内就去滚动网页的话，我也没办法o(╥﹏╥)o），而后再怎么频繁地触发事件，也都是每delay时间才执行一次。而当最后一次事件触发完毕后，事件也不会再被执行了 （最后一次触发事件与倒数第二次触发事件的间隔小于delay，为什么小于呢？因为大于就不叫高频了呀(<em>╹▽╹</em>)）。</p><p>节流throttle代码（定时器）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 节流throttle代码（定时器）：</span><br><span class="line">var throttle &#x3D; function(func, delay) &#123;            </span><br><span class="line">    var timer &#x3D; null;            </span><br><span class="line">    return function() &#123;                </span><br><span class="line">        var context &#x3D; this;               </span><br><span class="line">        var args &#x3D; arguments;                </span><br><span class="line">        if (!timer) &#123;                    </span><br><span class="line">            timer &#x3D; setTimeout(function() &#123;                        </span><br><span class="line">                func.apply(context, args);                        </span><br><span class="line">                timer &#x3D; null;                    </span><br><span class="line">            &#125;, delay);                </span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;        </span><br><span class="line">function handle() &#123;            </span><br><span class="line">    console.log(Math.random());        </span><br><span class="line">&#125;        </span><br><span class="line">window.addEventListener(&#39;scroll&#39;, throttle(handle, 1000));</span><br></pre></td></tr></table></figure><p>当触发事件的时候，我们设置一个定时器，再次触发事件的时候，如果定时器存在，就不执行，直到delay时间后，定时器执行执行函数，并且清空定时器，这样就可以设置下个定时器。当第一次触发事件时，不会立即执行函数，而是在delay秒后才执行。而后再怎么频繁触发事件，也都是每delay时间才执行一次。当最后一次停止触发后，由于定时器的delay延迟，可能还会执行一次函数。</p><p>节流中用时间戳或定时器都是可以的。更精确地，可以用时间戳+定时器，当第一次触发事件时马上执行事件处理函数，最后一次触发事件后也还会执行一次事件处理函数。</p><p>节流throttle代码（时间戳+定时器）：</p><figure class="highlight plain"><figcaption><span>节流throttle代码（时间戳+定时器）：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var throttle &#x3D; function(func, delay) &#123;     </span><br><span class="line">    var timer &#x3D; null;     </span><br><span class="line">    var startTime &#x3D; Date.now();     </span><br><span class="line">    return function() &#123;             </span><br><span class="line">        var curTime &#x3D; Date.now();             </span><br><span class="line">        var remaining &#x3D; delay - (curTime - startTime);             </span><br><span class="line">        var context &#x3D; this;             </span><br><span class="line">        var args &#x3D; arguments;             </span><br><span class="line">        clearTimeout(timer);              </span><br><span class="line">        if (remaining &lt;&#x3D; 0) &#123;                    </span><br><span class="line">            func.apply(context, args);                    </span><br><span class="line">            startTime &#x3D; Date.now();              </span><br><span class="line">        &#125; else &#123;                    </span><br><span class="line">            timer &#x3D; setTimeout(func, remaining);              </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function handle() &#123;      </span><br><span class="line">    console.log(Math.random());</span><br><span class="line">&#125; </span><br><span class="line">window.addEventListener(&#39;scroll&#39;, throttle(handle, 1000));</span><br></pre></td></tr></table></figure><p>在节流函数内部使用开始时间startTime、当前时间curTime与delay来计算剩余时间remaining，当remaining&lt;=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重新计算一个remaining来判断当前状态。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</p><p>函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。</p><p>区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p><p> 转载自：<a href="https://www.cnblogs.com/momo798/p/9177767.html" target="_blank" rel="noopener">js防抖和节流</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web Worker 使用教程</title>
      <link href="/2020/07/04/web%20worker%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2020/07/04/web%20worker%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。</p><p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p><a id="more"></a><p>转载自<a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" target="_blank" rel="noopener">阮一峰</a></p><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。</p><p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p><p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p><p>Web Worker 有以下几个使用注意点。</p><p>（1）同源限制</p><p>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p><p>（2）DOM 限制</p><p>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。</p><p>（3）通信联系</p><p>Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p><p>（4）脚本限制</p><p>Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</p><p>（5）文件限制</p><p>Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。</p><h2 id="二、基本用法"><a href="#二、基本用法" class="headerlink" title="二、基本用法"></a>二、基本用法</h2><h3 id="2-1-主线程"><a href="#2-1-主线程" class="headerlink" title="2.1 主线程"></a>2.1 主线程</h3><p>主线程采用new命令，调用Worker()构造函数，新建一个 Worker 线程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var worker = new Worker(<span class="string">'work.js'</span>);</span><br></pre></td></tr></table></figure><p>Worker()构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。</p><p>然后，主线程调用worker.postMessage()方法，向 Worker 发消息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker.postMessage(<span class="string">'Hello World'</span>);</span><br><span class="line">worker.postMessage(&#123;method: <span class="string">'echo'</span>, args: [<span class="string">'Work'</span>]&#125;);</span><br></pre></td></tr></table></figure><p>worker.postMessage()方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。</p><p>接着，主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">worker.onmessage &#x3D; function (event) &#123;</span><br><span class="line">  console.log(&#39;Received message &#39; + event.data);</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function doSomething() &#123;</span><br><span class="line">  &#x2F;&#x2F; 执行任务</span><br><span class="line">  worker.postMessage(&#39;Work done!&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，事件对象的data属性可以获取 Worker 发来的数据。</p><p>Worker 完成任务以后，主线程就可以把它关掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.terminate();</span><br></pre></td></tr></table></figure><h3 id="2-2-Worker-线程"><a href="#2-2-Worker-线程" class="headerlink" title="2.2 Worker 线程"></a>2.2 Worker 线程</h3><p>Worker 线程内部需要有一个监听函数，监听message事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">  self.postMessage(&#39;You said: &#39; + e.data);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure><p>上面代码中，self代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 写法一</span><br><span class="line">this.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">  this.postMessage(&#39;You said: &#39; + e.data);</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法二</span><br><span class="line">addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">  postMessage(&#39;You said: &#39; + e.data);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure><p>除了使用self.addEventListener()指定监听函数，也可以使用self.onmessage指定。监听函数的参数是一个事件对象，它的data属性包含主线程发来的数据。self.postMessage()方法用来向主线程发送消息。</p><p>根据主线程发来的数据，Worker 线程可以调用不同的方法，下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">  var data &#x3D; e.data;</span><br><span class="line">  switch (data.cmd) &#123;</span><br><span class="line">    case &#39;start&#39;:</span><br><span class="line">      self.postMessage(&#39;WORKER STARTED: &#39; + data.msg);</span><br><span class="line">      break;</span><br><span class="line">    case &#39;stop&#39;:</span><br><span class="line">      self.postMessage(&#39;WORKER STOPPED: &#39; + data.msg);</span><br><span class="line">      self.close(); &#x2F;&#x2F; Terminates the worker.</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      self.postMessage(&#39;Unknown command: &#39; + data.msg);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure><p>上面代码中，self.close()用于在 Worker 内部关闭自身。</p><h3 id="2-3-Worker-加载脚本"><a href="#2-3-Worker-加载脚本" class="headerlink" title="2.3 Worker 加载脚本"></a>2.3 Worker 加载脚本</h3><p>Worker 内部如果要加载其他脚本，有一个专门的方法importScripts()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">importScripts(&#39;script1.js&#39;);</span><br></pre></td></tr></table></figure><p>该方法可以同时加载多个脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">importScripts(&#39;script1.js&#39;, &#39;script2.js&#39;);</span><br></pre></td></tr></table></figure><h3 id="2-4-错误处理"><a href="#2-4-错误处理" class="headerlink" title="2.4 错误处理"></a>2.4 错误处理</h3><p>主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的error事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">worker.onerror(function (event) &#123;</span><br><span class="line">  console.log([</span><br><span class="line">    &#39;ERROR: Line &#39;, e.lineno, &#39; in &#39;, e.filename, &#39;: &#39;, e.message</span><br><span class="line">  ].join(&#39;&#39;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">worker.addEventListener(&#39;error&#39;, function (event) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Worker 内部也可以监听error事件。</p><h3 id="2-5-关闭-Worker"><a href="#2-5-关闭-Worker" class="headerlink" title="2.5 关闭 Worker"></a>2.5 关闭 Worker</h3><p>使用完毕，为了节省系统资源，必须关闭 Worker。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主线程</span><br><span class="line">worker.terminate();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Worker 线程</span><br><span class="line">self.close();</span><br></pre></td></tr></table></figure><h2 id="三、数据通信"><a href="#三、数据通信" class="headerlink" title="三、数据通信"></a>三、数据通信</h2><p>前面说过，主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 Worker，后者再将它还原。</p><p>主线程与 Worker 之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主线程</span><br><span class="line">var uInt8Array &#x3D; new Uint8Array(new ArrayBuffer(10));</span><br><span class="line">for (var i &#x3D; 0; i &lt; uInt8Array.length; ++i) &#123;</span><br><span class="line">  uInt8Array[i] &#x3D; i * 2; &#x2F;&#x2F; [0, 2, 4, 6, 8,...]</span><br><span class="line">&#125;</span><br><span class="line">worker.postMessage(uInt8Array);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Worker 线程</span><br><span class="line">self.onmessage &#x3D; function (e) &#123;</span><br><span class="line">  var uInt8Array &#x3D; e.data;</span><br><span class="line">  postMessage(&#39;Inside worker.js: uInt8Array.toString() &#x3D; &#39; + uInt8Array.toString());</span><br><span class="line">  postMessage(&#39;Inside worker.js: uInt8Array.byteLength &#x3D; &#39; + uInt8Array.byteLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做Transferable Objects。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。</p><p>如果要直接转移数据的控制权，就要使用下面的写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Transferable Objects 格式</span><br><span class="line">worker.postMessage(arrayBuffer, [arrayBuffer]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 例子</span><br><span class="line">var ab &#x3D; new ArrayBuffer(1);</span><br><span class="line">worker.postMessage(ab, [ab]);</span><br></pre></td></tr></table></figure><h2 id="四、同页面的-Web-Worker"><a href="#四、同页面的-Web-Worker" class="headerlink" title="四、同页面的 Web Worker"></a>四、同页面的 Web Worker</h2><p>通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;script id&#x3D;&quot;worker&quot; type&#x3D;&quot;app&#x2F;worker&quot;&gt;</span><br><span class="line">      addEventListener(&#39;message&#39;, function () &#123;</span><br><span class="line">        postMessage(&#39;some message&#39;);</span><br><span class="line">      &#125;, false);</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>上面是一段嵌入网页的脚本，注意必须指定&lt;script&gt;标签的type属性是一个浏览器不认识的值，上例是app/worker。</p><p>然后，读取这一段嵌入页面的脚本，用 Worker 来处理。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var blob &#x3D; new Blob([document.querySelector(&#39;#worker&#39;).textContent]);</span><br><span class="line">var url &#x3D; window.URL.createObjectURL(blob);</span><br><span class="line">var worker &#x3D; new Worker(url);</span><br><span class="line"></span><br><span class="line">worker.onmessage &#x3D; function (e) &#123;</span><br><span class="line">  &#x2F;&#x2F; e.data &#x3D;&#x3D;&#x3D; &#39;some message&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 URL，再让 Worker 加载这个 URL。这样就做到了，主线程和 Worker 的代码都在同一个网页上面。</p><h2 id="五、实例：Worker-线程完成轮询"><a href="#五、实例：Worker-线程完成轮询" class="headerlink" title="五、实例：Worker 线程完成轮询"></a>五、实例：Worker 线程完成轮询</h2><p>有时，浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在 Worker 里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function createWorker(f) &#123;</span><br><span class="line">  var blob &#x3D; new Blob([&#39;(&#39; + f.toString() +&#39;)()&#39;]);</span><br><span class="line">  var url &#x3D; window.URL.createObjectURL(blob);</span><br><span class="line">  var worker &#x3D; new Worker(url);</span><br><span class="line">  return worker;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var pollingWorker &#x3D; createWorker(function (e) &#123;</span><br><span class="line">  var cache;</span><br><span class="line"></span><br><span class="line">  function compare(new, old) &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">  setInterval(function () &#123;</span><br><span class="line">    fetch(&#39;&#x2F;my-api-endpoint&#39;).then(function (res) &#123;</span><br><span class="line">      var data &#x3D; res.json();</span><br><span class="line"></span><br><span class="line">      if (!compare(data, cache)) &#123;</span><br><span class="line">        cache &#x3D; data;</span><br><span class="line">        self.postMessage(data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pollingWorker.onmessage &#x3D; function () &#123;</span><br><span class="line">  &#x2F;&#x2F; render data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pollingWorker.postMessage(&#39;init&#39;);</span><br></pre></td></tr></table></figure><p>上面代码中，Worker 每秒钟轮询一次数据，然后跟缓存做比较。如果不一致，就说明服务端有了新的变化，因此就要通知主线程。</p><h2 id="六、实例：-Worker-新建-Worker"><a href="#六、实例：-Worker-新建-Worker" class="headerlink" title="六、实例： Worker 新建 Worker"></a>六、实例： Worker 新建 Worker</h2><p>Worker 线程内部还能再新建 Worker 线程（目前只有 Firefox 浏览器支持）。下面的例子是将一个计算密集的任务，分配到10个 Worker。</p><p>主线程代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var worker &#x3D; new Worker(&#39;worker.js&#39;);</span><br><span class="line">worker.onmessage &#x3D; function (event) &#123;</span><br><span class="line">  document.getElementById(&#39;result&#39;).textContent &#x3D; event.data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Worker 线程代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; worker.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; settings</span><br><span class="line">var num_workers &#x3D; 10;</span><br><span class="line">var items_per_worker &#x3D; 1000000;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; start the workers</span><br><span class="line">var result &#x3D; 0;</span><br><span class="line">var pending_workers &#x3D; num_workers;</span><br><span class="line">for (var i &#x3D; 0; i &lt; num_workers; i +&#x3D; 1) &#123;</span><br><span class="line">  var worker &#x3D; new Worker(&#39;core.js&#39;);</span><br><span class="line">  worker.postMessage(i * items_per_worker);</span><br><span class="line">  worker.postMessage((i + 1) * items_per_worker);</span><br><span class="line">  worker.onmessage &#x3D; storeResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; handle the results</span><br><span class="line">function storeResult(event) &#123;</span><br><span class="line">  result +&#x3D; event.data;</span><br><span class="line">  pending_workers -&#x3D; 1;</span><br><span class="line">  if (pending_workers &lt;&#x3D; 0)</span><br><span class="line">    postMessage(result); &#x2F;&#x2F; finished!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Worker 线程内部新建了10个 Worker 线程，并且依次向这10个 Worker 发送消息，告知了计算的起点和终点。计算任务脚本的代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; core.js</span><br><span class="line">var start;</span><br><span class="line">onmessage &#x3D; getStart;</span><br><span class="line">function getStart(event) &#123;</span><br><span class="line">  start &#x3D; event.data;</span><br><span class="line">  onmessage &#x3D; getEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var end;</span><br><span class="line">function getEnd(event) &#123;</span><br><span class="line">  end &#x3D; event.data;</span><br><span class="line">  onmessage &#x3D; null;</span><br><span class="line">  work();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function work() &#123;</span><br><span class="line">  var result &#x3D; 0;</span><br><span class="line">  for (var i &#x3D; start; i &lt; end; i +&#x3D; 1) &#123;</span><br><span class="line">    &#x2F;&#x2F; perform some complex calculation here</span><br><span class="line">    result +&#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  postMessage(result);</span><br><span class="line">  close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、API"><a href="#七、API" class="headerlink" title="七、API"></a>七、API</h2><h3 id="7-1-主线程"><a href="#7-1-主线程" class="headerlink" title="7.1 主线程"></a>7.1 主线程</h3><p>浏览器原生提供Worker()构造函数，用来供主线程生成 Worker 线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var myWorker &#x3D; new Worker(jsUrl, options);</span><br></pre></td></tr></table></figure><p>Worker()构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主线程</span><br><span class="line">var myWorker &#x3D; new Worker(&#39;worker.js&#39;, &#123; name : &#39;myWorker&#39; &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Worker 线程</span><br><span class="line">self.name &#x2F;&#x2F; myWorker</span><br></pre></td></tr></table></figure><p>Worker()构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。Worker 线程对象的属性和方法如下。</p><ul><li>Worker.onerror：指定 error 事件的监听函数。</li><li>Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在Event.data属性中。</li><li>Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li><li>Worker.postMessage()：向 Worker 线程发送消息。</li><li>Worker.terminate()：立即终止 Worker 线程。</li></ul><h3 id="7-2-Worker-线程"><a href="#7-2-Worker-线程" class="headerlink" title="7.2 Worker 线程"></a>7.2 Worker 线程</h3><p>Web Worker 有自己的全局对象，不是主线程的window，而是一个专门为 Worker 定制的全局对象。因此定义在window上面的对象和方法不是全部都可以使用。</p><p>Worker 线程有一些自己的全局属性和方法。</p><ul><li>self.name： Worker 的名字。该属性只读，由构造函数指定。</li><li>self.onmessage：指定message事件的监听函数。</li><li>self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li><li>self.close()：关闭 Worker 线程。</li><li>self.postMessage()：向产生这个 Worker 线程发送消息。</li><li>self.importScripts()：加载 JS 脚本。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
